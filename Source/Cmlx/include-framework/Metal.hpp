#ifdef __cplusplus
//
// Metal.hpp.in
//
// Autogenerated from commit 654854863abf7b4ef2a657761421bf6565493e40.
//
// Copyright 2020-2024 Apple Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

#pragma once

#define _NS_WEAK_IMPORT __attribute__((weak_import))
#ifdef METALCPP_SYMBOL_VISIBILITY_HIDDEN
#define _NS_EXPORT __attribute__((visibility("hidden")))
#else
#define _NS_EXPORT __attribute__((visibility("default")))
#endif // METALCPP_SYMBOL_VISIBILITY_HIDDEN
#define _NS_EXTERN extern "C" _NS_EXPORT
#define _NS_INLINE inline __attribute__((always_inline))
#define _NS_PACKED __attribute__((packed))

#define _NS_CONST(type, name) _NS_EXTERN type const name
#define _NS_ENUM(type, name) enum name : type
#define _NS_OPTIONS(type, name) \
    using name = type;          \
    enum : name

#define _NS_CAST_TO_UINT(value) static_cast<NS::UInteger>(value)
#define _NS_VALIDATE_SIZE(ns, name) static_assert(sizeof(ns::name) == sizeof(ns##name), "size mismatch " #ns "::" #name)
#define _NS_VALIDATE_ENUM(ns, name) static_assert(_NS_CAST_TO_UINT(ns::name) == _NS_CAST_TO_UINT(ns##name), "value mismatch " #ns "::" #name)

#include <objc/runtime.h>

#define _NS_PRIVATE_CLS(symbol) (Private::Class::s_k##symbol)
#define _NS_PRIVATE_SEL(accessor) (Private::Selector::s_k##accessor)

#if defined(NS_PRIVATE_IMPLEMENTATION)

#include <dlfcn.h>

namespace NS::Private
{
    template <typename _Type>
    inline _Type const LoadSymbol(const char* pSymbol)
    {
        const _Type* pAddress = static_cast<_Type*>(dlsym(RTLD_DEFAULT, pSymbol));

        return pAddress ? *pAddress : _Type();
    }
} // NS::Private

#ifdef METALCPP_SYMBOL_VISIBILITY_HIDDEN
#define _NS_PRIVATE_VISIBILITY __attribute__((visibility("hidden")))
#else
#define _NS_PRIVATE_VISIBILITY __attribute__((visibility("default")))
#endif // METALCPP_SYMBOL_VISIBILITY_HIDDEN

#define _NS_PRIVATE_IMPORT __attribute__((weak_import))

#ifdef __OBJC__
#define _NS_PRIVATE_OBJC_LOOKUP_CLASS(symbol) ((__bridge void*)objc_lookUpClass(#symbol))
#define _NS_PRIVATE_OBJC_GET_PROTOCOL(symbol) ((__bridge void*)objc_getProtocol(#symbol))
#else
#define _NS_PRIVATE_OBJC_LOOKUP_CLASS(symbol) objc_lookUpClass(#symbol)
#define _NS_PRIVATE_OBJC_GET_PROTOCOL(symbol) objc_getProtocol(#symbol)
#endif // __OBJC__

#define _NS_PRIVATE_DEF_CLS(symbol) void* s_k##symbol _NS_PRIVATE_VISIBILITY = _NS_PRIVATE_OBJC_LOOKUP_CLASS(symbol)
#define _NS_PRIVATE_DEF_PRO(symbol) void* s_k##symbol _NS_PRIVATE_VISIBILITY = _NS_PRIVATE_OBJC_GET_PROTOCOL(symbol)
#define _NS_PRIVATE_DEF_SEL(accessor, symbol) SEL s_k##accessor _NS_PRIVATE_VISIBILITY = sel_registerName(symbol)

#if defined(__MAC_26_0) || defined(__IPHONE_26_0) || defined(__TVOS_26_0)
#define _NS_PRIVATE_DEF_CONST(type, symbol)              \
    _NS_EXTERN type const NS##symbol _NS_PRIVATE_IMPORT; \
    type const                       NS::symbol = (nullptr != &NS##symbol) ? NS##symbol : type()
#else
#define _NS_PRIVATE_DEF_CONST(type, symbol) \
    _NS_EXTERN type const MTL##symbol _NS_PRIVATE_IMPORT; \
    type const             NS::symbol = Private::LoadSymbol<type>("NS" #symbol)
#endif

#else

#define _NS_PRIVATE_DEF_CLS(symbol) extern void* s_k##symbol
#define _NS_PRIVATE_DEF_PRO(symbol) extern void* s_k##symbol
#define _NS_PRIVATE_DEF_SEL(accessor, symbol) extern SEL s_k##accessor
#define _NS_PRIVATE_DEF_CONST(type, symbol) extern type const NS::symbol

#endif // NS_PRIVATE_IMPLEMENTATION

namespace NS
{
namespace Private
{
    namespace Class
    {

        _NS_PRIVATE_DEF_CLS(NSArray);
        _NS_PRIVATE_DEF_CLS(NSAutoreleasePool);
        _NS_PRIVATE_DEF_CLS(NSBundle);
        _NS_PRIVATE_DEF_CLS(NSCondition);
        _NS_PRIVATE_DEF_CLS(NSDate);
        _NS_PRIVATE_DEF_CLS(NSDictionary);
        _NS_PRIVATE_DEF_CLS(NSError);
        _NS_PRIVATE_DEF_CLS(NSNotificationCenter);
        _NS_PRIVATE_DEF_CLS(NSNumber);
        _NS_PRIVATE_DEF_CLS(NSObject);
        _NS_PRIVATE_DEF_CLS(NSProcessInfo);
        _NS_PRIVATE_DEF_CLS(NSSet);
        _NS_PRIVATE_DEF_CLS(NSString);
        _NS_PRIVATE_DEF_CLS(NSURL);
        _NS_PRIVATE_DEF_CLS(NSValue);

    } // Class
} // Private
} // MTL

namespace NS
{
namespace Private
{
    namespace Protocol
    {

    } // Protocol
} // Private
} // NS

namespace NS
{
namespace Private
{
    namespace Selector
    {

        _NS_PRIVATE_DEF_SEL(addObject_,
            "addObject:");
        _NS_PRIVATE_DEF_SEL(addObserverName_object_queue_block_,
            "addObserverForName:object:queue:usingBlock:");
        _NS_PRIVATE_DEF_SEL(activeProcessorCount,
            "activeProcessorCount");
        _NS_PRIVATE_DEF_SEL(allBundles,
            "allBundles");
        _NS_PRIVATE_DEF_SEL(allFrameworks,
            "allFrameworks");
        _NS_PRIVATE_DEF_SEL(allObjects,
            "allObjects");
        _NS_PRIVATE_DEF_SEL(alloc,
            "alloc");
        _NS_PRIVATE_DEF_SEL(appStoreReceiptURL,
            "appStoreReceiptURL");
        _NS_PRIVATE_DEF_SEL(arguments,
            "arguments");
        _NS_PRIVATE_DEF_SEL(array,
            "array");
        _NS_PRIVATE_DEF_SEL(arrayWithObject_,
            "arrayWithObject:");
        _NS_PRIVATE_DEF_SEL(arrayWithObjects_count_,
            "arrayWithObjects:count:");
        _NS_PRIVATE_DEF_SEL(automaticTerminationSupportEnabled,
            "automaticTerminationSupportEnabled");
        _NS_PRIVATE_DEF_SEL(autorelease,
            "autorelease");
        _NS_PRIVATE_DEF_SEL(beginActivityWithOptions_reason_,
            "beginActivityWithOptions:reason:");
        _NS_PRIVATE_DEF_SEL(boolValue,
            "boolValue");
        _NS_PRIVATE_DEF_SEL(broadcast,
            "broadcast");
        _NS_PRIVATE_DEF_SEL(builtInPlugInsPath,
            "builtInPlugInsPath");
        _NS_PRIVATE_DEF_SEL(builtInPlugInsURL,
            "builtInPlugInsURL");
        _NS_PRIVATE_DEF_SEL(bundleIdentifier,
            "bundleIdentifier");
        _NS_PRIVATE_DEF_SEL(bundlePath,
            "bundlePath");
        _NS_PRIVATE_DEF_SEL(bundleURL,
            "bundleURL");
        _NS_PRIVATE_DEF_SEL(bundleWithPath_,
            "bundleWithPath:");
        _NS_PRIVATE_DEF_SEL(bundleWithURL_,
            "bundleWithURL:");
        _NS_PRIVATE_DEF_SEL(caseInsensitiveCompare_,
            "caseInsensitiveCompare:");
        _NS_PRIVATE_DEF_SEL(characterAtIndex_,
            "characterAtIndex:");
        _NS_PRIVATE_DEF_SEL(charValue,
            "charValue");
        _NS_PRIVATE_DEF_SEL(countByEnumeratingWithState_objects_count_,
            "countByEnumeratingWithState:objects:count:");
        _NS_PRIVATE_DEF_SEL(cStringUsingEncoding_,
            "cStringUsingEncoding:");
        _NS_PRIVATE_DEF_SEL(code,
            "code");
        _NS_PRIVATE_DEF_SEL(compare_,
            "compare:");
        _NS_PRIVATE_DEF_SEL(copy,
            "copy");
        _NS_PRIVATE_DEF_SEL(count,
            "count");
        _NS_PRIVATE_DEF_SEL(dateWithTimeIntervalSinceNow_,
            "dateWithTimeIntervalSinceNow:");
        _NS_PRIVATE_DEF_SEL(defaultCenter,
            "defaultCenter");
        _NS_PRIVATE_DEF_SEL(descriptionWithLocale_,
            "descriptionWithLocale:");
        _NS_PRIVATE_DEF_SEL(disableAutomaticTermination_,
            "disableAutomaticTermination:");
        _NS_PRIVATE_DEF_SEL(disableSuddenTermination,
            "disableSuddenTermination");
        _NS_PRIVATE_DEF_SEL(debugDescription,
            "debugDescription");
        _NS_PRIVATE_DEF_SEL(description,
            "description");
        _NS_PRIVATE_DEF_SEL(dictionary,
            "dictionary");
        _NS_PRIVATE_DEF_SEL(dictionaryWithObject_forKey_,
            "dictionaryWithObject:forKey:");
        _NS_PRIVATE_DEF_SEL(dictionaryWithObjects_forKeys_count_,
            "dictionaryWithObjects:forKeys:count:");
        _NS_PRIVATE_DEF_SEL(domain,
            "domain");
        _NS_PRIVATE_DEF_SEL(doubleValue,
            "doubleValue");
        _NS_PRIVATE_DEF_SEL(drain,
            "drain");
        _NS_PRIVATE_DEF_SEL(enableAutomaticTermination_,
            "enableAutomaticTermination:");
        _NS_PRIVATE_DEF_SEL(enableSuddenTermination,
            "enableSuddenTermination");
        _NS_PRIVATE_DEF_SEL(endActivity_,
            "endActivity:");
        _NS_PRIVATE_DEF_SEL(environment,
            "environment");
        _NS_PRIVATE_DEF_SEL(errorWithDomain_code_userInfo_,
            "errorWithDomain:code:userInfo:");
        _NS_PRIVATE_DEF_SEL(executablePath,
            "executablePath");
        _NS_PRIVATE_DEF_SEL(executableURL,
            "executableURL");
        _NS_PRIVATE_DEF_SEL(fileSystemRepresentation,
            "fileSystemRepresentation");
        _NS_PRIVATE_DEF_SEL(fileURLWithPath_,
            "fileURLWithPath:");
        _NS_PRIVATE_DEF_SEL(floatValue,
            "floatValue");
        _NS_PRIVATE_DEF_SEL(fullUserName,
            "fullUserName");
        _NS_PRIVATE_DEF_SEL(getValue_size_,
            "getValue:size:");
        _NS_PRIVATE_DEF_SEL(globallyUniqueString,
            "globallyUniqueString");
        _NS_PRIVATE_DEF_SEL(hash,
            "hash");
        _NS_PRIVATE_DEF_SEL(hasPerformanceProfile_,
            "hasPerformanceProfile:");
        _NS_PRIVATE_DEF_SEL(hostName,
            "hostName");
        _NS_PRIVATE_DEF_SEL(infoDictionary,
            "infoDictionary");
        _NS_PRIVATE_DEF_SEL(init,
            "init");
        _NS_PRIVATE_DEF_SEL(initFileURLWithPath_,
            "initFileURLWithPath:");
        _NS_PRIVATE_DEF_SEL(initWithBool_,
            "initWithBool:");
        _NS_PRIVATE_DEF_SEL(initWithBytes_objCType_,
            "initWithBytes:objCType:");
        _NS_PRIVATE_DEF_SEL(initWithBytesNoCopy_length_encoding_freeWhenDone_,
            "initWithBytesNoCopy:length:encoding:freeWhenDone:");
        _NS_PRIVATE_DEF_SEL(initWithChar_,
            "initWithChar:");
        _NS_PRIVATE_DEF_SEL(initWithCoder_,
            "initWithCoder:");
        _NS_PRIVATE_DEF_SEL(initWithCString_encoding_,
            "initWithCString:encoding:");
        _NS_PRIVATE_DEF_SEL(initWithDomain_code_userInfo_,
            "initWithDomain:code:userInfo:");
        _NS_PRIVATE_DEF_SEL(initWithDouble_,
            "initWithDouble:");
        _NS_PRIVATE_DEF_SEL(initWithFloat_,
            "initWithFloat:");
        _NS_PRIVATE_DEF_SEL(initWithInt_,
            "initWithInt:");
        _NS_PRIVATE_DEF_SEL(initWithLong_,
            "initWithLong:");
        _NS_PRIVATE_DEF_SEL(initWithLongLong_,
            "initWithLongLong:");
        _NS_PRIVATE_DEF_SEL(initWithObjects_count_,
            "initWithObjects:count:");
        _NS_PRIVATE_DEF_SEL(initWithObjects_forKeys_count_,
            "initWithObjects:forKeys:count:");
        _NS_PRIVATE_DEF_SEL(initWithPath_,
            "initWithPath:");
        _NS_PRIVATE_DEF_SEL(initWithShort_,
            "initWithShort:");
        _NS_PRIVATE_DEF_SEL(initWithString_,
            "initWithString:");
        _NS_PRIVATE_DEF_SEL(initWithUnsignedChar_,
            "initWithUnsignedChar:");
        _NS_PRIVATE_DEF_SEL(initWithUnsignedInt_,
            "initWithUnsignedInt:");
        _NS_PRIVATE_DEF_SEL(initWithUnsignedLong_,
            "initWithUnsignedLong:");
        _NS_PRIVATE_DEF_SEL(initWithUnsignedLongLong_,
            "initWithUnsignedLongLong:");
        _NS_PRIVATE_DEF_SEL(initWithUnsignedShort_,
            "initWithUnsignedShort:");
        _NS_PRIVATE_DEF_SEL(initWithURL_,
            "initWithURL:");
        _NS_PRIVATE_DEF_SEL(integerValue,
            "integerValue");
        _NS_PRIVATE_DEF_SEL(intValue,
            "intValue");
        _NS_PRIVATE_DEF_SEL(isDeviceCertified_,
            "isDeviceCertifiedFor:");
        _NS_PRIVATE_DEF_SEL(isEqual_,
            "isEqual:");
        _NS_PRIVATE_DEF_SEL(isEqualToNumber_,
            "isEqualToNumber:");
        _NS_PRIVATE_DEF_SEL(isEqualToString_,
            "isEqualToString:");
        _NS_PRIVATE_DEF_SEL(isEqualToValue_,
            "isEqualToValue:");
        _NS_PRIVATE_DEF_SEL(isiOSAppOnMac,
            "isiOSAppOnMac");
        _NS_PRIVATE_DEF_SEL(isLoaded,
            "isLoaded");
        _NS_PRIVATE_DEF_SEL(isLowPowerModeEnabled,
            "isLowPowerModeEnabled");
        _NS_PRIVATE_DEF_SEL(isMacCatalystApp,
            "isMacCatalystApp");
        _NS_PRIVATE_DEF_SEL(isOperatingSystemAtLeastVersion_,
            "isOperatingSystemAtLeastVersion:");
        _NS_PRIVATE_DEF_SEL(keyEnumerator,
            "keyEnumerator");
        _NS_PRIVATE_DEF_SEL(length,
            "length");
        _NS_PRIVATE_DEF_SEL(lengthOfBytesUsingEncoding_,
            "lengthOfBytesUsingEncoding:");
        _NS_PRIVATE_DEF_SEL(load,
            "load");
        _NS_PRIVATE_DEF_SEL(loadAndReturnError_,
            "loadAndReturnError:");
        _NS_PRIVATE_DEF_SEL(localizedDescription,
            "localizedDescription");
        _NS_PRIVATE_DEF_SEL(localizedFailureReason,
            "localizedFailureReason");
        _NS_PRIVATE_DEF_SEL(localizedInfoDictionary,
            "localizedInfoDictionary");
        _NS_PRIVATE_DEF_SEL(localizedRecoveryOptions,
            "localizedRecoveryOptions");
        _NS_PRIVATE_DEF_SEL(localizedRecoverySuggestion,
            "localizedRecoverySuggestion");
        _NS_PRIVATE_DEF_SEL(localizedStringForKey_value_table_,
            "localizedStringForKey:value:table:");
        _NS_PRIVATE_DEF_SEL(lock,
            "lock");
        _NS_PRIVATE_DEF_SEL(longValue,
            "longValue");
        _NS_PRIVATE_DEF_SEL(longLongValue,
            "longLongValue");
        _NS_PRIVATE_DEF_SEL(mainBundle,
            "mainBundle");
        _NS_PRIVATE_DEF_SEL(maximumLengthOfBytesUsingEncoding_,
            "maximumLengthOfBytesUsingEncoding:");
        _NS_PRIVATE_DEF_SEL(methodSignatureForSelector_,
            "methodSignatureForSelector:");
        _NS_PRIVATE_DEF_SEL(mutableBytes,
            "mutableBytes");
        _NS_PRIVATE_DEF_SEL(name,
            "name");
        _NS_PRIVATE_DEF_SEL(nextObject,
            "nextObject");
        _NS_PRIVATE_DEF_SEL(numberWithBool_,
            "numberWithBool:");
        _NS_PRIVATE_DEF_SEL(numberWithChar_,
            "numberWithChar:");
        _NS_PRIVATE_DEF_SEL(numberWithDouble_,
            "numberWithDouble:");
        _NS_PRIVATE_DEF_SEL(numberWithFloat_,
            "numberWithFloat:");
        _NS_PRIVATE_DEF_SEL(numberWithInt_,
            "numberWithInt:");
        _NS_PRIVATE_DEF_SEL(numberWithLong_,
            "numberWithLong:");
        _NS_PRIVATE_DEF_SEL(numberWithLongLong_,
            "numberWithLongLong:");
        _NS_PRIVATE_DEF_SEL(numberWithShort_,
            "numberWithShort:");
        _NS_PRIVATE_DEF_SEL(numberWithUnsignedChar_,
            "numberWithUnsignedChar:");
        _NS_PRIVATE_DEF_SEL(numberWithUnsignedInt_,
            "numberWithUnsignedInt:");
        _NS_PRIVATE_DEF_SEL(numberWithUnsignedLong_,
            "numberWithUnsignedLong:");
        _NS_PRIVATE_DEF_SEL(numberWithUnsignedLongLong_,
            "numberWithUnsignedLongLong:");
        _NS_PRIVATE_DEF_SEL(numberWithUnsignedShort_,
            "numberWithUnsignedShort:");
        _NS_PRIVATE_DEF_SEL(objCType,
            "objCType");
        _NS_PRIVATE_DEF_SEL(object,
            "object");
        _NS_PRIVATE_DEF_SEL(objectAtIndex_,
            "objectAtIndex:");
        _NS_PRIVATE_DEF_SEL(objectEnumerator,
            "objectEnumerator");
        _NS_PRIVATE_DEF_SEL(objectForInfoDictionaryKey_,
            "objectForInfoDictionaryKey:");
        _NS_PRIVATE_DEF_SEL(objectForKey_,
            "objectForKey:");
        _NS_PRIVATE_DEF_SEL(operatingSystem,
            "operatingSystem");
        _NS_PRIVATE_DEF_SEL(operatingSystemVersion,
            "operatingSystemVersion");
        _NS_PRIVATE_DEF_SEL(operatingSystemVersionString,
            "operatingSystemVersionString");
        _NS_PRIVATE_DEF_SEL(pathForAuxiliaryExecutable_,
            "pathForAuxiliaryExecutable:");
        _NS_PRIVATE_DEF_SEL(performActivityWithOptions_reason_usingBlock_,
            "performActivityWithOptions:reason:usingBlock:");
        _NS_PRIVATE_DEF_SEL(performExpiringActivityWithReason_usingBlock_,
            "performExpiringActivityWithReason:usingBlock:");
        _NS_PRIVATE_DEF_SEL(physicalMemory,
            "physicalMemory");
        _NS_PRIVATE_DEF_SEL(pointerValue,
            "pointerValue");
        _NS_PRIVATE_DEF_SEL(preflightAndReturnError_,
            "preflightAndReturnError:");
        _NS_PRIVATE_DEF_SEL(privateFrameworksPath,
            "privateFrameworksPath");
        _NS_PRIVATE_DEF_SEL(privateFrameworksURL,
            "privateFrameworksURL");
        _NS_PRIVATE_DEF_SEL(processIdentifier,
            "processIdentifier");
        _NS_PRIVATE_DEF_SEL(processInfo,
            "processInfo");
        _NS_PRIVATE_DEF_SEL(processName,
            "processName");
        _NS_PRIVATE_DEF_SEL(processorCount,
            "processorCount");
        _NS_PRIVATE_DEF_SEL(rangeOfString_options_,
            "rangeOfString:options:");
        _NS_PRIVATE_DEF_SEL(release,
            "release");
        _NS_PRIVATE_DEF_SEL(removeObserver_,
            "removeObserver:");
        _NS_PRIVATE_DEF_SEL(resourcePath,
            "resourcePath");
        _NS_PRIVATE_DEF_SEL(resourceURL,
            "resourceURL");
        _NS_PRIVATE_DEF_SEL(respondsToSelector_,
            "respondsToSelector:");
        _NS_PRIVATE_DEF_SEL(retain,
            "retain");
        _NS_PRIVATE_DEF_SEL(retainCount,
            "retainCount");
        _NS_PRIVATE_DEF_SEL(setAutomaticTerminationSupportEnabled_,
            "setAutomaticTerminationSupportEnabled:");
        _NS_PRIVATE_DEF_SEL(setProcessName_,
            "setProcessName:");
        _NS_PRIVATE_DEF_SEL(sharedFrameworksPath,
            "sharedFrameworksPath");
        _NS_PRIVATE_DEF_SEL(sharedFrameworksURL,
            "sharedFrameworksURL");
        _NS_PRIVATE_DEF_SEL(sharedSupportPath,
            "sharedSupportPath");
        _NS_PRIVATE_DEF_SEL(sharedSupportURL,
            "sharedSupportURL");
        _NS_PRIVATE_DEF_SEL(shortValue,
            "shortValue");
        _NS_PRIVATE_DEF_SEL(showPools,
            "showPools");
        _NS_PRIVATE_DEF_SEL(signal,
            "signal");
        _NS_PRIVATE_DEF_SEL(string,
            "string");
        _NS_PRIVATE_DEF_SEL(stringValue,
            "stringValue");
        _NS_PRIVATE_DEF_SEL(stringWithString_,
            "stringWithString:");
        _NS_PRIVATE_DEF_SEL(stringWithCString_encoding_,
            "stringWithCString:encoding:");
        _NS_PRIVATE_DEF_SEL(stringByAppendingString_,
            "stringByAppendingString:");
        _NS_PRIVATE_DEF_SEL(systemUptime,
            "systemUptime");
        _NS_PRIVATE_DEF_SEL(thermalState,
            "thermalState");
        _NS_PRIVATE_DEF_SEL(unload,
            "unload");
        _NS_PRIVATE_DEF_SEL(unlock,
            "unlock");
        _NS_PRIVATE_DEF_SEL(unsignedCharValue,
            "unsignedCharValue");
        _NS_PRIVATE_DEF_SEL(unsignedIntegerValue,
            "unsignedIntegerValue");
        _NS_PRIVATE_DEF_SEL(unsignedIntValue,
            "unsignedIntValue");
        _NS_PRIVATE_DEF_SEL(unsignedLongValue,
            "unsignedLongValue");
        _NS_PRIVATE_DEF_SEL(unsignedLongLongValue,
            "unsignedLongLongValue");
        _NS_PRIVATE_DEF_SEL(unsignedShortValue,
            "unsignedShortValue");
        _NS_PRIVATE_DEF_SEL(URLForAuxiliaryExecutable_,
            "URLForAuxiliaryExecutable:");
        _NS_PRIVATE_DEF_SEL(userInfo,
            "userInfo");
        _NS_PRIVATE_DEF_SEL(userName,
            "userName");
        _NS_PRIVATE_DEF_SEL(UTF8String,
            "UTF8String");
        _NS_PRIVATE_DEF_SEL(valueWithBytes_objCType_,
            "valueWithBytes:objCType:");
        _NS_PRIVATE_DEF_SEL(valueWithPointer_,
            "valueWithPointer:");
        _NS_PRIVATE_DEF_SEL(wait,
            "wait");
        _NS_PRIVATE_DEF_SEL(waitUntilDate_,
            "waitUntilDate:");
    } // Class
} // Private
} // MTL

#include <CoreFoundation/CoreFoundation.h>
#include <cstdint>

namespace NS
{
using TimeInterval = double;

using Integer = std::intptr_t;
using UInteger = std::uintptr_t;

const Integer  IntegerMax = INTPTR_MAX;
const Integer  IntegerMin = INTPTR_MIN;
const UInteger UIntegerMax = UINTPTR_MAX;

struct OperatingSystemVersion
{
    Integer majorVersion;
    Integer minorVersion;
    Integer patchVersion;
} _NS_PACKED;
}

#include <objc/message.h>
#include <objc/runtime.h>

#include <type_traits>

namespace NS
{
template <class _Class, class _Base = class Object>
class _NS_EXPORT Referencing : public _Base
{
public:
    _Class*  retain();
    void     release();

    _Class*  autorelease();

    UInteger retainCount() const;
};

template <class _Class, class _Base = class Object>
class Copying : public Referencing<_Class, _Base>
{
public:
    _Class* copy() const;
};

template <class _Class, class _Base = class Object>
class SecureCoding : public Referencing<_Class, _Base>
{
};

class Object : public Referencing<Object, objc_object>
{
public:
    UInteger      hash() const;
    bool          isEqual(const Object* pObject) const;

    class String* description() const;
    class String* debugDescription() const;

protected:
    friend class Referencing<Object, objc_object>;

    template <class _Class>
    static _Class* alloc(const char* pClassName);
    template <class _Class>
    static _Class* alloc(const void* pClass);
    template <class _Class>
    _Class* init();

    template <class _Dst>
    static _Dst                   bridgingCast(const void* pObj);
    static class MethodSignature* methodSignatureForSelector(const void* pObj, SEL selector);
    static bool                   respondsToSelector(const void* pObj, SEL selector);
    template <typename _Type>
    static constexpr bool doesRequireMsgSendStret();
    template <typename _Ret, typename... _Args>
    static _Ret sendMessage(const void* pObj, SEL selector, _Args... args);
    template <typename _Ret, typename... _Args>
    static _Ret sendMessageSafe(const void* pObj, SEL selector, _Args... args);

private:
    Object() = delete;
    Object(const Object&) = delete;
    ~Object() = delete;

    Object& operator=(const Object&) = delete;
};
}

template <class _Class, class _Base /* = Object */>
_NS_INLINE _Class* NS::Referencing<_Class, _Base>::retain()
{
    return Object::sendMessage<_Class*>(this, _NS_PRIVATE_SEL(retain));
}

template <class _Class, class _Base /* = Object */>
_NS_INLINE void NS::Referencing<_Class, _Base>::release()
{
    Object::sendMessage<void>(this, _NS_PRIVATE_SEL(release));
}

template <class _Class, class _Base /* = Object */>
_NS_INLINE _Class* NS::Referencing<_Class, _Base>::autorelease()
{
    return Object::sendMessage<_Class*>(this, _NS_PRIVATE_SEL(autorelease));
}

template <class _Class, class _Base /* = Object */>
_NS_INLINE NS::UInteger NS::Referencing<_Class, _Base>::retainCount() const
{
    return Object::sendMessage<UInteger>(this, _NS_PRIVATE_SEL(retainCount));
}

template <class _Class, class _Base /* = Object */>
_NS_INLINE _Class* NS::Copying<_Class, _Base>::copy() const
{
    return Object::sendMessage<_Class*>(this, _NS_PRIVATE_SEL(copy));
}

template <class _Dst>
_NS_INLINE _Dst NS::Object::bridgingCast(const void* pObj)
{
#ifdef __OBJC__
    return (__bridge _Dst)pObj;
#else
    return (_Dst)pObj;
#endif // __OBJC__
}

template <typename _Type>
_NS_INLINE constexpr bool NS::Object::doesRequireMsgSendStret()
{
#if (defined(__i386__) || defined(__x86_64__))
    constexpr size_t kStructLimit = (sizeof(std::uintptr_t) << 1);

    return sizeof(_Type) > kStructLimit;
#elif defined(__arm64__)
    return false;
#elif defined(__arm__)
    constexpr size_t kStructLimit = sizeof(std::uintptr_t);

    return std::is_class_v<_Type> && (sizeof(_Type) > kStructLimit);
#else
#error "Unsupported architecture!"
#endif
}

template <>
_NS_INLINE constexpr bool NS::Object::doesRequireMsgSendStret<void>()
{
    return false;
}

template <typename _Ret, typename... _Args>
_NS_INLINE _Ret NS::Object::sendMessage(const void* pObj, SEL selector, _Args... args)
{
#if (defined(__i386__) || defined(__x86_64__))
    if constexpr (std::is_floating_point<_Ret>())
    {
        using SendMessageProcFpret = _Ret (*)(const void*, SEL, _Args...);

        const SendMessageProcFpret pProc = reinterpret_cast<SendMessageProcFpret>(&objc_msgSend_fpret);

        return (*pProc)(pObj, selector, args...);
    }
    else
#endif // ( defined( __i386__ )  || defined( __x86_64__ )  )
#if !defined(__arm64__)
        if constexpr (doesRequireMsgSendStret<_Ret>())
    {
        using SendMessageProcStret = void (*)(_Ret*, const void*, SEL, _Args...);

        const SendMessageProcStret pProc = reinterpret_cast<SendMessageProcStret>(&objc_msgSend_stret);
        _Ret                       ret;

        (*pProc)(&ret, pObj, selector, args...);

        return ret;
    }
    else
#endif // !defined( __arm64__ )
    {
        using SendMessageProc = _Ret (*)(const void*, SEL, _Args...);

        const SendMessageProc pProc = reinterpret_cast<SendMessageProc>(&objc_msgSend);

        return (*pProc)(pObj, selector, args...);
    }
}

_NS_INLINE NS::MethodSignature* NS::Object::methodSignatureForSelector(const void* pObj, SEL selector)
{
    return sendMessage<MethodSignature*>(pObj, _NS_PRIVATE_SEL(methodSignatureForSelector_), selector);
}

_NS_INLINE bool NS::Object::respondsToSelector(const void* pObj, SEL selector)
{
    return sendMessage<bool>(pObj, _NS_PRIVATE_SEL(respondsToSelector_), selector);
}

template <typename _Ret, typename... _Args>
_NS_INLINE _Ret NS::Object::sendMessageSafe(const void* pObj, SEL selector, _Args... args)
{
    if ((respondsToSelector(pObj, selector)) || (nullptr != methodSignatureForSelector(pObj, selector)))
    {
        return sendMessage<_Ret>(pObj, selector, args...);
    }

    if constexpr (!std::is_void<_Ret>::value)
    {
        return _Ret(0);
    }
}

template <class _Class>
_NS_INLINE _Class* NS::Object::alloc(const char* pClassName)
{
    return sendMessage<_Class*>(objc_lookUpClass(pClassName), _NS_PRIVATE_SEL(alloc));
}

template <class _Class>
_NS_INLINE _Class* NS::Object::alloc(const void* pClass)
{
    return sendMessage<_Class*>(pClass, _NS_PRIVATE_SEL(alloc));
}

template <class _Class>
_NS_INLINE _Class* NS::Object::init()
{
    return sendMessage<_Class*>(this, _NS_PRIVATE_SEL(init));
}

_NS_INLINE NS::UInteger NS::Object::hash() const
{
    return sendMessage<UInteger>(this, _NS_PRIVATE_SEL(hash));
}

_NS_INLINE bool NS::Object::isEqual(const Object* pObject) const
{
    return sendMessage<bool>(this, _NS_PRIVATE_SEL(isEqual_), pObject);
}

_NS_INLINE NS::String* NS::Object::description() const
{
    return sendMessage<String*>(this, _NS_PRIVATE_SEL(description));
}

_NS_INLINE NS::String* NS::Object::debugDescription() const
{
    return sendMessageSafe<String*>(this, _NS_PRIVATE_SEL(debugDescription));
}

namespace NS
{
struct FastEnumerationState
{
    unsigned long  state;
    Object**       itemsPtr;
    unsigned long* mutationsPtr;
    unsigned long  extra[5];
} _NS_PACKED;

class FastEnumeration : public Referencing<FastEnumeration>
{
public:
    NS::UInteger countByEnumerating(FastEnumerationState* pState, Object** pBuffer, NS::UInteger len);
};

template <class _ObjectType>
class Enumerator : public Referencing<Enumerator<_ObjectType>, FastEnumeration>
{
public:
    _ObjectType* nextObject();
    class Array* allObjects();
};
}

_NS_INLINE NS::UInteger NS::FastEnumeration::countByEnumerating(FastEnumerationState* pState, Object** pBuffer, NS::UInteger len)
{
    return Object::sendMessage<UInteger>(this, _NS_PRIVATE_SEL(countByEnumeratingWithState_objects_count_), pState, pBuffer, len);
}

template <class _ObjectType>
_NS_INLINE _ObjectType* NS::Enumerator<_ObjectType>::nextObject()
{
    return Object::sendMessage<_ObjectType*>(this, _NS_PRIVATE_SEL(nextObject));
}

template <class _ObjectType>
_NS_INLINE NS::Array* NS::Enumerator<_ObjectType>::allObjects()
{
    return Object::sendMessage<Array*>(this, _NS_PRIVATE_SEL(allObjects));
}

namespace NS
{
class Array : public Copying<Array>
{
public:
    static Array* array();
    static Array* array(const Object* pObject);
    static Array* array(const Object* const* pObjects, UInteger count);

    static Array* alloc();

    Array*        init();
    Array*        init(const Object* const* pObjects, UInteger count);
    Array*        init(const class Coder* pCoder);

    template <class _Object = Object>
    _Object*            object(UInteger index) const;
    UInteger            count() const;
    Enumerator<Object>* objectEnumerator() const;
};
}

_NS_INLINE NS::Array* NS::Array::array()
{
    return Object::sendMessage<Array*>(_NS_PRIVATE_CLS(NSArray), _NS_PRIVATE_SEL(array));
}

_NS_INLINE NS::Array* NS::Array::array(const Object* pObject)
{
    return Object::sendMessage<Array*>(_NS_PRIVATE_CLS(NSArray), _NS_PRIVATE_SEL(arrayWithObject_), pObject);
}

_NS_INLINE NS::Array* NS::Array::array(const Object* const* pObjects, UInteger count)
{
    return Object::sendMessage<Array*>(_NS_PRIVATE_CLS(NSArray), _NS_PRIVATE_SEL(arrayWithObjects_count_), pObjects, count);
}

_NS_INLINE NS::Array* NS::Array::alloc()
{
    return NS::Object::alloc<Array>(_NS_PRIVATE_CLS(NSArray));
}

_NS_INLINE NS::Array* NS::Array::init()
{
    return NS::Object::init<Array>();
}

_NS_INLINE NS::Array* NS::Array::init(const Object* const* pObjects, UInteger count)
{
    return Object::sendMessage<Array*>(this, _NS_PRIVATE_SEL(initWithObjects_count_), pObjects, count);
}

_NS_INLINE NS::Array* NS::Array::init(const class Coder* pCoder)
{
    return Object::sendMessage<Array*>(this, _NS_PRIVATE_SEL(initWithCoder_), pCoder);
}

_NS_INLINE NS::UInteger NS::Array::count() const
{
    return Object::sendMessage<UInteger>(this, _NS_PRIVATE_SEL(count));
}

template <class _Object>
_NS_INLINE _Object* NS::Array::object(UInteger index) const
{
    return Object::sendMessage<_Object*>(this, _NS_PRIVATE_SEL(objectAtIndex_), index);
}

_NS_INLINE NS::Enumerator<NS::Object>* NS::Array::objectEnumerator() const
{
    return NS::Object::sendMessage<Enumerator<NS::Object>*>(this, _NS_PRIVATE_SEL(objectEnumerator));
}

namespace NS
{
class AutoreleasePool : public Object
{
public:
    static AutoreleasePool* alloc();
    AutoreleasePool*        init();

    void                    drain();

    void                    addObject(Object* pObject);

    static void             showPools();
};
}

_NS_INLINE NS::AutoreleasePool* NS::AutoreleasePool::alloc()
{
    return NS::Object::alloc<AutoreleasePool>(_NS_PRIVATE_CLS(NSAutoreleasePool));
}

_NS_INLINE NS::AutoreleasePool* NS::AutoreleasePool::init()
{
    return NS::Object::init<AutoreleasePool>();
}

_NS_INLINE void NS::AutoreleasePool::drain()
{
    Object::sendMessage<void>(this, _NS_PRIVATE_SEL(drain));
}

_NS_INLINE void NS::AutoreleasePool::addObject(Object* pObject)
{
    Object::sendMessage<void>(this, _NS_PRIVATE_SEL(addObject_), pObject);
}

_NS_INLINE void NS::AutoreleasePool::showPools()
{
    Object::sendMessage<void>(_NS_PRIVATE_CLS(NSAutoreleasePool), _NS_PRIVATE_SEL(showPools));
}

namespace NS
{
class Dictionary : public NS::Copying<Dictionary>
{
public:
    static Dictionary* dictionary();
    static Dictionary* dictionary(const Object* pObject, const Object* pKey);
    static Dictionary* dictionary(const Object* const* pObjects, const Object* const* pKeys, UInteger count);

    static Dictionary* alloc();

    Dictionary*        init();
    Dictionary*        init(const Object* const* pObjects, const Object* const* pKeys, UInteger count);
    Dictionary*        init(const class Coder* pCoder);

    template <class _KeyType = Object>
    Enumerator<_KeyType>* keyEnumerator() const;

    template <class _Object = Object>
    _Object* object(const Object* pKey) const;
    UInteger count() const;
};
}

_NS_INLINE NS::Dictionary* NS::Dictionary::dictionary()
{
    return Object::sendMessage<Dictionary*>(_NS_PRIVATE_CLS(NSDictionary), _NS_PRIVATE_SEL(dictionary));
}

_NS_INLINE NS::Dictionary* NS::Dictionary::dictionary(const Object* pObject, const Object* pKey)
{
    return Object::sendMessage<Dictionary*>(_NS_PRIVATE_CLS(NSDictionary), _NS_PRIVATE_SEL(dictionaryWithObject_forKey_), pObject, pKey);
}

_NS_INLINE NS::Dictionary* NS::Dictionary::dictionary(const Object* const* pObjects, const Object* const* pKeys, UInteger count)
{
    return Object::sendMessage<Dictionary*>(_NS_PRIVATE_CLS(NSDictionary), _NS_PRIVATE_SEL(dictionaryWithObjects_forKeys_count_),
        pObjects, pKeys, count);
}

_NS_INLINE NS::Dictionary* NS::Dictionary::alloc()
{
    return NS::Object::alloc<Dictionary>(_NS_PRIVATE_CLS(NSDictionary));
}

_NS_INLINE NS::Dictionary* NS::Dictionary::init()
{
    return NS::Object::init<Dictionary>();
}

_NS_INLINE NS::Dictionary* NS::Dictionary::init(const Object* const* pObjects, const Object* const* pKeys, UInteger count)
{
    return Object::sendMessage<Dictionary*>(this, _NS_PRIVATE_SEL(initWithObjects_forKeys_count_), pObjects, pKeys, count);
}

_NS_INLINE NS::Dictionary* NS::Dictionary::init(const class Coder* pCoder)
{
    return Object::sendMessage<Dictionary*>(this, _NS_PRIVATE_SEL(initWithCoder_), pCoder);
}

template <class _KeyType>
_NS_INLINE NS::Enumerator<_KeyType>* NS::Dictionary::keyEnumerator() const
{
    return Object::sendMessage<Enumerator<_KeyType>*>(this, _NS_PRIVATE_SEL(keyEnumerator));
}

template <class _Object>
_NS_INLINE _Object* NS::Dictionary::object(const Object* pKey) const
{
    return Object::sendMessage<_Object*>(this, _NS_PRIVATE_SEL(objectForKey_), pKey);
}

_NS_INLINE NS::UInteger NS::Dictionary::count() const
{
    return Object::sendMessage<UInteger>(this, _NS_PRIVATE_SEL(count));
}

namespace NS
{

_NS_ENUM(Integer, ComparisonResult) {
    OrderedAscending = -1L,
    OrderedSame,
    OrderedDescending
};

const Integer NotFound = IntegerMax;

}

namespace NS
{
struct Range
{
    static Range Make(UInteger loc, UInteger len);

    Range(UInteger loc, UInteger len);

    bool     Equal(const Range& range) const;
    bool     LocationInRange(UInteger loc) const;
    UInteger Max() const;

    UInteger location;
    UInteger length;
} _NS_PACKED;
}

_NS_INLINE NS::Range::Range(UInteger loc, UInteger len)
    : location(loc)
    , length(len)
{
}

_NS_INLINE NS::Range NS::Range::Make(UInteger loc, UInteger len)
{
    return Range(loc, len);
}

_NS_INLINE bool NS::Range::Equal(const Range& range) const
{
    return (location == range.location) && (length == range.length);
}

_NS_INLINE bool NS::Range::LocationInRange(UInteger loc) const
{
    return (!(loc < location)) && ((loc - location) < length);
}

_NS_INLINE NS::UInteger NS::Range::Max() const
{
    return location + length;
}

namespace NS
{
_NS_ENUM(NS::UInteger, StringEncoding) {
    ASCIIStringEncoding = 1,
    NEXTSTEPStringEncoding = 2,
    JapaneseEUCStringEncoding = 3,
    UTF8StringEncoding = 4,
    ISOLatin1StringEncoding = 5,
    SymbolStringEncoding = 6,
    NonLossyASCIIStringEncoding = 7,
    ShiftJISStringEncoding = 8,
    ISOLatin2StringEncoding = 9,
    UnicodeStringEncoding = 10,
    WindowsCP1251StringEncoding = 11,
    WindowsCP1252StringEncoding = 12,
    WindowsCP1253StringEncoding = 13,
    WindowsCP1254StringEncoding = 14,
    WindowsCP1250StringEncoding = 15,
    ISO2022JPStringEncoding = 21,
    MacOSRomanStringEncoding = 30,

    UTF16StringEncoding = UnicodeStringEncoding,

    UTF16BigEndianStringEncoding = 0x90000100,
    UTF16LittleEndianStringEncoding = 0x94000100,

    UTF32StringEncoding = 0x8c000100,
    UTF32BigEndianStringEncoding = 0x98000100,
    UTF32LittleEndianStringEncoding = 0x9c000100
};

_NS_OPTIONS(NS::UInteger, StringCompareOptions) {
    CaseInsensitiveSearch = 1,
    LiteralSearch = 2,
    BackwardsSearch = 4,
    AnchoredSearch = 8,
    NumericSearch = 64,
    DiacriticInsensitiveSearch = 128,
    WidthInsensitiveSearch = 256,
    ForcedOrderingSearch = 512,
    RegularExpressionSearch = 1024
};

using unichar = unsigned short;

class String : public Copying<String>
{
public:
    static String*   string();
    static String*   string(const String* pString);
    static String*   string(const char* pString, StringEncoding encoding);

    static String*   alloc();
    String*          init();
    String*          init(const String* pString);
    String*          init(const char* pString, StringEncoding encoding);
    String*          init(void* pBytes, UInteger len, StringEncoding encoding, bool freeBuffer);

    unichar          character(UInteger index) const;
    UInteger         length() const;

    const char*      cString(StringEncoding encoding) const;
    const char*      utf8String() const;
    UInteger         maximumLengthOfBytes(StringEncoding encoding) const;
    UInteger         lengthOfBytes(StringEncoding encoding) const;

    bool             isEqualToString(const String* pString) const;
    Range            rangeOfString(const String* pString, StringCompareOptions options) const;

    const char*      fileSystemRepresentation() const;

    String*          stringByAppendingString(const String* pString) const;
    ComparisonResult caseInsensitiveCompare(const String* pString) const;
};

#define MTLSTR(literal) (NS::String*)__builtin___CFStringMakeConstantString("" literal "")

template <std::size_t _StringLen>
[[deprecated("please use MTLSTR(str)")]] constexpr const String* MakeConstantString(const char (&str)[_StringLen])
{
    return reinterpret_cast<const String*>(__CFStringMakeConstantString(str));
}

}

_NS_INLINE NS::String* NS::String::string()
{
    return Object::sendMessage<String*>(_NS_PRIVATE_CLS(NSString), _NS_PRIVATE_SEL(string));
}

_NS_INLINE NS::String* NS::String::string(const String* pString)
{
    return Object::sendMessage<String*>(_NS_PRIVATE_CLS(NSString), _NS_PRIVATE_SEL(stringWithString_), pString);
}

_NS_INLINE NS::String* NS::String::string(const char* pString, StringEncoding encoding)
{
    return Object::sendMessage<String*>(_NS_PRIVATE_CLS(NSString), _NS_PRIVATE_SEL(stringWithCString_encoding_), pString, encoding);
}

_NS_INLINE NS::String* NS::String::alloc()
{
    return Object::alloc<String>(_NS_PRIVATE_CLS(NSString));
}

_NS_INLINE NS::String* NS::String::init()
{
    return Object::init<String>();
}

_NS_INLINE NS::String* NS::String::init(const String* pString)
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(initWithString_), pString);
}

_NS_INLINE NS::String* NS::String::init(const char* pString, StringEncoding encoding)
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(initWithCString_encoding_), pString, encoding);
}

_NS_INLINE NS::String* NS::String::init(void* pBytes, UInteger len, StringEncoding encoding, bool freeBuffer)
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(initWithBytesNoCopy_length_encoding_freeWhenDone_), pBytes, len, encoding, freeBuffer);
}

_NS_INLINE NS::unichar NS::String::character(UInteger index) const
{
    return Object::sendMessage<unichar>(this, _NS_PRIVATE_SEL(characterAtIndex_), index);
}

_NS_INLINE NS::UInteger NS::String::length() const
{
    return Object::sendMessage<UInteger>(this, _NS_PRIVATE_SEL(length));
}

_NS_INLINE const char* NS::String::cString(StringEncoding encoding) const
{
    return Object::sendMessage<const char*>(this, _NS_PRIVATE_SEL(cStringUsingEncoding_), encoding);
}

_NS_INLINE const char* NS::String::utf8String() const
{
    return Object::sendMessage<const char*>(this, _NS_PRIVATE_SEL(UTF8String));
}

_NS_INLINE NS::UInteger NS::String::maximumLengthOfBytes(StringEncoding encoding) const
{
    return Object::sendMessage<UInteger>(this, _NS_PRIVATE_SEL(maximumLengthOfBytesUsingEncoding_), encoding);
}

_NS_INLINE NS::UInteger NS::String::lengthOfBytes(StringEncoding encoding) const
{
    return Object::sendMessage<UInteger>(this, _NS_PRIVATE_SEL(lengthOfBytesUsingEncoding_), encoding);
}

_NS_INLINE bool NS::String::isEqualToString(const NS::String* pString) const
{
    return Object::sendMessage<bool>(this, _NS_PRIVATE_SEL(isEqualToString_), pString);
}

_NS_INLINE NS::Range NS::String::rangeOfString(const NS::String* pString, NS::StringCompareOptions options) const
{
    return Object::sendMessage<Range>(this, _NS_PRIVATE_SEL(rangeOfString_options_), pString, options);
}

_NS_INLINE const char* NS::String::fileSystemRepresentation() const
{
    return Object::sendMessage<const char*>(this, _NS_PRIVATE_SEL(fileSystemRepresentation));
}

_NS_INLINE NS::String* NS::String::stringByAppendingString(const String* pString) const
{
    return Object::sendMessage<NS::String*>(this, _NS_PRIVATE_SEL(stringByAppendingString_), pString);
}

_NS_INLINE NS::ComparisonResult NS::String::caseInsensitiveCompare(const String* pString) const
{
    return Object::sendMessage<NS::ComparisonResult>(this, _NS_PRIVATE_SEL(caseInsensitiveCompare_), pString);
}

#include <functional>

namespace NS
{
using NotificationName = class String*;

class Notification : public NS::Referencing<Notification>
{
public:
    NS::String*     name() const;
    NS::Object*     object() const;
    NS::Dictionary* userInfo() const;
};

using ObserverBlock = void(^)(Notification*);
using ObserverFunction = std::function<void(Notification*)>;

class NotificationCenter : public NS::Referencing<NotificationCenter>
{
    public:
        static class NotificationCenter* defaultCenter();
        Object* addObserver(NotificationName name, Object* pObj, void* pQueue, ObserverBlock block);
        Object* addObserver(NotificationName name, Object* pObj, void* pQueue, ObserverFunction &handler);
        void removeObserver(Object* pObserver);

};
}

_NS_INLINE NS::String* NS::Notification::name() const
{
    return Object::sendMessage<NS::String*>(this, _NS_PRIVATE_SEL(name));
}

_NS_INLINE NS::Object* NS::Notification::object() const
{
    return Object::sendMessage<NS::Object*>(this, _NS_PRIVATE_SEL(object));
}

_NS_INLINE NS::Dictionary* NS::Notification::userInfo() const
{
    return Object::sendMessage<NS::Dictionary*>(this, _NS_PRIVATE_SEL(userInfo));
}

_NS_INLINE NS::NotificationCenter* NS::NotificationCenter::defaultCenter()
{
    return NS::Object::sendMessage<NS::NotificationCenter*>(_NS_PRIVATE_CLS(NSNotificationCenter), _NS_PRIVATE_SEL(defaultCenter));
}

_NS_INLINE NS::Object* NS::NotificationCenter::addObserver(NS::NotificationName name, Object* pObj, void* pQueue, NS::ObserverBlock block)
{
    return NS::Object::sendMessage<Object*>(this, _NS_PRIVATE_SEL(addObserverName_object_queue_block_), name, pObj, pQueue, block);
}

_NS_INLINE NS::Object* NS::NotificationCenter::addObserver(NS::NotificationName name, Object* pObj, void* pQueue, NS::ObserverFunction &handler)
{
    __block ObserverFunction blockFunction = handler;

    return addObserver(name, pObj, pQueue, ^(NS::Notification* pNotif) {blockFunction(pNotif);});
}

_NS_INLINE void NS::NotificationCenter::removeObserver(Object* pObserver)
{
    return NS::Object::sendMessage<void>(this, _NS_PRIVATE_SEL(removeObserver_), pObserver);
}

namespace NS
{
_NS_CONST(NotificationName, BundleDidLoadNotification);
_NS_CONST(NotificationName, BundleResourceRequestLowDiskSpaceNotification);

class String* LocalizedString(const String* pKey, const String*);
class String* LocalizedStringFromTable(const String* pKey, const String* pTbl, const String*);
class String* LocalizedStringFromTableInBundle(const String* pKey, const String* pTbl, const class Bundle* pBdle, const String*);
class String* LocalizedStringWithDefaultValue(const String* pKey, const String* pTbl, const class Bundle* pBdle, const String* pVal, const String*);

class Bundle : public Referencing<Bundle>
{
public:
    static Bundle*      mainBundle();

    static Bundle*      bundle(const class String* pPath);
    static Bundle*      bundle(const class URL* pURL);

    static class Array* allBundles();
    static class Array* allFrameworks();

    static Bundle*      alloc();

    Bundle*             init(const class String* pPath);
    Bundle*             init(const class URL* pURL);

    bool                load();
    bool                unload();

    bool                isLoaded() const;

    bool                preflightAndReturnError(class Error** pError) const;
    bool                loadAndReturnError(class Error** pError);

    class URL*          bundleURL() const;
    class URL*          resourceURL() const;
    class URL*          executableURL() const;
    class URL*          URLForAuxiliaryExecutable(const class String* pExecutableName) const;

    class URL*          privateFrameworksURL() const;
    class URL*          sharedFrameworksURL() const;
    class URL*          sharedSupportURL() const;
    class URL*          builtInPlugInsURL() const;
    class URL*          appStoreReceiptURL() const;

    class String*       bundlePath() const;
    class String*       resourcePath() const;
    class String*       executablePath() const;
    class String*       pathForAuxiliaryExecutable(const class String* pExecutableName) const;

    class String*       privateFrameworksPath() const;
    class String*       sharedFrameworksPath() const;
    class String*       sharedSupportPath() const;
    class String*       builtInPlugInsPath() const;

    class String*       bundleIdentifier() const;
    class Dictionary*   infoDictionary() const;
    class Dictionary*   localizedInfoDictionary() const;
    class Object*       objectForInfoDictionaryKey(const class String* pKey);

    class String*       localizedString(const class String* pKey, const class String* pValue = nullptr, const class String* pTableName = nullptr) const;
};
}

_NS_PRIVATE_DEF_CONST(NS::NotificationName, BundleDidLoadNotification);
_NS_PRIVATE_DEF_CONST(NS::NotificationName, BundleResourceRequestLowDiskSpaceNotification);

_NS_INLINE NS::String* NS::LocalizedString(const String* pKey, const String*)
{
    return Bundle::mainBundle()->localizedString(pKey, nullptr, nullptr);
}

_NS_INLINE NS::String* NS::LocalizedStringFromTable(const String* pKey, const String* pTbl, const String*)
{
    return Bundle::mainBundle()->localizedString(pKey, nullptr, pTbl);
}

_NS_INLINE NS::String* NS::LocalizedStringFromTableInBundle(const String* pKey, const String* pTbl, const Bundle* pBdl, const String*)
{
    return pBdl->localizedString(pKey, nullptr, pTbl);
}

_NS_INLINE NS::String* NS::LocalizedStringWithDefaultValue(const String* pKey, const String* pTbl, const Bundle* pBdl, const String* pVal, const String*)
{
    return pBdl->localizedString(pKey, pVal, pTbl);
}

_NS_INLINE NS::Bundle* NS::Bundle::mainBundle()
{
    return Object::sendMessage<Bundle*>(_NS_PRIVATE_CLS(NSBundle), _NS_PRIVATE_SEL(mainBundle));
}

_NS_INLINE NS::Bundle* NS::Bundle::bundle(const class String* pPath)
{
    return Object::sendMessage<Bundle*>(_NS_PRIVATE_CLS(NSBundle), _NS_PRIVATE_SEL(bundleWithPath_), pPath);
}

_NS_INLINE NS::Bundle* NS::Bundle::bundle(const class URL* pURL)
{
    return Object::sendMessage<Bundle*>(_NS_PRIVATE_CLS(NSBundle), _NS_PRIVATE_SEL(bundleWithURL_), pURL);
}

_NS_INLINE NS::Array* NS::Bundle::allBundles()
{
    return Object::sendMessage<Array*>(_NS_PRIVATE_CLS(NSBundle), _NS_PRIVATE_SEL(allBundles));
}

_NS_INLINE NS::Array* NS::Bundle::allFrameworks()
{
    return Object::sendMessage<Array*>(_NS_PRIVATE_CLS(NSBundle), _NS_PRIVATE_SEL(allFrameworks));
}

_NS_INLINE NS::Bundle* NS::Bundle::alloc()
{
    return Object::sendMessage<Bundle*>(_NS_PRIVATE_CLS(NSBundle), _NS_PRIVATE_SEL(alloc));
}

_NS_INLINE NS::Bundle* NS::Bundle::init(const String* pPath)
{
    return Object::sendMessage<Bundle*>(this, _NS_PRIVATE_SEL(initWithPath_), pPath);
}

_NS_INLINE NS::Bundle* NS::Bundle::init(const URL* pURL)
{
    return Object::sendMessage<Bundle*>(this, _NS_PRIVATE_SEL(initWithURL_), pURL);
}

_NS_INLINE bool NS::Bundle::load()
{
    return Object::sendMessage<bool>(this, _NS_PRIVATE_SEL(load));
}

_NS_INLINE bool NS::Bundle::unload()
{
    return Object::sendMessage<bool>(this, _NS_PRIVATE_SEL(unload));
}

_NS_INLINE bool NS::Bundle::isLoaded() const
{
    return Object::sendMessage<bool>(this, _NS_PRIVATE_SEL(isLoaded));
}

_NS_INLINE bool NS::Bundle::preflightAndReturnError(Error** pError) const
{
    return Object::sendMessage<bool>(this, _NS_PRIVATE_SEL(preflightAndReturnError_), pError);
}

_NS_INLINE bool NS::Bundle::loadAndReturnError(Error** pError)
{
    return Object::sendMessage<bool>(this, _NS_PRIVATE_SEL(loadAndReturnError_), pError);
}

_NS_INLINE NS::URL* NS::Bundle::bundleURL() const
{
    return Object::sendMessage<URL*>(this, _NS_PRIVATE_SEL(bundleURL));
}

_NS_INLINE NS::URL* NS::Bundle::resourceURL() const
{
    return Object::sendMessage<URL*>(this, _NS_PRIVATE_SEL(resourceURL));
}

_NS_INLINE NS::URL* NS::Bundle::executableURL() const
{
    return Object::sendMessage<URL*>(this, _NS_PRIVATE_SEL(executableURL));
}

_NS_INLINE NS::URL* NS::Bundle::URLForAuxiliaryExecutable(const String* pExecutableName) const
{
    return Object::sendMessage<URL*>(this, _NS_PRIVATE_SEL(URLForAuxiliaryExecutable_), pExecutableName);
}

_NS_INLINE NS::URL* NS::Bundle::privateFrameworksURL() const
{
    return Object::sendMessage<URL*>(this, _NS_PRIVATE_SEL(privateFrameworksURL));
}

_NS_INLINE NS::URL* NS::Bundle::sharedFrameworksURL() const
{
    return Object::sendMessage<URL*>(this, _NS_PRIVATE_SEL(sharedFrameworksURL));
}

_NS_INLINE NS::URL* NS::Bundle::sharedSupportURL() const
{
    return Object::sendMessage<URL*>(this, _NS_PRIVATE_SEL(sharedSupportURL));
}

_NS_INLINE NS::URL* NS::Bundle::builtInPlugInsURL() const
{
    return Object::sendMessage<URL*>(this, _NS_PRIVATE_SEL(builtInPlugInsURL));
}

_NS_INLINE NS::URL* NS::Bundle::appStoreReceiptURL() const
{
    return Object::sendMessage<URL*>(this, _NS_PRIVATE_SEL(appStoreReceiptURL));
}

_NS_INLINE NS::String* NS::Bundle::bundlePath() const
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(bundlePath));
}

_NS_INLINE NS::String* NS::Bundle::resourcePath() const
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(resourcePath));
}

_NS_INLINE NS::String* NS::Bundle::executablePath() const
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(executablePath));
}

_NS_INLINE NS::String* NS::Bundle::pathForAuxiliaryExecutable(const String* pExecutableName) const
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(pathForAuxiliaryExecutable_), pExecutableName);
}

_NS_INLINE NS::String* NS::Bundle::privateFrameworksPath() const
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(privateFrameworksPath));
}

_NS_INLINE NS::String* NS::Bundle::sharedFrameworksPath() const
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(sharedFrameworksPath));
}

_NS_INLINE NS::String* NS::Bundle::sharedSupportPath() const
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(sharedSupportPath));
}

_NS_INLINE NS::String* NS::Bundle::builtInPlugInsPath() const
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(builtInPlugInsPath));
}

_NS_INLINE NS::String* NS::Bundle::bundleIdentifier() const
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(bundleIdentifier));
}

_NS_INLINE NS::Dictionary* NS::Bundle::infoDictionary() const
{
    return Object::sendMessage<Dictionary*>(this, _NS_PRIVATE_SEL(infoDictionary));
}

_NS_INLINE NS::Dictionary* NS::Bundle::localizedInfoDictionary() const
{
    return Object::sendMessage<Dictionary*>(this, _NS_PRIVATE_SEL(localizedInfoDictionary));
}

_NS_INLINE NS::Object* NS::Bundle::objectForInfoDictionaryKey(const String* pKey)
{
    return Object::sendMessage<Object*>(this, _NS_PRIVATE_SEL(objectForInfoDictionaryKey_), pKey);
}

_NS_INLINE NS::String* NS::Bundle::localizedString(const String* pKey, const String* pValue /* = nullptr */, const String* pTableName /* = nullptr */) const
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(localizedStringForKey_value_table_), pKey, pValue, pTableName);
}

namespace NS
{
class Data : public Copying<Data>
{
public:
    void*    mutableBytes() const;
    UInteger length() const;
};
}

_NS_INLINE void* NS::Data::mutableBytes() const
{
    return Object::sendMessage<void*>(this, _NS_PRIVATE_SEL(mutableBytes));
}

_NS_INLINE NS::UInteger NS::Data::length() const
{
    return Object::sendMessage<UInteger>(this, _NS_PRIVATE_SEL(length));
}

namespace NS
{

using TimeInterval = double;

class Date : public Copying<Date>
{
public:
    static Date* dateWithTimeIntervalSinceNow(TimeInterval secs);
};

} // NS

_NS_INLINE NS::Date* NS::Date::dateWithTimeIntervalSinceNow(NS::TimeInterval secs)
{
    return NS::Object::sendMessage<NS::Date*>(_NS_PRIVATE_CLS(NSDate), _NS_PRIVATE_SEL(dateWithTimeIntervalSinceNow_), secs);
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------

namespace NS
{
using ErrorDomain = class String*;

_NS_CONST(ErrorDomain, CocoaErrorDomain);
_NS_CONST(ErrorDomain, POSIXErrorDomain);
_NS_CONST(ErrorDomain, OSStatusErrorDomain);
_NS_CONST(ErrorDomain, MachErrorDomain);

using ErrorUserInfoKey = class String*;

_NS_CONST(ErrorUserInfoKey, UnderlyingErrorKey);
_NS_CONST(ErrorUserInfoKey, LocalizedDescriptionKey);
_NS_CONST(ErrorUserInfoKey, LocalizedFailureReasonErrorKey);
_NS_CONST(ErrorUserInfoKey, LocalizedRecoverySuggestionErrorKey);
_NS_CONST(ErrorUserInfoKey, LocalizedRecoveryOptionsErrorKey);
_NS_CONST(ErrorUserInfoKey, RecoveryAttempterErrorKey);
_NS_CONST(ErrorUserInfoKey, HelpAnchorErrorKey);
_NS_CONST(ErrorUserInfoKey, DebugDescriptionErrorKey);
_NS_CONST(ErrorUserInfoKey, LocalizedFailureErrorKey);
_NS_CONST(ErrorUserInfoKey, StringEncodingErrorKey);
_NS_CONST(ErrorUserInfoKey, URLErrorKey);
_NS_CONST(ErrorUserInfoKey, FilePathErrorKey);

class Error : public Copying<Error>
{
public:
    static Error*     error(ErrorDomain domain, Integer code, class Dictionary* pDictionary);

    static Error*     alloc();
    Error*            init();
    Error*            init(ErrorDomain domain, Integer code, class Dictionary* pDictionary);

    Integer           code() const;
    ErrorDomain       domain() const;
    class Dictionary* userInfo() const;

    class String*     localizedDescription() const;
    class Array*      localizedRecoveryOptions() const;
    class String*     localizedRecoverySuggestion() const;
    class String*     localizedFailureReason() const;
};
}

_NS_PRIVATE_DEF_CONST(NS::ErrorDomain, CocoaErrorDomain);
_NS_PRIVATE_DEF_CONST(NS::ErrorDomain, POSIXErrorDomain);
_NS_PRIVATE_DEF_CONST(NS::ErrorDomain, OSStatusErrorDomain);
_NS_PRIVATE_DEF_CONST(NS::ErrorDomain, MachErrorDomain);

_NS_PRIVATE_DEF_CONST(NS::ErrorUserInfoKey, UnderlyingErrorKey);
_NS_PRIVATE_DEF_CONST(NS::ErrorUserInfoKey, LocalizedDescriptionKey);
_NS_PRIVATE_DEF_CONST(NS::ErrorUserInfoKey, LocalizedFailureReasonErrorKey);
_NS_PRIVATE_DEF_CONST(NS::ErrorUserInfoKey, LocalizedRecoverySuggestionErrorKey);
_NS_PRIVATE_DEF_CONST(NS::ErrorUserInfoKey, LocalizedRecoveryOptionsErrorKey);
_NS_PRIVATE_DEF_CONST(NS::ErrorUserInfoKey, RecoveryAttempterErrorKey);
_NS_PRIVATE_DEF_CONST(NS::ErrorUserInfoKey, HelpAnchorErrorKey);
_NS_PRIVATE_DEF_CONST(NS::ErrorUserInfoKey, DebugDescriptionErrorKey);
_NS_PRIVATE_DEF_CONST(NS::ErrorUserInfoKey, LocalizedFailureErrorKey);
_NS_PRIVATE_DEF_CONST(NS::ErrorUserInfoKey, StringEncodingErrorKey);
_NS_PRIVATE_DEF_CONST(NS::ErrorUserInfoKey, URLErrorKey);
_NS_PRIVATE_DEF_CONST(NS::ErrorUserInfoKey, FilePathErrorKey);

_NS_INLINE NS::Error* NS::Error::error(ErrorDomain domain, Integer code, class Dictionary* pDictionary)
{
    return Object::sendMessage<Error*>(_NS_PRIVATE_CLS(NSError), _NS_PRIVATE_SEL(errorWithDomain_code_userInfo_), domain, code, pDictionary);
}

_NS_INLINE NS::Error* NS::Error::alloc()
{
    return Object::alloc<Error>(_NS_PRIVATE_CLS(NSError));
}

_NS_INLINE NS::Error* NS::Error::init()
{
    return Object::init<Error>();
}

_NS_INLINE NS::Error* NS::Error::init(ErrorDomain domain, Integer code, class Dictionary* pDictionary)
{
    return Object::sendMessage<Error*>(this, _NS_PRIVATE_SEL(initWithDomain_code_userInfo_), domain, code, pDictionary);
}

_NS_INLINE NS::Integer NS::Error::code() const
{
    return Object::sendMessage<Integer>(this, _NS_PRIVATE_SEL(code));
}

_NS_INLINE NS::ErrorDomain NS::Error::domain() const
{
    return Object::sendMessage<ErrorDomain>(this, _NS_PRIVATE_SEL(domain));
}

_NS_INLINE NS::Dictionary* NS::Error::userInfo() const
{
    return Object::sendMessage<Dictionary*>(this, _NS_PRIVATE_SEL(userInfo));
}

_NS_INLINE NS::String* NS::Error::localizedDescription() const
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(localizedDescription));
}

_NS_INLINE NS::Array* NS::Error::localizedRecoveryOptions() const
{
    return Object::sendMessage<Array*>(this, _NS_PRIVATE_SEL(localizedRecoveryOptions));
}

_NS_INLINE NS::String* NS::Error::localizedRecoverySuggestion() const
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(localizedRecoverySuggestion));
}

_NS_INLINE NS::String* NS::Error::localizedFailureReason() const
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(localizedFailureReason));
}

namespace NS
{

template <class _Class, class _Base = class Object>
class Locking : public _Base
{
public:
    void lock();
    void unlock();
};

class Condition : public Locking<Condition>
{
public:
    static Condition* alloc();

    Condition*        init();

    void              wait();
    bool              waitUntilDate(Date* pLimit);
    void              signal();
    void              broadcast();
};

} // NS

template<class _Class, class _Base /* = NS::Object */>
_NS_INLINE void NS::Locking<_Class, _Base>::lock()
{
    NS::Object::sendMessage<void>(this, _NS_PRIVATE_SEL(lock));
}

template<class _Class, class _Base /* = NS::Object */>
_NS_INLINE void NS::Locking<_Class, _Base>::unlock()
{
    NS::Object::sendMessage<void>(this, _NS_PRIVATE_SEL(unlock));
}

_NS_INLINE NS::Condition* NS::Condition::alloc()
{
    return NS::Object::alloc<NS::Condition>(_NS_PRIVATE_CLS(NSCondition));
}

_NS_INLINE NS::Condition* NS::Condition::init()
{
    return NS::Object::init<NS::Condition>();
}

_NS_INLINE void NS::Condition::wait()
{
    NS::Object::sendMessage<void>(this, _NS_PRIVATE_SEL(wait));
}

_NS_INLINE bool NS::Condition::waitUntilDate(NS::Date* pLimit)
{
    return NS::Object::sendMessage<bool>(this, _NS_PRIVATE_SEL(waitUntilDate_), pLimit);
}

_NS_INLINE void NS::Condition::signal()
{
    NS::Object::sendMessage<void>(this, _NS_PRIVATE_SEL(signal));
}

_NS_INLINE void NS::Condition::broadcast()
{
    NS::Object::sendMessage<void>(this, _NS_PRIVATE_SEL(broadcast));
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------

namespace NS
{
class Value : public Copying<Value>
{
public:
    static Value* value(const void* pValue, const char* pType);
    static Value* value(const void* pPointer);

    static Value* alloc();

    Value*        init(const void* pValue, const char* pType);
    Value*        init(const class Coder* pCoder);

    void          getValue(void* pValue, UInteger size) const;
    const char*   objCType() const;

    bool          isEqualToValue(Value* pValue) const;
    void*         pointerValue() const;
};

class Number : public Copying<Number, Value>
{
public:
    static Number*     number(char value);
    static Number*     number(unsigned char value);
    static Number*     number(short value);
    static Number*     number(unsigned short value);
    static Number*     number(int value);
    static Number*     number(unsigned int value);
    static Number*     number(long value);
    static Number*     number(unsigned long value);
    static Number*     number(long long value);
    static Number*     number(unsigned long long value);
    static Number*     number(float value);
    static Number*     number(double value);
    static Number*     number(bool value);

    static Number*     alloc();

    Number*            init(const class Coder* pCoder);
    Number*            init(char value);
    Number*            init(unsigned char value);
    Number*            init(short value);
    Number*            init(unsigned short value);
    Number*            init(int value);
    Number*            init(unsigned int value);
    Number*            init(long value);
    Number*            init(unsigned long value);
    Number*            init(long long value);
    Number*            init(unsigned long long value);
    Number*            init(float value);
    Number*            init(double value);
    Number*            init(bool value);

    char               charValue() const;
    unsigned char      unsignedCharValue() const;
    short              shortValue() const;
    unsigned short     unsignedShortValue() const;
    int                intValue() const;
    unsigned int       unsignedIntValue() const;
    long               longValue() const;
    unsigned long      unsignedLongValue() const;
    long long          longLongValue() const;
    unsigned long long unsignedLongLongValue() const;
    float              floatValue() const;
    double             doubleValue() const;
    bool               boolValue() const;
    Integer            integerValue() const;
    UInteger           unsignedIntegerValue() const;
    class String*      stringValue() const;

    ComparisonResult   compare(const Number* pOtherNumber) const;
    bool               isEqualToNumber(const Number* pNumber) const;

    class String*      descriptionWithLocale(const Object* pLocale) const;
};
}

_NS_INLINE NS::Value* NS::Value::value(const void* pValue, const char* pType)
{
    return Object::sendMessage<Value*>(_NS_PRIVATE_CLS(NSValue), _NS_PRIVATE_SEL(valueWithBytes_objCType_), pValue, pType);
}

_NS_INLINE NS::Value* NS::Value::value(const void* pPointer)
{
    return Object::sendMessage<Value*>(_NS_PRIVATE_CLS(NSValue), _NS_PRIVATE_SEL(valueWithPointer_), pPointer);
}

_NS_INLINE NS::Value* NS::Value::alloc()
{
    return NS::Object::alloc<Value>(_NS_PRIVATE_CLS(NSValue));
}

_NS_INLINE NS::Value* NS::Value::init(const void* pValue, const char* pType)
{
    return Object::sendMessage<Value*>(this, _NS_PRIVATE_SEL(initWithBytes_objCType_), pValue, pType);
}

_NS_INLINE NS::Value* NS::Value::init(const class Coder* pCoder)
{
    return Object::sendMessage<Value*>(this, _NS_PRIVATE_SEL(initWithCoder_), pCoder);
}

_NS_INLINE void NS::Value::getValue(void* pValue, UInteger size) const
{
    Object::sendMessage<void>(this, _NS_PRIVATE_SEL(getValue_size_), pValue, size);
}

_NS_INLINE const char* NS::Value::objCType() const
{
    return Object::sendMessage<const char*>(this, _NS_PRIVATE_SEL(objCType));
}

_NS_INLINE bool NS::Value::isEqualToValue(Value* pValue) const
{
    return Object::sendMessage<bool>(this, _NS_PRIVATE_SEL(isEqualToValue_), pValue);
}

_NS_INLINE void* NS::Value::pointerValue() const
{
    return Object::sendMessage<void*>(this, _NS_PRIVATE_SEL(pointerValue));
}

_NS_INLINE NS::Number* NS::Number::number(char value)
{
    return Object::sendMessage<Number*>(_NS_PRIVATE_CLS(NSNumber), _NS_PRIVATE_SEL(numberWithChar_), value);
}

_NS_INLINE NS::Number* NS::Number::number(unsigned char value)
{
    return Object::sendMessage<Number*>(_NS_PRIVATE_CLS(NSNumber), _NS_PRIVATE_SEL(numberWithUnsignedChar_), value);
}

_NS_INLINE NS::Number* NS::Number::number(short value)
{
    return Object::sendMessage<Number*>(_NS_PRIVATE_CLS(NSNumber), _NS_PRIVATE_SEL(numberWithShort_), value);
}

_NS_INLINE NS::Number* NS::Number::number(unsigned short value)
{
    return Object::sendMessage<Number*>(_NS_PRIVATE_CLS(NSNumber), _NS_PRIVATE_SEL(numberWithUnsignedShort_), value);
}

_NS_INLINE NS::Number* NS::Number::number(int value)
{
    return Object::sendMessage<Number*>(_NS_PRIVATE_CLS(NSNumber), _NS_PRIVATE_SEL(numberWithInt_), value);
}

_NS_INLINE NS::Number* NS::Number::number(unsigned int value)
{
    return Object::sendMessage<Number*>(_NS_PRIVATE_CLS(NSNumber), _NS_PRIVATE_SEL(numberWithUnsignedInt_), value);
}

_NS_INLINE NS::Number* NS::Number::number(long value)
{
    return Object::sendMessage<Number*>(_NS_PRIVATE_CLS(NSNumber), _NS_PRIVATE_SEL(numberWithLong_), value);
}

_NS_INLINE NS::Number* NS::Number::number(unsigned long value)
{
    return Object::sendMessage<Number*>(_NS_PRIVATE_CLS(NSNumber), _NS_PRIVATE_SEL(numberWithUnsignedLong_), value);
}

_NS_INLINE NS::Number* NS::Number::number(long long value)
{
    return Object::sendMessage<Number*>(_NS_PRIVATE_CLS(NSNumber), _NS_PRIVATE_SEL(numberWithLongLong_), value);
}

_NS_INLINE NS::Number* NS::Number::number(unsigned long long value)
{
    return Object::sendMessage<Number*>(_NS_PRIVATE_CLS(NSNumber), _NS_PRIVATE_SEL(numberWithUnsignedLongLong_), value);
}

_NS_INLINE NS::Number* NS::Number::number(float value)
{
    return Object::sendMessage<Number*>(_NS_PRIVATE_CLS(NSNumber), _NS_PRIVATE_SEL(numberWithFloat_), value);
}

_NS_INLINE NS::Number* NS::Number::number(double value)
{
    return Object::sendMessage<Number*>(_NS_PRIVATE_CLS(NSNumber), _NS_PRIVATE_SEL(numberWithDouble_), value);
}

_NS_INLINE NS::Number* NS::Number::number(bool value)
{
    return Object::sendMessage<Number*>(_NS_PRIVATE_CLS(NSNumber), _NS_PRIVATE_SEL(numberWithBool_), value);
}

_NS_INLINE NS::Number* NS::Number::alloc()
{
    return NS::Object::alloc<Number>(_NS_PRIVATE_CLS(NSNumber));
}

_NS_INLINE NS::Number* NS::Number::init(const Coder* pCoder)
{
    return Object::sendMessage<Number*>(this, _NS_PRIVATE_SEL(initWithCoder_), pCoder);
}

_NS_INLINE NS::Number* NS::Number::init(char value)
{
    return Object::sendMessage<Number*>(this, _NS_PRIVATE_SEL(initWithChar_), value);
}

_NS_INLINE NS::Number* NS::Number::init(unsigned char value)
{
    return Object::sendMessage<Number*>(this, _NS_PRIVATE_SEL(initWithUnsignedChar_), value);
}

_NS_INLINE NS::Number* NS::Number::init(short value)
{
    return Object::sendMessage<Number*>(this, _NS_PRIVATE_SEL(initWithShort_), value);
}

_NS_INLINE NS::Number* NS::Number::init(unsigned short value)
{
    return Object::sendMessage<Number*>(this, _NS_PRIVATE_SEL(initWithUnsignedShort_), value);
}

_NS_INLINE NS::Number* NS::Number::init(int value)
{
    return Object::sendMessage<Number*>(this, _NS_PRIVATE_SEL(initWithInt_), value);
}

_NS_INLINE NS::Number* NS::Number::init(unsigned int value)
{
    return Object::sendMessage<Number*>(this, _NS_PRIVATE_SEL(initWithUnsignedInt_), value);
}

_NS_INLINE NS::Number* NS::Number::init(long value)
{
    return Object::sendMessage<Number*>(this, _NS_PRIVATE_SEL(initWithLong_), value);
}

_NS_INLINE NS::Number* NS::Number::init(unsigned long value)
{
    return Object::sendMessage<Number*>(this, _NS_PRIVATE_SEL(initWithUnsignedLong_), value);
}

_NS_INLINE NS::Number* NS::Number::init(long long value)
{
    return Object::sendMessage<Number*>(this, _NS_PRIVATE_SEL(initWithLongLong_), value);
}

_NS_INLINE NS::Number* NS::Number::init(unsigned long long value)
{
    return Object::sendMessage<Number*>(this, _NS_PRIVATE_SEL(initWithUnsignedLongLong_), value);
}

_NS_INLINE NS::Number* NS::Number::init(float value)
{
    return Object::sendMessage<Number*>(this, _NS_PRIVATE_SEL(initWithFloat_), value);
}

_NS_INLINE NS::Number* NS::Number::init(double value)
{
    return Object::sendMessage<Number*>(this, _NS_PRIVATE_SEL(initWithDouble_), value);
}

_NS_INLINE NS::Number* NS::Number::init(bool value)
{
    return Object::sendMessage<Number*>(this, _NS_PRIVATE_SEL(initWithBool_), value);
}

_NS_INLINE char NS::Number::charValue() const
{
    return Object::sendMessage<char>(this, _NS_PRIVATE_SEL(charValue));
}

_NS_INLINE unsigned char NS::Number::unsignedCharValue() const
{
    return Object::sendMessage<unsigned char>(this, _NS_PRIVATE_SEL(unsignedCharValue));
}

_NS_INLINE short NS::Number::shortValue() const
{
    return Object::sendMessage<short>(this, _NS_PRIVATE_SEL(shortValue));
}

_NS_INLINE unsigned short NS::Number::unsignedShortValue() const
{
    return Object::sendMessage<unsigned short>(this, _NS_PRIVATE_SEL(unsignedShortValue));
}

_NS_INLINE int NS::Number::intValue() const
{
    return Object::sendMessage<int>(this, _NS_PRIVATE_SEL(intValue));
}

_NS_INLINE unsigned int NS::Number::unsignedIntValue() const
{
    return Object::sendMessage<unsigned int>(this, _NS_PRIVATE_SEL(unsignedIntValue));
}

_NS_INLINE long NS::Number::longValue() const
{
    return Object::sendMessage<long>(this, _NS_PRIVATE_SEL(longValue));
}

_NS_INLINE unsigned long NS::Number::unsignedLongValue() const
{
    return Object::sendMessage<unsigned long>(this, _NS_PRIVATE_SEL(unsignedLongValue));
}

_NS_INLINE long long NS::Number::longLongValue() const
{
    return Object::sendMessage<long long>(this, _NS_PRIVATE_SEL(longLongValue));
}

_NS_INLINE unsigned long long NS::Number::unsignedLongLongValue() const
{
    return Object::sendMessage<unsigned long long>(this, _NS_PRIVATE_SEL(unsignedLongLongValue));
}

_NS_INLINE float NS::Number::floatValue() const
{
    return Object::sendMessage<float>(this, _NS_PRIVATE_SEL(floatValue));
}

_NS_INLINE double NS::Number::doubleValue() const
{
    return Object::sendMessage<double>(this, _NS_PRIVATE_SEL(doubleValue));
}

_NS_INLINE bool NS::Number::boolValue() const
{
    return Object::sendMessage<bool>(this, _NS_PRIVATE_SEL(boolValue));
}

_NS_INLINE NS::Integer NS::Number::integerValue() const
{
    return Object::sendMessage<Integer>(this, _NS_PRIVATE_SEL(integerValue));
}

_NS_INLINE NS::UInteger NS::Number::unsignedIntegerValue() const
{
    return Object::sendMessage<UInteger>(this, _NS_PRIVATE_SEL(unsignedIntegerValue));
}

_NS_INLINE NS::String* NS::Number::stringValue() const
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(stringValue));
}

_NS_INLINE NS::ComparisonResult NS::Number::compare(const Number* pOtherNumber) const
{
    return Object::sendMessage<ComparisonResult>(this, _NS_PRIVATE_SEL(compare_), pOtherNumber);
}

_NS_INLINE bool NS::Number::isEqualToNumber(const Number* pNumber) const
{
    return Object::sendMessage<bool>(this, _NS_PRIVATE_SEL(isEqualToNumber_), pNumber);
}

_NS_INLINE NS::String* NS::Number::descriptionWithLocale(const Object* pLocale) const
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(descriptionWithLocale_), pLocale);
}

#include <functional>

namespace NS
{
_NS_CONST(NotificationName, ProcessInfoThermalStateDidChangeNotification);
_NS_CONST(NotificationName, ProcessInfoPowerStateDidChangeNotification);
_NS_CONST(NotificationName, ProcessInfoPerformanceProfileDidChangeNotification);

_NS_ENUM(NS::Integer, ProcessInfoThermalState) {
    ProcessInfoThermalStateNominal = 0,
    ProcessInfoThermalStateFair = 1,
    ProcessInfoThermalStateSerious = 2,
    ProcessInfoThermalStateCritical = 3
};

_NS_OPTIONS(std::uint64_t, ActivityOptions) {
    ActivityIdleDisplaySleepDisabled = (1ULL << 40),
    ActivityIdleSystemSleepDisabled = (1ULL << 20),
    ActivitySuddenTerminationDisabled = (1ULL << 14),
    ActivityAutomaticTerminationDisabled = (1ULL << 15),
    ActivityUserInitiated = (0x00FFFFFFULL | ActivityIdleSystemSleepDisabled),
    ActivityUserInitiatedAllowingIdleSystemSleep = (ActivityUserInitiated & ~ActivityIdleSystemSleepDisabled),
    ActivityBackground = 0x000000FFULL,
    ActivityLatencyCritical = 0xFF00000000ULL,
};

typedef NS::Integer DeviceCertification;
_NS_CONST(DeviceCertification, DeviceCertificationiPhonePerformanceGaming);

typedef NS::Integer ProcessPerformanceProfile;
_NS_CONST(ProcessPerformanceProfile, ProcessPerformanceProfileDefault);
_NS_CONST(ProcessPerformanceProfile, ProcessPerformanceProfileSustained);

class ProcessInfo : public Referencing<ProcessInfo>
{
public:
    static ProcessInfo*     processInfo();

    class Array*            arguments() const;
    class Dictionary*       environment() const;
    class String*           hostName() const;
    class String*           processName() const;
    void                    setProcessName(const String* pString);
    int                     processIdentifier() const;
    class String*           globallyUniqueString() const;

    class String*           userName() const;
    class String*           fullUserName() const;

    UInteger                operatingSystem() const;
    OperatingSystemVersion  operatingSystemVersion() const;
    class String*           operatingSystemVersionString() const;
    bool                    isOperatingSystemAtLeastVersion(OperatingSystemVersion version) const;

    UInteger                processorCount() const;
    UInteger                activeProcessorCount() const;
    unsigned long long      physicalMemory() const;
    TimeInterval            systemUptime() const;

    void                    disableSuddenTermination();
    void                    enableSuddenTermination();

    void                    disableAutomaticTermination(const class String* pReason);
    void                    enableAutomaticTermination(const class String* pReason);
    bool                    automaticTerminationSupportEnabled() const;
    void                    setAutomaticTerminationSupportEnabled(bool enabled);

    class Object*           beginActivity(ActivityOptions options, const class String* pReason);
    void                    endActivity(class Object* pActivity);
    void                    performActivity(ActivityOptions options, const class String* pReason, void (^block)(void));
    void                    performActivity(ActivityOptions options, const class String* pReason, const std::function<void()>& func);
    void                    performExpiringActivity(const class String* pReason, void (^block)(bool expired));
    void                    performExpiringActivity(const class String* pReason, const std::function<void(bool expired)>& func);

    ProcessInfoThermalState thermalState() const;
    bool                    isLowPowerModeEnabled() const;

    bool                    isiOSAppOnMac() const;
    bool                    isMacCatalystApp() const;

    bool                    isDeviceCertified(DeviceCertification performanceTier) const;
    bool                    hasPerformanceProfile(ProcessPerformanceProfile performanceProfile) const;

};
}

_NS_PRIVATE_DEF_CONST(NS::NotificationName, ProcessInfoThermalStateDidChangeNotification);
_NS_PRIVATE_DEF_CONST(NS::NotificationName, ProcessInfoPowerStateDidChangeNotification);

_NS_PRIVATE_DEF_CONST(NS::NotificationName, ProcessInfoPerformanceProfileDidChangeNotification);
_NS_PRIVATE_DEF_CONST(NS::DeviceCertification, DeviceCertificationiPhonePerformanceGaming);
_NS_PRIVATE_DEF_CONST(NS::ProcessPerformanceProfile, ProcessPerformanceProfileDefault);
_NS_PRIVATE_DEF_CONST(NS::ProcessPerformanceProfile, ProcessPerformanceProfileSustained);

_NS_INLINE NS::ProcessInfo* NS::ProcessInfo::processInfo()
{
    return Object::sendMessage<ProcessInfo*>(_NS_PRIVATE_CLS(NSProcessInfo), _NS_PRIVATE_SEL(processInfo));
}

_NS_INLINE NS::Array* NS::ProcessInfo::arguments() const
{
    return Object::sendMessage<Array*>(this, _NS_PRIVATE_SEL(arguments));
}

_NS_INLINE NS::Dictionary* NS::ProcessInfo::environment() const
{
    return Object::sendMessage<Dictionary*>(this, _NS_PRIVATE_SEL(environment));
}

_NS_INLINE NS::String* NS::ProcessInfo::hostName() const
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(hostName));
}

_NS_INLINE NS::String* NS::ProcessInfo::processName() const
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(processName));
}

_NS_INLINE void NS::ProcessInfo::setProcessName(const String* pString)
{
    Object::sendMessage<void>(this, _NS_PRIVATE_SEL(setProcessName_), pString);
}

_NS_INLINE int NS::ProcessInfo::processIdentifier() const
{
    return Object::sendMessage<int>(this, _NS_PRIVATE_SEL(processIdentifier));
}

_NS_INLINE NS::String* NS::ProcessInfo::globallyUniqueString() const
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(globallyUniqueString));
}

_NS_INLINE NS::String* NS::ProcessInfo::userName() const
{
    return Object::sendMessageSafe<String*>(this, _NS_PRIVATE_SEL(userName));
}

_NS_INLINE NS::String* NS::ProcessInfo::fullUserName() const
{
    return Object::sendMessageSafe<String*>(this, _NS_PRIVATE_SEL(fullUserName));
}

_NS_INLINE NS::UInteger NS::ProcessInfo::operatingSystem() const
{
    return Object::sendMessage<UInteger>(this, _NS_PRIVATE_SEL(operatingSystem));
}

_NS_INLINE NS::OperatingSystemVersion NS::ProcessInfo::operatingSystemVersion() const
{
    return Object::sendMessage<OperatingSystemVersion>(this, _NS_PRIVATE_SEL(operatingSystemVersion));
}

_NS_INLINE NS::String* NS::ProcessInfo::operatingSystemVersionString() const
{
    return Object::sendMessage<String*>(this, _NS_PRIVATE_SEL(operatingSystemVersionString));
}

_NS_INLINE bool NS::ProcessInfo::isOperatingSystemAtLeastVersion(OperatingSystemVersion version) const
{
    return Object::sendMessage<bool>(this, _NS_PRIVATE_SEL(isOperatingSystemAtLeastVersion_), version);
}

_NS_INLINE NS::UInteger NS::ProcessInfo::processorCount() const
{
    return Object::sendMessage<UInteger>(this, _NS_PRIVATE_SEL(processorCount));
}

_NS_INLINE NS::UInteger NS::ProcessInfo::activeProcessorCount() const
{
    return Object::sendMessage<UInteger>(this, _NS_PRIVATE_SEL(activeProcessorCount));
}

_NS_INLINE unsigned long long NS::ProcessInfo::physicalMemory() const
{
    return Object::sendMessage<unsigned long long>(this, _NS_PRIVATE_SEL(physicalMemory));
}

_NS_INLINE NS::TimeInterval NS::ProcessInfo::systemUptime() const
{
    return Object::sendMessage<TimeInterval>(this, _NS_PRIVATE_SEL(systemUptime));
}

_NS_INLINE void NS::ProcessInfo::disableSuddenTermination()
{
    Object::sendMessageSafe<void>(this, _NS_PRIVATE_SEL(disableSuddenTermination));
}

_NS_INLINE void NS::ProcessInfo::enableSuddenTermination()
{
    Object::sendMessageSafe<void>(this, _NS_PRIVATE_SEL(enableSuddenTermination));
}

_NS_INLINE void NS::ProcessInfo::disableAutomaticTermination(const String* pReason)
{
    Object::sendMessageSafe<void>(this, _NS_PRIVATE_SEL(disableAutomaticTermination_), pReason);
}

_NS_INLINE void NS::ProcessInfo::enableAutomaticTermination(const String* pReason)
{
    Object::sendMessageSafe<void>(this, _NS_PRIVATE_SEL(enableAutomaticTermination_), pReason);
}

_NS_INLINE bool NS::ProcessInfo::automaticTerminationSupportEnabled() const
{
    return Object::sendMessageSafe<bool>(this, _NS_PRIVATE_SEL(automaticTerminationSupportEnabled));
}

_NS_INLINE void NS::ProcessInfo::setAutomaticTerminationSupportEnabled(bool enabled)
{
    Object::sendMessageSafe<void>(this, _NS_PRIVATE_SEL(setAutomaticTerminationSupportEnabled_), enabled);
}

_NS_INLINE NS::Object* NS::ProcessInfo::beginActivity(ActivityOptions options, const String* pReason)
{
    return Object::sendMessage<Object*>(this, _NS_PRIVATE_SEL(beginActivityWithOptions_reason_), options, pReason);
}

_NS_INLINE void NS::ProcessInfo::endActivity(Object* pActivity)
{
    Object::sendMessage<void>(this, _NS_PRIVATE_SEL(endActivity_), pActivity);
}

_NS_INLINE void NS::ProcessInfo::performActivity(ActivityOptions options, const String* pReason, void (^block)(void))
{
    Object::sendMessage<void>(this, _NS_PRIVATE_SEL(performActivityWithOptions_reason_usingBlock_), options, pReason, block);
}

_NS_INLINE void NS::ProcessInfo::performActivity(ActivityOptions options, const String* pReason, const std::function<void()>& function)
{
    __block std::function<void()> blockFunction = function;

    performActivity(options, pReason, ^() { blockFunction(); });
}

_NS_INLINE void NS::ProcessInfo::performExpiringActivity(const String* pReason, void (^block)(bool expired))
{
    Object::sendMessageSafe<void>(this, _NS_PRIVATE_SEL(performExpiringActivityWithReason_usingBlock_), pReason, block);
}

_NS_INLINE void NS::ProcessInfo::performExpiringActivity(const String* pReason, const std::function<void(bool expired)>& function)
{
    __block std::function<void(bool expired)> blockFunction = function;

    performExpiringActivity(pReason, ^(bool expired) { blockFunction(expired); });
}

_NS_INLINE NS::ProcessInfoThermalState NS::ProcessInfo::thermalState() const
{
    return Object::sendMessage<ProcessInfoThermalState>(this, _NS_PRIVATE_SEL(thermalState));
}

_NS_INLINE bool NS::ProcessInfo::isLowPowerModeEnabled() const
{
    return Object::sendMessageSafe<bool>(this, _NS_PRIVATE_SEL(isLowPowerModeEnabled));
}

_NS_INLINE bool NS::ProcessInfo::isiOSAppOnMac() const
{
    return Object::sendMessageSafe<bool>(this, _NS_PRIVATE_SEL(isiOSAppOnMac));
}

_NS_INLINE bool NS::ProcessInfo::isMacCatalystApp() const
{
    return Object::sendMessageSafe<bool>(this, _NS_PRIVATE_SEL(isMacCatalystApp));
}

_NS_INLINE bool NS::ProcessInfo::isDeviceCertified(DeviceCertification performanceTier) const
{
    return Object::sendMessageSafe<bool>(this, _NS_PRIVATE_SEL(isDeviceCertified_), performanceTier);
}

_NS_INLINE bool NS::ProcessInfo::hasPerformanceProfile(ProcessPerformanceProfile performanceProfile) const
{
    return Object::sendMessageSafe<bool>(this, _NS_PRIVATE_SEL(hasPerformanceProfile_), performanceProfile);
}

/*****Immutable Set*******/

namespace NS
{
    class Set : public NS::Copying <Set>
    {
        public:
            UInteger count() const;
            Enumerator<Object>* objectEnumerator() const;

            static Set* alloc();

            Set* init();
            Set* init(const Object* const* pObjects, UInteger count);
            Set* init(const class Coder* pCoder);

    };
}

_NS_INLINE NS::UInteger NS::Set::count() const
{
    return NS::Object::sendMessage<NS::UInteger>(this, _NS_PRIVATE_SEL(count));
}

_NS_INLINE NS::Enumerator<NS::Object>* NS::Set::objectEnumerator() const
{
    return NS::Object::sendMessage<Enumerator<NS::Object>*>(this, _NS_PRIVATE_SEL(objectEnumerator));
}

_NS_INLINE NS::Set* NS::Set::alloc()
{
    return NS::Object::alloc<Set>(_NS_PRIVATE_CLS(NSSet));
}

_NS_INLINE NS::Set* NS::Set::init()
{
    return NS::Object::init<Set>();
}

_NS_INLINE NS::Set* NS::Set::init(const Object* const* pObjects, NS::UInteger count)
{
    return NS::Object::sendMessage<Set*>(this, _NS_PRIVATE_SEL(initWithObjects_count_), pObjects, count);
}

_NS_INLINE NS::Set* NS::Set::init(const class Coder* pCoder)
{
    return Object::sendMessage<Set*>(this, _NS_PRIVATE_SEL(initWithCoder_), pCoder);
}

#pragma once

#include <cstddef>

namespace NS
{
template <class _Class>
class SharedPtr
{
public:
    /**
     * Create a new null pointer.
     */
    SharedPtr();

    /**
     * Destroy this SharedPtr, decreasing the reference count.
     */
    ~SharedPtr();

    /**
     * Create a new null pointer.
     */
    SharedPtr(std::nullptr_t) noexcept;

    /**
     * SharedPtr copy constructor.
     */
    SharedPtr(const SharedPtr<_Class>& other) noexcept;

    /**
     * Construction from another pointee type.
     */
    template <class _OtherClass>
    SharedPtr(const SharedPtr<_OtherClass>& other, typename std::enable_if_t<std::is_convertible_v<_OtherClass *, _Class *>> * = nullptr) noexcept;

    /**
     * SharedPtr move constructor.
     */
    SharedPtr(SharedPtr<_Class>&& other) noexcept;

    /**
     * Move from another pointee type.
     */
    template <class _OtherClass>
    SharedPtr(SharedPtr<_OtherClass>&& other, typename std::enable_if_t<std::is_convertible_v<_OtherClass *, _Class *>> * = nullptr) noexcept;

    /**
     * Copy assignment operator.
     * Copying increases reference count. Only releases previous pointee if objects are different.
     */
    SharedPtr& operator=(const SharedPtr<_Class>& other);

    /**
     * Copy-assignment from different pointee.
     * Copying increases reference count. Only releases previous pointee if objects are different.
     */
    template <class _OtherClass>
    typename std::enable_if_t<std::is_convertible_v<_OtherClass *, _Class *>, SharedPtr &>
    operator=(const SharedPtr<_OtherClass>& other);

    /**
     * Move assignment operator.
     * Move without affecting reference counts, unless pointees are equal. Moved-from object is reset to nullptr.
     */
    SharedPtr& operator=(SharedPtr<_Class>&& other);

    /**
     * Move-asignment from different pointee.
     * Move without affecting reference counts, unless pointees are equal. Moved-from object is reset to nullptr.
     */
    template <class _OtherClass>
    typename std::enable_if_t<std::is_convertible_v<_OtherClass *, _Class *>, SharedPtr &>
    operator=(SharedPtr<_OtherClass>&& other);

    /**
     * Access raw pointee.
     * @warning Avoid wrapping the returned value again, as it may lead double frees unless this object becomes detached.
     */
    _Class* get() const;

    /**
     * Call operations directly on the pointee.
     */
    _Class* operator->() const;

    /**
     * Implicit cast to bool.
     */
    explicit operator bool() const;

    /**
     * Reset this SharedPtr to null, decreasing the reference count.
     */
    void reset();

    /**
     * Detach the SharedPtr from the pointee, without decreasing the reference count.
     */
    void detach();

    template <class _OtherClass>
    friend SharedPtr<_OtherClass> RetainPtr(_OtherClass* ptr);

    template <class _OtherClass>
    friend SharedPtr<_OtherClass> TransferPtr(_OtherClass* ptr);

private:
    _Class* m_pObject;
};

/**
 * Create a SharedPtr by retaining an existing raw pointer.
 * Increases the reference count of the passed-in object.
 * If the passed-in object was in an AutoreleasePool, it will be removed from it.
 */
template <class _Class>
_NS_INLINE NS::SharedPtr<_Class> RetainPtr(_Class* pObject)
{
    NS::SharedPtr<_Class> ret;
    ret.m_pObject = pObject->retain();
    return ret;
}

/*
 * Create a SharedPtr by transfering the ownership of an existing raw pointer to SharedPtr.
 * Does not increase the reference count of the passed-in pointer, it is assumed to be >= 1.
 * This method does not remove objects from an AutoreleasePool.
*/
template <class _Class>
_NS_INLINE NS::SharedPtr<_Class> TransferPtr(_Class* pObject)
{
    NS::SharedPtr<_Class> ret;
    ret.m_pObject = pObject;
    return ret;
}

}

template <class _Class>
_NS_INLINE NS::SharedPtr<_Class>::SharedPtr()
    : m_pObject(nullptr)
{
}

template <class _Class>
_NS_INLINE NS::SharedPtr<_Class>::~SharedPtr<_Class>() __attribute__((no_sanitize("undefined")))
{
    m_pObject->release();
}

template <class _Class>
_NS_INLINE NS::SharedPtr<_Class>::SharedPtr(std::nullptr_t) noexcept
    : m_pObject(nullptr)
{
}

template <class _Class>
_NS_INLINE NS::SharedPtr<_Class>::SharedPtr(const SharedPtr<_Class>& other) noexcept
    : m_pObject(other.m_pObject->retain())
{
}

template <class _Class>
template <class _OtherClass>
_NS_INLINE NS::SharedPtr<_Class>::SharedPtr(const SharedPtr<_OtherClass>& other, typename std::enable_if_t<std::is_convertible_v<_OtherClass *, _Class *>> *) noexcept
    : m_pObject(reinterpret_cast<_Class*>(other.get()->retain()))
{
}

template <class _Class>
_NS_INLINE NS::SharedPtr<_Class>::SharedPtr(SharedPtr<_Class>&& other) noexcept
    : m_pObject(other.m_pObject)
{
    other.m_pObject = nullptr;
}

template <class _Class>
template <class _OtherClass>
_NS_INLINE NS::SharedPtr<_Class>::SharedPtr(SharedPtr<_OtherClass>&& other, typename std::enable_if_t<std::is_convertible_v<_OtherClass *, _Class *>> *) noexcept
    : m_pObject(reinterpret_cast<_Class*>(other.get()))
{
    other.detach();
}

template <class _Class>
_NS_INLINE _Class* NS::SharedPtr<_Class>::get() const
{
    return m_pObject;
}

template <class _Class>
_NS_INLINE _Class* NS::SharedPtr<_Class>::operator->() const
{
    return m_pObject;
}

template <class _Class>
_NS_INLINE NS::SharedPtr<_Class>::operator bool() const
{
    return nullptr != m_pObject;
}

template <class _Class>
_NS_INLINE void NS::SharedPtr<_Class>::reset() __attribute__((no_sanitize("undefined")))
{
    m_pObject->release();
    m_pObject = nullptr;
}

template <class _Class>
_NS_INLINE void NS::SharedPtr<_Class>::detach()
{
    m_pObject = nullptr;
}

template <class _Class>
_NS_INLINE NS::SharedPtr<_Class>& NS::SharedPtr<_Class>::operator=(const SharedPtr<_Class>& other) __attribute__((no_sanitize("undefined")))
{
    _Class* pOldObject = m_pObject;

    m_pObject = other.m_pObject->retain();

    pOldObject->release();

    return *this;
}

template <class _Class>
template <class _OtherClass>
typename std::enable_if_t<std::is_convertible_v<_OtherClass *, _Class *>, NS::SharedPtr<_Class> &>
_NS_INLINE NS::SharedPtr<_Class>::operator=(const SharedPtr<_OtherClass>& other) __attribute__((no_sanitize("undefined")))
{
    _Class* pOldObject = m_pObject;

    m_pObject = reinterpret_cast<_Class*>(other.get()->retain());

    pOldObject->release();

    return *this;
}

template <class _Class>
_NS_INLINE NS::SharedPtr<_Class>& NS::SharedPtr<_Class>::operator=(SharedPtr<_Class>&& other) __attribute__((no_sanitize("undefined")))
{
    if (m_pObject != other.m_pObject)
    {
        m_pObject->release();
        m_pObject = other.m_pObject;
    }
    else
    {
        m_pObject = other.m_pObject;
        other.m_pObject->release();
    }
    other.m_pObject = nullptr;
    return *this;
}

template <class _Class>
template <class _OtherClass>
typename std::enable_if_t<std::is_convertible_v<_OtherClass *, _Class *>, NS::SharedPtr<_Class> &>
_NS_INLINE NS::SharedPtr<_Class>::operator=(SharedPtr<_OtherClass>&& other) __attribute__((no_sanitize("undefined")))
{
    if (m_pObject != other.get())
    {
        m_pObject->release();
        m_pObject = reinterpret_cast<_Class*>(other.get());
        other.detach();
    }
    else
    {
        m_pObject = other.get();
        other.reset();
    }
    return *this;
}

template <class _ClassLhs, class _ClassRhs>
_NS_INLINE bool operator==(const NS::SharedPtr<_ClassLhs>& lhs, const NS::SharedPtr<_ClassRhs>& rhs)
{
    return lhs.get() == rhs.get();
}

template <class _ClassLhs, class _ClassRhs>
_NS_INLINE bool operator!=(const NS::SharedPtr<_ClassLhs>& lhs, const NS::SharedPtr<_ClassRhs>& rhs)
{
    return lhs.get() != rhs.get();
}

namespace NS
{
class URL : public Copying<URL>
{
public:
    static URL* fileURLWithPath(const class String* pPath);

    static URL* alloc();
    URL*        init();
    URL*        init(const class String* pString);
    URL*        initFileURLWithPath(const class String* pPath);

    const char* fileSystemRepresentation() const;
};
}

_NS_INLINE NS::URL* NS::URL::fileURLWithPath(const String* pPath)
{
    return Object::sendMessage<URL*>(_NS_PRIVATE_CLS(NSURL), _NS_PRIVATE_SEL(fileURLWithPath_), pPath);
}

_NS_INLINE NS::URL* NS::URL::alloc()
{
    return Object::alloc<URL>(_NS_PRIVATE_CLS(NSURL));
}

_NS_INLINE NS::URL* NS::URL::init()
{
    return Object::init<URL>();
}

_NS_INLINE NS::URL* NS::URL::init(const String* pString)
{
    return Object::sendMessage<URL*>(this, _NS_PRIVATE_SEL(initWithString_), pString);
}

_NS_INLINE NS::URL* NS::URL::initFileURLWithPath(const String* pPath)
{
    return Object::sendMessage<URL*>(this, _NS_PRIVATE_SEL(initFileURLWithPath_), pPath);
}

_NS_INLINE const char* NS::URL::fileSystemRepresentation() const
{
    return Object::sendMessage<const char*>(this, _NS_PRIVATE_SEL(fileSystemRepresentation));
}

#pragma once

#define _MTL_EXPORT _NS_EXPORT
#define _MTL_EXTERN _NS_EXTERN
#define _MTL_INLINE _NS_INLINE
#define _MTL_PACKED _NS_PACKED

#define _MTL_CONST(type, name) _NS_CONST(type, name)
#define _MTL_ENUM(type, name) _NS_ENUM(type, name)
#define _MTL_OPTIONS(type, name) _NS_OPTIONS(type, name)

#define _MTL_VALIDATE_SIZE(ns, name) _NS_VALIDATE_SIZE(ns, name)
#define _MTL_VALIDATE_ENUM(ns, name) _NS_VALIDATE_ENUM(ns, name)

#pragma once

#include <objc/runtime.h>

#define _MTL_PRIVATE_CLS(symbol) (MTL::Private::Class::s_k##symbol)
#define _MTL_PRIVATE_SEL(accessor) (MTL::Private::Selector::s_k##accessor)

#if defined(MTL_PRIVATE_IMPLEMENTATION)

#ifdef METALCPP_SYMBOL_VISIBILITY_HIDDEN
#define _MTL_PRIVATE_VISIBILITY __attribute__((visibility("hidden")))
#else
#define _MTL_PRIVATE_VISIBILITY __attribute__((visibility("default")))
#endif // METALCPP_SYMBOL_VISIBILITY_HIDDEN

#define _MTL_PRIVATE_IMPORT __attribute__((weak_import))

#ifdef __OBJC__
#define _MTL_PRIVATE_OBJC_LOOKUP_CLASS(symbol) ((__bridge void*)objc_lookUpClass(#symbol))
#define _MTL_PRIVATE_OBJC_GET_PROTOCOL(symbol) ((__bridge void*)objc_getProtocol(#symbol))
#else
#define _MTL_PRIVATE_OBJC_LOOKUP_CLASS(symbol) objc_lookUpClass(#symbol)
#define _MTL_PRIVATE_OBJC_GET_PROTOCOL(symbol) objc_getProtocol(#symbol)
#endif // __OBJC__

#define _MTL_PRIVATE_DEF_CLS(symbol) void* s_k##symbol _MTL_PRIVATE_VISIBILITY = _MTL_PRIVATE_OBJC_LOOKUP_CLASS(symbol)
#define _MTL_PRIVATE_DEF_PRO(symbol) void* s_k##symbol _MTL_PRIVATE_VISIBILITY = _MTL_PRIVATE_OBJC_GET_PROTOCOL(symbol)
#define _MTL_PRIVATE_DEF_SEL(accessor, symbol) SEL s_k##accessor _MTL_PRIVATE_VISIBILITY = sel_registerName(symbol)

#include <dlfcn.h>
#define MTL_DEF_FUNC( name, signature ) \
    using Fn##name = signature; \
    Fn##name name = reinterpret_cast< Fn##name >( dlsym( RTLD_DEFAULT, #name ) )

namespace MTL::Private
{
    template <typename _Type>
    inline _Type const LoadSymbol(const char* pSymbol)
    {
        const _Type* pAddress = static_cast<_Type*>(dlsym(RTLD_DEFAULT, pSymbol));

        return pAddress ? *pAddress : nullptr;
    }
} // MTL::Private

#if defined(__MAC_26_0) || defined(__IPHONE_26_0) || defined(__TVOS_26_0)

#define _MTL_PRIVATE_DEF_STR(type, symbol)                  \
    _MTL_EXTERN type const MTL##symbol _MTL_PRIVATE_IMPORT; \
    type const                         MTL::symbol = (nullptr != &MTL##symbol) ? MTL##symbol : nullptr

#define _MTL_PRIVATE_DEF_CONST(type, symbol)              \
    _MTL_EXTERN type const MTL##symbol _MTL_PRIVATE_IMPORT; \
    type const                         MTL::symbol = (nullptr != &MTL##symbol) ? MTL##symbol : nullptr

#define _MTL_PRIVATE_DEF_WEAK_CONST(type, symbol) \
    _MTL_EXTERN type const MTL##symbol;    \
    type const             MTL::symbol = MTL::Private::LoadSymbol<type>("MTL" #symbol)

#else

#define _MTL_PRIVATE_DEF_STR(type, symbol) \
    _MTL_EXTERN type const MTL##symbol;    \
    type const             MTL::symbol = MTL::Private::LoadSymbol<type>("MTL" #symbol)

#define _MTL_PRIVATE_DEF_CONST(type, symbol) \
    _MTL_EXTERN type const MTL##symbol;    \
    type const             MTL::symbol = MTL::Private::LoadSymbol<type>("MTL" #symbol)

#define _MTL_PRIVATE_DEF_WEAK_CONST(type, symbol) _MTL_PRIVATE_DEF_CONST(type, symbol)

#endif

#else

#define _MTL_PRIVATE_DEF_CLS(symbol) extern void* s_k##symbol
#define _MTL_PRIVATE_DEF_PRO(symbol) extern void* s_k##symbol
#define _MTL_PRIVATE_DEF_SEL(accessor, symbol) extern SEL s_k##accessor
#define _MTL_PRIVATE_DEF_STR(type, symbol) extern type const MTL::symbol
#define _MTL_PRIVATE_DEF_CONST(type, symbol) extern type const MTL::symbol
#define _MTL_PRIVATE_DEF_WEAK_CONST(type, symbol) extern type const MTL::symbol

#endif // MTL_PRIVATE_IMPLEMENTATION

namespace MTL
{
namespace Private
{
    namespace Class
    {

    } // Class
} // Private
} // MTL

namespace MTL
{
namespace Private
{
    namespace Protocol
    {

    } // Protocol
} // Private
} // MTL

namespace MTL
{
namespace Private
{
    namespace Selector
    {

        _MTL_PRIVATE_DEF_SEL(beginScope,
            "beginScope");
        _MTL_PRIVATE_DEF_SEL(endScope,
            "endScope");
    } // Class
} // Private
} // MTL

namespace MTL::Private::Class
{

_MTL_PRIVATE_DEF_CLS(MTL4AccelerationStructureBoundingBoxGeometryDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4AccelerationStructureCurveGeometryDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4AccelerationStructureDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4AccelerationStructureGeometryDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4AccelerationStructureMotionBoundingBoxGeometryDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4AccelerationStructureMotionCurveGeometryDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4AccelerationStructureMotionTriangleGeometryDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4AccelerationStructureTriangleGeometryDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4ArgumentTableDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4BinaryFunctionDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4CommandAllocatorDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4CommandBufferOptions);
_MTL_PRIVATE_DEF_CLS(MTL4CommandQueueDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4CommitOptions);
_MTL_PRIVATE_DEF_CLS(MTL4CompilerDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4CompilerTaskOptions);
_MTL_PRIVATE_DEF_CLS(MTL4ComputePipelineDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4CounterHeapDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4FunctionDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4IndirectInstanceAccelerationStructureDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4InstanceAccelerationStructureDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4LibraryDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4LibraryFunctionDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4MachineLearningPipelineDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4MachineLearningPipelineReflection);
_MTL_PRIVATE_DEF_CLS(MTL4MeshRenderPipelineDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4PipelineDataSetSerializerDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4PipelineDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4PipelineOptions);
_MTL_PRIVATE_DEF_CLS(MTL4PipelineStageDynamicLinkingDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4PrimitiveAccelerationStructureDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4RenderPassDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4RenderPipelineBinaryFunctionsDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4RenderPipelineColorAttachmentDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4RenderPipelineColorAttachmentDescriptorArray);
_MTL_PRIVATE_DEF_CLS(MTL4RenderPipelineDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4RenderPipelineDynamicLinkingDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4SpecializedFunctionDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4StaticLinkingDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4StitchedFunctionDescriptor);
_MTL_PRIVATE_DEF_CLS(MTL4TileRenderPipelineDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLAccelerationStructureBoundingBoxGeometryDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLAccelerationStructureCurveGeometryDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLAccelerationStructureDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLAccelerationStructureGeometryDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLAccelerationStructureMotionCurveGeometryDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLAccelerationStructureMotionTriangleGeometryDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLAccelerationStructurePassDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLAccelerationStructurePassSampleBufferAttachmentDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLAccelerationStructurePassSampleBufferAttachmentDescriptorArray);
_MTL_PRIVATE_DEF_CLS(MTLAccelerationStructureTriangleGeometryDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLArchitecture);
_MTL_PRIVATE_DEF_CLS(MTLArgument);
_MTL_PRIVATE_DEF_CLS(MTLArgumentDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLArrayType);
_MTL_PRIVATE_DEF_CLS(MTLAttribute);
_MTL_PRIVATE_DEF_CLS(MTLAttributeDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLAttributeDescriptorArray);
_MTL_PRIVATE_DEF_CLS(MTLBinaryArchiveDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLBlitPassDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLBlitPassSampleBufferAttachmentDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLBlitPassSampleBufferAttachmentDescriptorArray);
_MTL_PRIVATE_DEF_CLS(MTLBufferLayoutDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLBufferLayoutDescriptorArray);
_MTL_PRIVATE_DEF_CLS(MTLCaptureDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLCaptureManager);
_MTL_PRIVATE_DEF_CLS(MTLCommandBufferDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLCommandQueueDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLCompileOptions);
_MTL_PRIVATE_DEF_CLS(MTLComputePassDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLComputePassSampleBufferAttachmentDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLComputePassSampleBufferAttachmentDescriptorArray);
_MTL_PRIVATE_DEF_CLS(MTLComputePipelineDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLComputePipelineReflection);
_MTL_PRIVATE_DEF_CLS(MTLCounterSampleBufferDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLDepthStencilDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLFunctionConstant);
_MTL_PRIVATE_DEF_CLS(MTLFunctionConstantValues);
_MTL_PRIVATE_DEF_CLS(MTLFunctionDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLFunctionReflection);
_MTL_PRIVATE_DEF_CLS(MTLFunctionStitchingAttributeAlwaysInline);
_MTL_PRIVATE_DEF_CLS(MTLFunctionStitchingFunctionNode);
_MTL_PRIVATE_DEF_CLS(MTLFunctionStitchingGraph);
_MTL_PRIVATE_DEF_CLS(MTLFunctionStitchingInputNode);
_MTL_PRIVATE_DEF_CLS(MTLHeapDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLIOCommandQueueDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLIndirectCommandBufferDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLIndirectInstanceAccelerationStructureDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLInstanceAccelerationStructureDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLIntersectionFunctionDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLIntersectionFunctionTableDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLLinkedFunctions);
_MTL_PRIVATE_DEF_CLS(MTLLogStateDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLLogicalToPhysicalColorAttachmentMap);
_MTL_PRIVATE_DEF_CLS(MTLMeshRenderPipelineDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLMotionKeyframeData);
_MTL_PRIVATE_DEF_CLS(MTLPipelineBufferDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLPipelineBufferDescriptorArray);
_MTL_PRIVATE_DEF_CLS(MTLPointerType);
_MTL_PRIVATE_DEF_CLS(MTLPrimitiveAccelerationStructureDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLRasterizationRateLayerArray);
_MTL_PRIVATE_DEF_CLS(MTLRasterizationRateLayerDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLRasterizationRateMapDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLRasterizationRateSampleArray);
_MTL_PRIVATE_DEF_CLS(MTLRenderPassAttachmentDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLRenderPassColorAttachmentDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLRenderPassColorAttachmentDescriptorArray);
_MTL_PRIVATE_DEF_CLS(MTLRenderPassDepthAttachmentDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLRenderPassDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLRenderPassSampleBufferAttachmentDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLRenderPassSampleBufferAttachmentDescriptorArray);
_MTL_PRIVATE_DEF_CLS(MTLRenderPassStencilAttachmentDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLRenderPipelineColorAttachmentDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLRenderPipelineColorAttachmentDescriptorArray);
_MTL_PRIVATE_DEF_CLS(MTLRenderPipelineDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLRenderPipelineFunctionsDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLRenderPipelineReflection);
_MTL_PRIVATE_DEF_CLS(MTLResidencySetDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLResourceStatePassDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLResourceStatePassSampleBufferAttachmentDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLResourceStatePassSampleBufferAttachmentDescriptorArray);
_MTL_PRIVATE_DEF_CLS(MTLResourceViewPoolDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLSamplerDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLSharedEventHandle);
_MTL_PRIVATE_DEF_CLS(MTLSharedEventListener);
_MTL_PRIVATE_DEF_CLS(MTLSharedTextureHandle);
_MTL_PRIVATE_DEF_CLS(MTLStageInputOutputDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLStencilDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLStitchedLibraryDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLStructMember);
_MTL_PRIVATE_DEF_CLS(MTLStructType);
_MTL_PRIVATE_DEF_CLS(MTLTensorDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLTensorExtents);
_MTL_PRIVATE_DEF_CLS(MTLTensorReferenceType);
_MTL_PRIVATE_DEF_CLS(MTLTextureDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLTextureReferenceType);
_MTL_PRIVATE_DEF_CLS(MTLTextureViewDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLTileRenderPipelineColorAttachmentDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLTileRenderPipelineColorAttachmentDescriptorArray);
_MTL_PRIVATE_DEF_CLS(MTLTileRenderPipelineDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLType);
_MTL_PRIVATE_DEF_CLS(MTLVertexAttribute);
_MTL_PRIVATE_DEF_CLS(MTLVertexAttributeDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLVertexAttributeDescriptorArray);
_MTL_PRIVATE_DEF_CLS(MTLVertexBufferLayoutDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLVertexBufferLayoutDescriptorArray);
_MTL_PRIVATE_DEF_CLS(MTLVertexDescriptor);
_MTL_PRIVATE_DEF_CLS(MTLVisibleFunctionTableDescriptor);

}

namespace MTL::Private::Protocol
{

_MTL_PRIVATE_DEF_PRO(MTL4Archive);
_MTL_PRIVATE_DEF_PRO(MTL4ArgumentTable);
_MTL_PRIVATE_DEF_PRO(MTL4BinaryFunction);
_MTL_PRIVATE_DEF_PRO(MTL4CommandAllocator);
_MTL_PRIVATE_DEF_PRO(MTL4CommandBuffer);
_MTL_PRIVATE_DEF_PRO(MTL4CommandEncoder);
_MTL_PRIVATE_DEF_PRO(MTL4CommandQueue);
_MTL_PRIVATE_DEF_PRO(MTL4CommitFeedback);
_MTL_PRIVATE_DEF_PRO(MTL4Compiler);
_MTL_PRIVATE_DEF_PRO(MTL4CompilerTask);
_MTL_PRIVATE_DEF_PRO(MTL4ComputeCommandEncoder);
_MTL_PRIVATE_DEF_PRO(MTL4CounterHeap);
_MTL_PRIVATE_DEF_PRO(MTL4MachineLearningCommandEncoder);
_MTL_PRIVATE_DEF_PRO(MTL4MachineLearningPipelineState);
_MTL_PRIVATE_DEF_PRO(MTL4PipelineDataSetSerializer);
_MTL_PRIVATE_DEF_PRO(MTL4RenderCommandEncoder);
_MTL_PRIVATE_DEF_PRO(MTLAccelerationStructure);
_MTL_PRIVATE_DEF_PRO(MTLAccelerationStructureCommandEncoder);
_MTL_PRIVATE_DEF_PRO(MTLAllocation);
_MTL_PRIVATE_DEF_PRO(MTLArgumentEncoder);
_MTL_PRIVATE_DEF_PRO(MTLBinaryArchive);
_MTL_PRIVATE_DEF_PRO(MTLBinding);
_MTL_PRIVATE_DEF_PRO(MTLBlitCommandEncoder);
_MTL_PRIVATE_DEF_PRO(MTLBuffer);
_MTL_PRIVATE_DEF_PRO(MTLBufferBinding);
_MTL_PRIVATE_DEF_PRO(MTLCommandBuffer);
_MTL_PRIVATE_DEF_PRO(MTLCommandBufferEncoderInfo);
_MTL_PRIVATE_DEF_PRO(MTLCommandEncoder);
_MTL_PRIVATE_DEF_PRO(MTLCommandQueue);
_MTL_PRIVATE_DEF_PRO(MTLComputeCommandEncoder);
_MTL_PRIVATE_DEF_PRO(MTLComputePipelineState);
_MTL_PRIVATE_DEF_PRO(MTLCounter);
_MTL_PRIVATE_DEF_PRO(MTLCounterSampleBuffer);
_MTL_PRIVATE_DEF_PRO(MTLCounterSet);
_MTL_PRIVATE_DEF_PRO(MTLDepthStencilState);
_MTL_PRIVATE_DEF_PRO(MTLDevice);
_MTL_PRIVATE_DEF_PRO(MTLDrawable);
_MTL_PRIVATE_DEF_PRO(MTLDynamicLibrary);
_MTL_PRIVATE_DEF_PRO(MTLEvent);
_MTL_PRIVATE_DEF_PRO(MTLFence);
_MTL_PRIVATE_DEF_PRO(MTLFunction);
_MTL_PRIVATE_DEF_PRO(MTLFunctionHandle);
_MTL_PRIVATE_DEF_PRO(MTLFunctionLog);
_MTL_PRIVATE_DEF_PRO(MTLFunctionLogDebugLocation);
_MTL_PRIVATE_DEF_PRO(MTLFunctionStitchingAttribute);
_MTL_PRIVATE_DEF_PRO(MTLFunctionStitchingNode);
_MTL_PRIVATE_DEF_PRO(MTLHeap);
_MTL_PRIVATE_DEF_PRO(MTLIOCommandBuffer);
_MTL_PRIVATE_DEF_PRO(MTLIOCommandQueue);
_MTL_PRIVATE_DEF_PRO(MTLIOFileHandle);
_MTL_PRIVATE_DEF_PRO(MTLIOScratchBuffer);
_MTL_PRIVATE_DEF_PRO(MTLIOScratchBufferAllocator);
_MTL_PRIVATE_DEF_PRO(MTLIndirectCommandBuffer);
_MTL_PRIVATE_DEF_PRO(MTLIndirectComputeCommand);
_MTL_PRIVATE_DEF_PRO(MTLIndirectRenderCommand);
_MTL_PRIVATE_DEF_PRO(MTLIntersectionFunctionTable);
_MTL_PRIVATE_DEF_PRO(MTLLibrary);
_MTL_PRIVATE_DEF_PRO(MTLLogContainer);
_MTL_PRIVATE_DEF_PRO(MTLLogState);
_MTL_PRIVATE_DEF_PRO(MTLObjectPayloadBinding);
_MTL_PRIVATE_DEF_PRO(MTLParallelRenderCommandEncoder);
_MTL_PRIVATE_DEF_PRO(MTLRasterizationRateMap);
_MTL_PRIVATE_DEF_PRO(MTLRenderCommandEncoder);
_MTL_PRIVATE_DEF_PRO(MTLRenderPipelineState);
_MTL_PRIVATE_DEF_PRO(MTLResidencySet);
_MTL_PRIVATE_DEF_PRO(MTLResource);
_MTL_PRIVATE_DEF_PRO(MTLResourceStateCommandEncoder);
_MTL_PRIVATE_DEF_PRO(MTLResourceViewPool);
_MTL_PRIVATE_DEF_PRO(MTLSamplerState);
_MTL_PRIVATE_DEF_PRO(MTLSharedEvent);
_MTL_PRIVATE_DEF_PRO(MTLTensor);
_MTL_PRIVATE_DEF_PRO(MTLTensorBinding);
_MTL_PRIVATE_DEF_PRO(MTLTexture);
_MTL_PRIVATE_DEF_PRO(MTLTextureBinding);
_MTL_PRIVATE_DEF_PRO(MTLTextureViewPool);
_MTL_PRIVATE_DEF_PRO(MTLThreadgroupBinding);
_MTL_PRIVATE_DEF_PRO(MTLVisibleFunctionTable);

}

namespace MTL::Private::Selector
{

_MTL_PRIVATE_DEF_SEL(GPUEndTime,
    "GPUEndTime");
_MTL_PRIVATE_DEF_SEL(GPUStartTime,
    "GPUStartTime");
_MTL_PRIVATE_DEF_SEL(URL,
    "URL");
_MTL_PRIVATE_DEF_SEL(accelerationStructureCommandEncoder,
    "accelerationStructureCommandEncoder");
_MTL_PRIVATE_DEF_SEL(accelerationStructureCommandEncoderWithDescriptor_,
    "accelerationStructureCommandEncoderWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(accelerationStructurePassDescriptor,
    "accelerationStructurePassDescriptor");
_MTL_PRIVATE_DEF_SEL(accelerationStructureSizesWithDescriptor_,
    "accelerationStructureSizesWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(access,
    "access");
_MTL_PRIVATE_DEF_SEL(addAllocation_,
    "addAllocation:");
_MTL_PRIVATE_DEF_SEL(addAllocations_count_,
    "addAllocations:count:");
_MTL_PRIVATE_DEF_SEL(addBarrier,
    "addBarrier");
_MTL_PRIVATE_DEF_SEL(addCompletedHandler_,
    "addCompletedHandler:");
_MTL_PRIVATE_DEF_SEL(addComputePipelineFunctionsWithDescriptor_error_,
    "addComputePipelineFunctionsWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(addDebugMarker_range_,
    "addDebugMarker:range:");
_MTL_PRIVATE_DEF_SEL(addFeedbackHandler_,
    "addFeedbackHandler:");
_MTL_PRIVATE_DEF_SEL(addFunctionWithDescriptor_library_error_,
    "addFunctionWithDescriptor:library:error:");
_MTL_PRIVATE_DEF_SEL(addLibraryWithDescriptor_error_,
    "addLibraryWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(addLogHandler_,
    "addLogHandler:");
_MTL_PRIVATE_DEF_SEL(addMeshRenderPipelineFunctionsWithDescriptor_error_,
    "addMeshRenderPipelineFunctionsWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(addPresentedHandler_,
    "addPresentedHandler:");
_MTL_PRIVATE_DEF_SEL(addRenderPipelineFunctionsWithDescriptor_error_,
    "addRenderPipelineFunctionsWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(addResidencySet_,
    "addResidencySet:");
_MTL_PRIVATE_DEF_SEL(addResidencySets_count_,
    "addResidencySets:count:");
_MTL_PRIVATE_DEF_SEL(addScheduledHandler_,
    "addScheduledHandler:");
_MTL_PRIVATE_DEF_SEL(addTileRenderPipelineFunctionsWithDescriptor_error_,
    "addTileRenderPipelineFunctionsWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(alignment,
    "alignment");
_MTL_PRIVATE_DEF_SEL(allAllocations,
    "allAllocations");
_MTL_PRIVATE_DEF_SEL(allocatedSize,
    "allocatedSize");
_MTL_PRIVATE_DEF_SEL(allocationCount,
    "allocationCount");
_MTL_PRIVATE_DEF_SEL(allowDuplicateIntersectionFunctionInvocation,
    "allowDuplicateIntersectionFunctionInvocation");
_MTL_PRIVATE_DEF_SEL(allowGPUOptimizedContents,
    "allowGPUOptimizedContents");
_MTL_PRIVATE_DEF_SEL(allowReferencingUndefinedSymbols,
    "allowReferencingUndefinedSymbols");
_MTL_PRIVATE_DEF_SEL(alphaBlendOperation,
    "alphaBlendOperation");
_MTL_PRIVATE_DEF_SEL(alphaToCoverageState,
    "alphaToCoverageState");
_MTL_PRIVATE_DEF_SEL(alphaToOneState,
    "alphaToOneState");
_MTL_PRIVATE_DEF_SEL(architecture,
    "architecture");
_MTL_PRIVATE_DEF_SEL(areBarycentricCoordsSupported,
    "areBarycentricCoordsSupported");
_MTL_PRIVATE_DEF_SEL(areProgrammableSamplePositionsSupported,
    "areProgrammableSamplePositionsSupported");
_MTL_PRIVATE_DEF_SEL(areRasterOrderGroupsSupported,
    "areRasterOrderGroupsSupported");
_MTL_PRIVATE_DEF_SEL(argumentBuffersSupport,
    "argumentBuffersSupport");
_MTL_PRIVATE_DEF_SEL(argumentDescriptor,
    "argumentDescriptor");
_MTL_PRIVATE_DEF_SEL(argumentIndex,
    "argumentIndex");
_MTL_PRIVATE_DEF_SEL(argumentIndexStride,
    "argumentIndexStride");
_MTL_PRIVATE_DEF_SEL(arguments,
    "arguments");
_MTL_PRIVATE_DEF_SEL(arrayLength,
    "arrayLength");
_MTL_PRIVATE_DEF_SEL(arrayType,
    "arrayType");
_MTL_PRIVATE_DEF_SEL(attributeIndex,
    "attributeIndex");
_MTL_PRIVATE_DEF_SEL(attributeType,
    "attributeType");
_MTL_PRIVATE_DEF_SEL(attributes,
    "attributes");
_MTL_PRIVATE_DEF_SEL(backFaceStencil,
    "backFaceStencil");
_MTL_PRIVATE_DEF_SEL(barrierAfterEncoderStages_beforeEncoderStages_visibilityOptions_,
    "barrierAfterEncoderStages:beforeEncoderStages:visibilityOptions:");
_MTL_PRIVATE_DEF_SEL(barrierAfterQueueStages_beforeStages_,
    "barrierAfterQueueStages:beforeStages:");
_MTL_PRIVATE_DEF_SEL(barrierAfterQueueStages_beforeStages_visibilityOptions_,
    "barrierAfterQueueStages:beforeStages:visibilityOptions:");
_MTL_PRIVATE_DEF_SEL(barrierAfterStages_beforeQueueStages_visibilityOptions_,
    "barrierAfterStages:beforeQueueStages:visibilityOptions:");
_MTL_PRIVATE_DEF_SEL(baseResourceID,
    "baseResourceID");
_MTL_PRIVATE_DEF_SEL(beginCommandBufferWithAllocator_,
    "beginCommandBufferWithAllocator:");
_MTL_PRIVATE_DEF_SEL(beginCommandBufferWithAllocator_options_,
    "beginCommandBufferWithAllocator:options:");
_MTL_PRIVATE_DEF_SEL(binaryArchives,
    "binaryArchives");
_MTL_PRIVATE_DEF_SEL(binaryFunctions,
    "binaryFunctions");
_MTL_PRIVATE_DEF_SEL(binaryLinkedFunctions,
    "binaryLinkedFunctions");
_MTL_PRIVATE_DEF_SEL(bindings,
    "bindings");
_MTL_PRIVATE_DEF_SEL(blendingState,
    "blendingState");
_MTL_PRIVATE_DEF_SEL(blitCommandEncoder,
    "blitCommandEncoder");
_MTL_PRIVATE_DEF_SEL(blitCommandEncoderWithDescriptor_,
    "blitCommandEncoderWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(blitPassDescriptor,
    "blitPassDescriptor");
_MTL_PRIVATE_DEF_SEL(borderColor,
    "borderColor");
_MTL_PRIVATE_DEF_SEL(boundingBoxBuffer,
    "boundingBoxBuffer");
_MTL_PRIVATE_DEF_SEL(boundingBoxBufferOffset,
    "boundingBoxBufferOffset");
_MTL_PRIVATE_DEF_SEL(boundingBoxBuffers,
    "boundingBoxBuffers");
_MTL_PRIVATE_DEF_SEL(boundingBoxCount,
    "boundingBoxCount");
_MTL_PRIVATE_DEF_SEL(boundingBoxStride,
    "boundingBoxStride");
_MTL_PRIVATE_DEF_SEL(buffer,
    "buffer");
_MTL_PRIVATE_DEF_SEL(bufferAlignment,
    "bufferAlignment");
_MTL_PRIVATE_DEF_SEL(bufferBytesPerRow,
    "bufferBytesPerRow");
_MTL_PRIVATE_DEF_SEL(bufferDataSize,
    "bufferDataSize");
_MTL_PRIVATE_DEF_SEL(bufferDataType,
    "bufferDataType");
_MTL_PRIVATE_DEF_SEL(bufferIndex,
    "bufferIndex");
_MTL_PRIVATE_DEF_SEL(bufferOffset,
    "bufferOffset");
_MTL_PRIVATE_DEF_SEL(bufferPointerType,
    "bufferPointerType");
_MTL_PRIVATE_DEF_SEL(bufferSize,
    "bufferSize");
_MTL_PRIVATE_DEF_SEL(bufferStructType,
    "bufferStructType");
_MTL_PRIVATE_DEF_SEL(buffers,
    "buffers");
_MTL_PRIVATE_DEF_SEL(buildAccelerationStructure_descriptor_scratchBuffer_,
    "buildAccelerationStructure:descriptor:scratchBuffer:");
_MTL_PRIVATE_DEF_SEL(buildAccelerationStructure_descriptor_scratchBuffer_scratchBufferOffset_,
    "buildAccelerationStructure:descriptor:scratchBuffer:scratchBufferOffset:");
_MTL_PRIVATE_DEF_SEL(captureObject,
    "captureObject");
_MTL_PRIVATE_DEF_SEL(clearBarrier,
    "clearBarrier");
_MTL_PRIVATE_DEF_SEL(clearColor,
    "clearColor");
_MTL_PRIVATE_DEF_SEL(clearDepth,
    "clearDepth");
_MTL_PRIVATE_DEF_SEL(clearStencil,
    "clearStencil");
_MTL_PRIVATE_DEF_SEL(colorAttachmentMappingState,
    "colorAttachmentMappingState");
_MTL_PRIVATE_DEF_SEL(colorAttachments,
    "colorAttachments");
_MTL_PRIVATE_DEF_SEL(column,
    "column");
_MTL_PRIVATE_DEF_SEL(commandBuffer,
    "commandBuffer");
_MTL_PRIVATE_DEF_SEL(commandBufferWithDescriptor_,
    "commandBufferWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(commandBufferWithUnretainedReferences,
    "commandBufferWithUnretainedReferences");
_MTL_PRIVATE_DEF_SEL(commandQueue,
    "commandQueue");
_MTL_PRIVATE_DEF_SEL(commandTypes,
    "commandTypes");
_MTL_PRIVATE_DEF_SEL(commit,
    "commit");
_MTL_PRIVATE_DEF_SEL(commit_count_,
    "commit:count:");
_MTL_PRIVATE_DEF_SEL(commit_count_options_,
    "commit:count:options:");
_MTL_PRIVATE_DEF_SEL(compareFunction,
    "compareFunction");
_MTL_PRIVATE_DEF_SEL(compileSymbolVisibility,
    "compileSymbolVisibility");
_MTL_PRIVATE_DEF_SEL(compiler,
    "compiler");
_MTL_PRIVATE_DEF_SEL(compressionType,
    "compressionType");
_MTL_PRIVATE_DEF_SEL(computeCommandEncoder,
    "computeCommandEncoder");
_MTL_PRIVATE_DEF_SEL(computeCommandEncoderWithDescriptor_,
    "computeCommandEncoderWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(computeCommandEncoderWithDispatchType_,
    "computeCommandEncoderWithDispatchType:");
_MTL_PRIVATE_DEF_SEL(computeFunction,
    "computeFunction");
_MTL_PRIVATE_DEF_SEL(computeFunctionDescriptor,
    "computeFunctionDescriptor");
_MTL_PRIVATE_DEF_SEL(computePassDescriptor,
    "computePassDescriptor");
_MTL_PRIVATE_DEF_SEL(concurrentDispatchThreadgroups_threadsPerThreadgroup_,
    "concurrentDispatchThreadgroups:threadsPerThreadgroup:");
_MTL_PRIVATE_DEF_SEL(concurrentDispatchThreads_threadsPerThreadgroup_,
    "concurrentDispatchThreads:threadsPerThreadgroup:");
_MTL_PRIVATE_DEF_SEL(configuration,
    "configuration");
_MTL_PRIVATE_DEF_SEL(constantBlockAlignment,
    "constantBlockAlignment");
_MTL_PRIVATE_DEF_SEL(constantDataAtIndex_,
    "constantDataAtIndex:");
_MTL_PRIVATE_DEF_SEL(constantValues,
    "constantValues");
_MTL_PRIVATE_DEF_SEL(containsAllocation_,
    "containsAllocation:");
_MTL_PRIVATE_DEF_SEL(contents,
    "contents");
_MTL_PRIVATE_DEF_SEL(controlDependencies,
    "controlDependencies");
_MTL_PRIVATE_DEF_SEL(controlPointBuffer,
    "controlPointBuffer");
_MTL_PRIVATE_DEF_SEL(controlPointBufferOffset,
    "controlPointBufferOffset");
_MTL_PRIVATE_DEF_SEL(controlPointBuffers,
    "controlPointBuffers");
_MTL_PRIVATE_DEF_SEL(controlPointCount,
    "controlPointCount");
_MTL_PRIVATE_DEF_SEL(controlPointFormat,
    "controlPointFormat");
_MTL_PRIVATE_DEF_SEL(controlPointStride,
    "controlPointStride");
_MTL_PRIVATE_DEF_SEL(convertSparsePixelRegions_toTileRegions_withTileSize_alignmentMode_numRegions_,
    "convertSparsePixelRegions:toTileRegions:withTileSize:alignmentMode:numRegions:");
_MTL_PRIVATE_DEF_SEL(convertSparseTileRegions_toPixelRegions_withTileSize_numRegions_,
    "convertSparseTileRegions:toPixelRegions:withTileSize:numRegions:");
_MTL_PRIVATE_DEF_SEL(copyAccelerationStructure_toAccelerationStructure_,
    "copyAccelerationStructure:toAccelerationStructure:");
_MTL_PRIVATE_DEF_SEL(copyAndCompactAccelerationStructure_toAccelerationStructure_,
    "copyAndCompactAccelerationStructure:toAccelerationStructure:");
_MTL_PRIVATE_DEF_SEL(copyBufferMappingsFromBuffer_toBuffer_operations_count_,
    "copyBufferMappingsFromBuffer:toBuffer:operations:count:");
_MTL_PRIVATE_DEF_SEL(copyFromBuffer_sourceOffset_sourceBytesPerRow_sourceBytesPerImage_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin_,
    "copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:");
_MTL_PRIVATE_DEF_SEL(copyFromBuffer_sourceOffset_sourceBytesPerRow_sourceBytesPerImage_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin_options_,
    "copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:");
_MTL_PRIVATE_DEF_SEL(copyFromBuffer_sourceOffset_toBuffer_destinationOffset_size_,
    "copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:");
_MTL_PRIVATE_DEF_SEL(copyFromTensor_sourceOrigin_sourceDimensions_toTensor_destinationOrigin_destinationDimensions_,
    "copyFromTensor:sourceOrigin:sourceDimensions:toTensor:destinationOrigin:destinationDimensions:");
_MTL_PRIVATE_DEF_SEL(copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toBuffer_destinationOffset_destinationBytesPerRow_destinationBytesPerImage_,
    "copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:");
_MTL_PRIVATE_DEF_SEL(copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toBuffer_destinationOffset_destinationBytesPerRow_destinationBytesPerImage_options_,
    "copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:");
_MTL_PRIVATE_DEF_SEL(copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin_,
    "copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:");
_MTL_PRIVATE_DEF_SEL(copyFromTexture_sourceSlice_sourceLevel_toTexture_destinationSlice_destinationLevel_sliceCount_levelCount_,
    "copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount:");
_MTL_PRIVATE_DEF_SEL(copyFromTexture_toTexture_,
    "copyFromTexture:toTexture:");
_MTL_PRIVATE_DEF_SEL(copyIndirectCommandBuffer_sourceRange_destination_destinationIndex_,
    "copyIndirectCommandBuffer:sourceRange:destination:destinationIndex:");
_MTL_PRIVATE_DEF_SEL(copyParameterDataToBuffer_offset_,
    "copyParameterDataToBuffer:offset:");
_MTL_PRIVATE_DEF_SEL(copyResourceViewsFromPool_sourceRange_destinationIndex_,
    "copyResourceViewsFromPool:sourceRange:destinationIndex:");
_MTL_PRIVATE_DEF_SEL(copyStatusToBuffer_offset_,
    "copyStatusToBuffer:offset:");
_MTL_PRIVATE_DEF_SEL(copyTextureMappingsFromTexture_toTexture_operations_count_,
    "copyTextureMappingsFromTexture:toTexture:operations:count:");
_MTL_PRIVATE_DEF_SEL(count,
    "count");
_MTL_PRIVATE_DEF_SEL(counterSet,
    "counterSet");
_MTL_PRIVATE_DEF_SEL(counterSets,
    "counterSets");
_MTL_PRIVATE_DEF_SEL(counters,
    "counters");
_MTL_PRIVATE_DEF_SEL(cpuCacheMode,
    "cpuCacheMode");
_MTL_PRIVATE_DEF_SEL(currentAllocatedSize,
    "currentAllocatedSize");
_MTL_PRIVATE_DEF_SEL(curveBasis,
    "curveBasis");
_MTL_PRIVATE_DEF_SEL(curveEndCaps,
    "curveEndCaps");
_MTL_PRIVATE_DEF_SEL(curveType,
    "curveType");
_MTL_PRIVATE_DEF_SEL(data,
    "data");
_MTL_PRIVATE_DEF_SEL(dataSize,
    "dataSize");
_MTL_PRIVATE_DEF_SEL(dataType,
    "dataType");
_MTL_PRIVATE_DEF_SEL(dealloc,
    "dealloc");
_MTL_PRIVATE_DEF_SEL(debugLocation,
    "debugLocation");
_MTL_PRIVATE_DEF_SEL(debugSignposts,
    "debugSignposts");
_MTL_PRIVATE_DEF_SEL(defaultCaptureScope,
    "defaultCaptureScope");
_MTL_PRIVATE_DEF_SEL(defaultRasterSampleCount,
    "defaultRasterSampleCount");
_MTL_PRIVATE_DEF_SEL(depth,
    "depth");
_MTL_PRIVATE_DEF_SEL(depthAttachment,
    "depthAttachment");
_MTL_PRIVATE_DEF_SEL(depthAttachmentPixelFormat,
    "depthAttachmentPixelFormat");
_MTL_PRIVATE_DEF_SEL(depthCompareFunction,
    "depthCompareFunction");
_MTL_PRIVATE_DEF_SEL(depthFailureOperation,
    "depthFailureOperation");
_MTL_PRIVATE_DEF_SEL(depthPlane,
    "depthPlane");
_MTL_PRIVATE_DEF_SEL(depthResolveFilter,
    "depthResolveFilter");
_MTL_PRIVATE_DEF_SEL(depthStencilPassOperation,
    "depthStencilPassOperation");
_MTL_PRIVATE_DEF_SEL(descriptor,
    "descriptor");
_MTL_PRIVATE_DEF_SEL(destination,
    "destination");
_MTL_PRIVATE_DEF_SEL(destinationAlphaBlendFactor,
    "destinationAlphaBlendFactor");
_MTL_PRIVATE_DEF_SEL(destinationRGBBlendFactor,
    "destinationRGBBlendFactor");
_MTL_PRIVATE_DEF_SEL(device,
    "device");
_MTL_PRIVATE_DEF_SEL(didModifyRange_,
    "didModifyRange:");
_MTL_PRIVATE_DEF_SEL(dimensions,
    "dimensions");
_MTL_PRIVATE_DEF_SEL(dispatchNetworkWithIntermediatesHeap_,
    "dispatchNetworkWithIntermediatesHeap:");
_MTL_PRIVATE_DEF_SEL(dispatchQueue,
    "dispatchQueue");
_MTL_PRIVATE_DEF_SEL(dispatchThreadgroups_threadsPerThreadgroup_,
    "dispatchThreadgroups:threadsPerThreadgroup:");
_MTL_PRIVATE_DEF_SEL(dispatchThreadgroupsWithIndirectBuffer_indirectBufferOffset_threadsPerThreadgroup_,
    "dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup:");
_MTL_PRIVATE_DEF_SEL(dispatchThreadgroupsWithIndirectBuffer_threadsPerThreadgroup_,
    "dispatchThreadgroupsWithIndirectBuffer:threadsPerThreadgroup:");
_MTL_PRIVATE_DEF_SEL(dispatchThreads_threadsPerThreadgroup_,
    "dispatchThreads:threadsPerThreadgroup:");
_MTL_PRIVATE_DEF_SEL(dispatchThreadsPerTile_,
    "dispatchThreadsPerTile:");
_MTL_PRIVATE_DEF_SEL(dispatchThreadsWithIndirectBuffer_,
    "dispatchThreadsWithIndirectBuffer:");
_MTL_PRIVATE_DEF_SEL(dispatchType,
    "dispatchType");
_MTL_PRIVATE_DEF_SEL(drawIndexedPatches_patchIndexBuffer_patchIndexBufferOffset_controlPointIndexBuffer_controlPointIndexBufferOffset_indirectBuffer_indirectBufferOffset_,
    "drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset:");
_MTL_PRIVATE_DEF_SEL(drawIndexedPatches_patchStart_patchCount_patchIndexBuffer_patchIndexBufferOffset_controlPointIndexBuffer_controlPointIndexBufferOffset_instanceCount_baseInstance_,
    "drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:");
_MTL_PRIVATE_DEF_SEL(drawIndexedPatches_patchStart_patchCount_patchIndexBuffer_patchIndexBufferOffset_controlPointIndexBuffer_controlPointIndexBufferOffset_instanceCount_baseInstance_tessellationFactorBuffer_tessellationFactorBufferOffset_tessellationFactorBufferInstanceStride_,
    "drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:");
_MTL_PRIVATE_DEF_SEL(drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferLength_,
    "drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferLength:");
_MTL_PRIVATE_DEF_SEL(drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferLength_instanceCount_,
    "drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferLength:instanceCount:");
_MTL_PRIVATE_DEF_SEL(drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferLength_instanceCount_baseVertex_baseInstance_,
    "drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferLength:instanceCount:baseVertex:baseInstance:");
_MTL_PRIVATE_DEF_SEL(drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferOffset_,
    "drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:");
_MTL_PRIVATE_DEF_SEL(drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferOffset_instanceCount_,
    "drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:");
_MTL_PRIVATE_DEF_SEL(drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferOffset_instanceCount_baseVertex_baseInstance_,
    "drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:");
_MTL_PRIVATE_DEF_SEL(drawIndexedPrimitives_indexType_indexBuffer_indexBufferLength_indirectBuffer_,
    "drawIndexedPrimitives:indexType:indexBuffer:indexBufferLength:indirectBuffer:");
_MTL_PRIVATE_DEF_SEL(drawIndexedPrimitives_indexType_indexBuffer_indexBufferOffset_indirectBuffer_indirectBufferOffset_,
    "drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset:");
_MTL_PRIVATE_DEF_SEL(drawMeshThreadgroups_threadsPerObjectThreadgroup_threadsPerMeshThreadgroup_,
    "drawMeshThreadgroups:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:");
_MTL_PRIVATE_DEF_SEL(drawMeshThreadgroupsWithIndirectBuffer_indirectBufferOffset_threadsPerObjectThreadgroup_threadsPerMeshThreadgroup_,
    "drawMeshThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:");
_MTL_PRIVATE_DEF_SEL(drawMeshThreadgroupsWithIndirectBuffer_threadsPerObjectThreadgroup_threadsPerMeshThreadgroup_,
    "drawMeshThreadgroupsWithIndirectBuffer:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:");
_MTL_PRIVATE_DEF_SEL(drawMeshThreads_threadsPerObjectThreadgroup_threadsPerMeshThreadgroup_,
    "drawMeshThreads:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:");
_MTL_PRIVATE_DEF_SEL(drawPatches_patchIndexBuffer_patchIndexBufferOffset_indirectBuffer_indirectBufferOffset_,
    "drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset:");
_MTL_PRIVATE_DEF_SEL(drawPatches_patchStart_patchCount_patchIndexBuffer_patchIndexBufferOffset_instanceCount_baseInstance_,
    "drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:");
_MTL_PRIVATE_DEF_SEL(drawPatches_patchStart_patchCount_patchIndexBuffer_patchIndexBufferOffset_instanceCount_baseInstance_tessellationFactorBuffer_tessellationFactorBufferOffset_tessellationFactorBufferInstanceStride_,
    "drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:");
_MTL_PRIVATE_DEF_SEL(drawPrimitives_indirectBuffer_,
    "drawPrimitives:indirectBuffer:");
_MTL_PRIVATE_DEF_SEL(drawPrimitives_indirectBuffer_indirectBufferOffset_,
    "drawPrimitives:indirectBuffer:indirectBufferOffset:");
_MTL_PRIVATE_DEF_SEL(drawPrimitives_vertexStart_vertexCount_,
    "drawPrimitives:vertexStart:vertexCount:");
_MTL_PRIVATE_DEF_SEL(drawPrimitives_vertexStart_vertexCount_instanceCount_,
    "drawPrimitives:vertexStart:vertexCount:instanceCount:");
_MTL_PRIVATE_DEF_SEL(drawPrimitives_vertexStart_vertexCount_instanceCount_baseInstance_,
    "drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:");
_MTL_PRIVATE_DEF_SEL(drawableID,
    "drawableID");
_MTL_PRIVATE_DEF_SEL(elementArrayType,
    "elementArrayType");
_MTL_PRIVATE_DEF_SEL(elementIsArgumentBuffer,
    "elementIsArgumentBuffer");
_MTL_PRIVATE_DEF_SEL(elementPointerType,
    "elementPointerType");
_MTL_PRIVATE_DEF_SEL(elementStructType,
    "elementStructType");
_MTL_PRIVATE_DEF_SEL(elementTensorReferenceType,
    "elementTensorReferenceType");
_MTL_PRIVATE_DEF_SEL(elementTextureReferenceType,
    "elementTextureReferenceType");
_MTL_PRIVATE_DEF_SEL(elementType,
    "elementType");
_MTL_PRIVATE_DEF_SEL(enableLogging,
    "enableLogging");
_MTL_PRIVATE_DEF_SEL(encodeSignalEvent_value_,
    "encodeSignalEvent:value:");
_MTL_PRIVATE_DEF_SEL(encodeWaitForEvent_value_,
    "encodeWaitForEvent:value:");
_MTL_PRIVATE_DEF_SEL(encodedLength,
    "encodedLength");
_MTL_PRIVATE_DEF_SEL(encoderLabel,
    "encoderLabel");
_MTL_PRIVATE_DEF_SEL(endCommandBuffer,
    "endCommandBuffer");
_MTL_PRIVATE_DEF_SEL(endEncoding,
    "endEncoding");
_MTL_PRIVATE_DEF_SEL(endOfEncoderSampleIndex,
    "endOfEncoderSampleIndex");
_MTL_PRIVATE_DEF_SEL(endOfFragmentSampleIndex,
    "endOfFragmentSampleIndex");
_MTL_PRIVATE_DEF_SEL(endOfVertexSampleIndex,
    "endOfVertexSampleIndex");
_MTL_PRIVATE_DEF_SEL(endResidency,
    "endResidency");
_MTL_PRIVATE_DEF_SEL(enqueue,
    "enqueue");
_MTL_PRIVATE_DEF_SEL(enqueueBarrier,
    "enqueueBarrier");
_MTL_PRIVATE_DEF_SEL(error,
    "error");
_MTL_PRIVATE_DEF_SEL(errorOptions,
    "errorOptions");
_MTL_PRIVATE_DEF_SEL(errorState,
    "errorState");
_MTL_PRIVATE_DEF_SEL(executeCommandsInBuffer_indirectBuffer_,
    "executeCommandsInBuffer:indirectBuffer:");
_MTL_PRIVATE_DEF_SEL(executeCommandsInBuffer_indirectBuffer_indirectBufferOffset_,
    "executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:");
_MTL_PRIVATE_DEF_SEL(executeCommandsInBuffer_withRange_,
    "executeCommandsInBuffer:withRange:");
_MTL_PRIVATE_DEF_SEL(extentAtDimensionIndex_,
    "extentAtDimensionIndex:");
_MTL_PRIVATE_DEF_SEL(fastMathEnabled,
    "fastMathEnabled");
_MTL_PRIVATE_DEF_SEL(feedbackQueue,
    "feedbackQueue");
_MTL_PRIVATE_DEF_SEL(fillBuffer_range_value_,
    "fillBuffer:range:value:");
_MTL_PRIVATE_DEF_SEL(firstMipmapInTail,
    "firstMipmapInTail");
_MTL_PRIVATE_DEF_SEL(format,
    "format");
_MTL_PRIVATE_DEF_SEL(fragmentAdditionalBinaryFunctions,
    "fragmentAdditionalBinaryFunctions");
_MTL_PRIVATE_DEF_SEL(fragmentArguments,
    "fragmentArguments");
_MTL_PRIVATE_DEF_SEL(fragmentBindings,
    "fragmentBindings");
_MTL_PRIVATE_DEF_SEL(fragmentBuffers,
    "fragmentBuffers");
_MTL_PRIVATE_DEF_SEL(fragmentFunction,
    "fragmentFunction");
_MTL_PRIVATE_DEF_SEL(fragmentFunctionDescriptor,
    "fragmentFunctionDescriptor");
_MTL_PRIVATE_DEF_SEL(fragmentLinkedFunctions,
    "fragmentLinkedFunctions");
_MTL_PRIVATE_DEF_SEL(fragmentLinkingDescriptor,
    "fragmentLinkingDescriptor");
_MTL_PRIVATE_DEF_SEL(fragmentPreloadedLibraries,
    "fragmentPreloadedLibraries");
_MTL_PRIVATE_DEF_SEL(fragmentStaticLinkingDescriptor,
    "fragmentStaticLinkingDescriptor");
_MTL_PRIVATE_DEF_SEL(frontFaceStencil,
    "frontFaceStencil");
_MTL_PRIVATE_DEF_SEL(function,
    "function");
_MTL_PRIVATE_DEF_SEL(functionConstantsDictionary,
    "functionConstantsDictionary");
_MTL_PRIVATE_DEF_SEL(functionCount,
    "functionCount");
_MTL_PRIVATE_DEF_SEL(functionDescriptor,
    "functionDescriptor");
_MTL_PRIVATE_DEF_SEL(functionDescriptors,
    "functionDescriptors");
_MTL_PRIVATE_DEF_SEL(functionGraph,
    "functionGraph");
_MTL_PRIVATE_DEF_SEL(functionGraphs,
    "functionGraphs");
_MTL_PRIVATE_DEF_SEL(functionHandleWithBinaryFunction_,
    "functionHandleWithBinaryFunction:");
_MTL_PRIVATE_DEF_SEL(functionHandleWithBinaryFunction_stage_,
    "functionHandleWithBinaryFunction:stage:");
_MTL_PRIVATE_DEF_SEL(functionHandleWithFunction_,
    "functionHandleWithFunction:");
_MTL_PRIVATE_DEF_SEL(functionHandleWithFunction_stage_,
    "functionHandleWithFunction:stage:");
_MTL_PRIVATE_DEF_SEL(functionHandleWithName_,
    "functionHandleWithName:");
_MTL_PRIVATE_DEF_SEL(functionHandleWithName_stage_,
    "functionHandleWithName:stage:");
_MTL_PRIVATE_DEF_SEL(functionName,
    "functionName");
_MTL_PRIVATE_DEF_SEL(functionNames,
    "functionNames");
_MTL_PRIVATE_DEF_SEL(functionType,
    "functionType");
_MTL_PRIVATE_DEF_SEL(functions,
    "functions");
_MTL_PRIVATE_DEF_SEL(generateMipmapsForTexture_,
    "generateMipmapsForTexture:");
_MTL_PRIVATE_DEF_SEL(geometryDescriptors,
    "geometryDescriptors");
_MTL_PRIVATE_DEF_SEL(getBytes_bytesPerRow_bytesPerImage_fromRegion_mipmapLevel_slice_,
    "getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:");
_MTL_PRIVATE_DEF_SEL(getBytes_bytesPerRow_fromRegion_mipmapLevel_,
    "getBytes:bytesPerRow:fromRegion:mipmapLevel:");
_MTL_PRIVATE_DEF_SEL(getBytes_strides_fromSliceOrigin_sliceDimensions_,
    "getBytes:strides:fromSliceOrigin:sliceDimensions:");
_MTL_PRIVATE_DEF_SEL(getDefaultSamplePositions_count_,
    "getDefaultSamplePositions:count:");
_MTL_PRIVATE_DEF_SEL(getPhysicalIndexForLogicalIndex_,
    "getPhysicalIndexForLogicalIndex:");
_MTL_PRIVATE_DEF_SEL(getSamplePositions_count_,
    "getSamplePositions:count:");
_MTL_PRIVATE_DEF_SEL(getTextureAccessCounters_region_mipLevel_slice_resetCounters_countersBuffer_countersBufferOffset_,
    "getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset:");
_MTL_PRIVATE_DEF_SEL(gpuAddress,
    "gpuAddress");
_MTL_PRIVATE_DEF_SEL(gpuResourceID,
    "gpuResourceID");
_MTL_PRIVATE_DEF_SEL(groups,
    "groups");
_MTL_PRIVATE_DEF_SEL(hasUnifiedMemory,
    "hasUnifiedMemory");
_MTL_PRIVATE_DEF_SEL(hazardTrackingMode,
    "hazardTrackingMode");
_MTL_PRIVATE_DEF_SEL(heap,
    "heap");
_MTL_PRIVATE_DEF_SEL(heapAccelerationStructureSizeAndAlignWithDescriptor_,
    "heapAccelerationStructureSizeAndAlignWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(heapAccelerationStructureSizeAndAlignWithSize_,
    "heapAccelerationStructureSizeAndAlignWithSize:");
_MTL_PRIVATE_DEF_SEL(heapBufferSizeAndAlignWithLength_options_,
    "heapBufferSizeAndAlignWithLength:options:");
_MTL_PRIVATE_DEF_SEL(heapOffset,
    "heapOffset");
_MTL_PRIVATE_DEF_SEL(heapTextureSizeAndAlignWithDescriptor_,
    "heapTextureSizeAndAlignWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(height,
    "height");
_MTL_PRIVATE_DEF_SEL(horizontal,
    "horizontal");
_MTL_PRIVATE_DEF_SEL(horizontalSampleStorage,
    "horizontalSampleStorage");
_MTL_PRIVATE_DEF_SEL(imageblockMemoryLengthForDimensions_,
    "imageblockMemoryLengthForDimensions:");
_MTL_PRIVATE_DEF_SEL(imageblockSampleLength,
    "imageblockSampleLength");
_MTL_PRIVATE_DEF_SEL(index,
    "index");
_MTL_PRIVATE_DEF_SEL(indexBuffer,
    "indexBuffer");
_MTL_PRIVATE_DEF_SEL(indexBufferIndex,
    "indexBufferIndex");
_MTL_PRIVATE_DEF_SEL(indexBufferOffset,
    "indexBufferOffset");
_MTL_PRIVATE_DEF_SEL(indexType,
    "indexType");
_MTL_PRIVATE_DEF_SEL(indirectComputeCommandAtIndex_,
    "indirectComputeCommandAtIndex:");
_MTL_PRIVATE_DEF_SEL(indirectRenderCommandAtIndex_,
    "indirectRenderCommandAtIndex:");
_MTL_PRIVATE_DEF_SEL(inheritBuffers,
    "inheritBuffers");
_MTL_PRIVATE_DEF_SEL(inheritCullMode,
    "inheritCullMode");
_MTL_PRIVATE_DEF_SEL(inheritDepthBias,
    "inheritDepthBias");
_MTL_PRIVATE_DEF_SEL(inheritDepthClipMode,
    "inheritDepthClipMode");
_MTL_PRIVATE_DEF_SEL(inheritDepthStencilState,
    "inheritDepthStencilState");
_MTL_PRIVATE_DEF_SEL(inheritFrontFacingWinding,
    "inheritFrontFacingWinding");
_MTL_PRIVATE_DEF_SEL(inheritPipelineState,
    "inheritPipelineState");
_MTL_PRIVATE_DEF_SEL(inheritTriangleFillMode,
    "inheritTriangleFillMode");
_MTL_PRIVATE_DEF_SEL(init,
    "init");
_MTL_PRIVATE_DEF_SEL(initWithArgumentIndex_,
    "initWithArgumentIndex:");
_MTL_PRIVATE_DEF_SEL(initWithDispatchQueue_,
    "initWithDispatchQueue:");
_MTL_PRIVATE_DEF_SEL(initWithFunctionName_nodes_outputNode_attributes_,
    "initWithFunctionName:nodes:outputNode:attributes:");
_MTL_PRIVATE_DEF_SEL(initWithName_arguments_controlDependencies_,
    "initWithName:arguments:controlDependencies:");
_MTL_PRIVATE_DEF_SEL(initWithRank_values_,
    "initWithRank:values:");
_MTL_PRIVATE_DEF_SEL(initWithSampleCount_,
    "initWithSampleCount:");
_MTL_PRIVATE_DEF_SEL(initWithSampleCount_horizontal_vertical_,
    "initWithSampleCount:horizontal:vertical:");
_MTL_PRIVATE_DEF_SEL(initialCapacity,
    "initialCapacity");
_MTL_PRIVATE_DEF_SEL(initializeBindings,
    "initializeBindings");
_MTL_PRIVATE_DEF_SEL(inputDimensionsAtBufferIndex_,
    "inputDimensionsAtBufferIndex:");
_MTL_PRIVATE_DEF_SEL(inputPrimitiveTopology,
    "inputPrimitiveTopology");
_MTL_PRIVATE_DEF_SEL(insertDebugCaptureBoundary,
    "insertDebugCaptureBoundary");
_MTL_PRIVATE_DEF_SEL(insertDebugSignpost_,
    "insertDebugSignpost:");
_MTL_PRIVATE_DEF_SEL(insertLibraries,
    "insertLibraries");
_MTL_PRIVATE_DEF_SEL(installName,
    "installName");
_MTL_PRIVATE_DEF_SEL(instanceCount,
    "instanceCount");
_MTL_PRIVATE_DEF_SEL(instanceCountBuffer,
    "instanceCountBuffer");
_MTL_PRIVATE_DEF_SEL(instanceCountBufferOffset,
    "instanceCountBufferOffset");
_MTL_PRIVATE_DEF_SEL(instanceDescriptorBuffer,
    "instanceDescriptorBuffer");
_MTL_PRIVATE_DEF_SEL(instanceDescriptorBufferOffset,
    "instanceDescriptorBufferOffset");
_MTL_PRIVATE_DEF_SEL(instanceDescriptorStride,
    "instanceDescriptorStride");
_MTL_PRIVATE_DEF_SEL(instanceDescriptorType,
    "instanceDescriptorType");
_MTL_PRIVATE_DEF_SEL(instanceTransformationMatrixLayout,
    "instanceTransformationMatrixLayout");
_MTL_PRIVATE_DEF_SEL(instancedAccelerationStructures,
    "instancedAccelerationStructures");
_MTL_PRIVATE_DEF_SEL(intermediatesHeapSize,
    "intermediatesHeapSize");
_MTL_PRIVATE_DEF_SEL(intersectionFunctionTableDescriptor,
    "intersectionFunctionTableDescriptor");
_MTL_PRIVATE_DEF_SEL(intersectionFunctionTableOffset,
    "intersectionFunctionTableOffset");
_MTL_PRIVATE_DEF_SEL(invalidateCounterRange_,
    "invalidateCounterRange:");
_MTL_PRIVATE_DEF_SEL(iosurface,
    "iosurface");
_MTL_PRIVATE_DEF_SEL(iosurfacePlane,
    "iosurfacePlane");
_MTL_PRIVATE_DEF_SEL(isActive,
    "isActive");
_MTL_PRIVATE_DEF_SEL(isAliasable,
    "isAliasable");
_MTL_PRIVATE_DEF_SEL(isAlphaToCoverageEnabled,
    "isAlphaToCoverageEnabled");
_MTL_PRIVATE_DEF_SEL(isAlphaToOneEnabled,
    "isAlphaToOneEnabled");
_MTL_PRIVATE_DEF_SEL(isArgument,
    "isArgument");
_MTL_PRIVATE_DEF_SEL(isBlendingEnabled,
    "isBlendingEnabled");
_MTL_PRIVATE_DEF_SEL(isCapturing,
    "isCapturing");
_MTL_PRIVATE_DEF_SEL(isDepth24Stencil8PixelFormatSupported,
    "isDepth24Stencil8PixelFormatSupported");
_MTL_PRIVATE_DEF_SEL(isDepthTexture,
    "isDepthTexture");
_MTL_PRIVATE_DEF_SEL(isDepthWriteEnabled,
    "isDepthWriteEnabled");
_MTL_PRIVATE_DEF_SEL(isFramebufferOnly,
    "isFramebufferOnly");
_MTL_PRIVATE_DEF_SEL(isHeadless,
    "isHeadless");
_MTL_PRIVATE_DEF_SEL(isLowPower,
    "isLowPower");
_MTL_PRIVATE_DEF_SEL(isPatchControlPointData,
    "isPatchControlPointData");
_MTL_PRIVATE_DEF_SEL(isPatchData,
    "isPatchData");
_MTL_PRIVATE_DEF_SEL(isRasterizationEnabled,
    "isRasterizationEnabled");
_MTL_PRIVATE_DEF_SEL(isRemovable,
    "isRemovable");
_MTL_PRIVATE_DEF_SEL(isShareable,
    "isShareable");
_MTL_PRIVATE_DEF_SEL(isSparse,
    "isSparse");
_MTL_PRIVATE_DEF_SEL(isTessellationFactorScaleEnabled,
    "isTessellationFactorScaleEnabled");
_MTL_PRIVATE_DEF_SEL(isUsed,
    "isUsed");
_MTL_PRIVATE_DEF_SEL(kernelEndTime,
    "kernelEndTime");
_MTL_PRIVATE_DEF_SEL(kernelStartTime,
    "kernelStartTime");
_MTL_PRIVATE_DEF_SEL(label,
    "label");
_MTL_PRIVATE_DEF_SEL(languageVersion,
    "languageVersion");
_MTL_PRIVATE_DEF_SEL(layerAtIndex_,
    "layerAtIndex:");
_MTL_PRIVATE_DEF_SEL(layerCount,
    "layerCount");
_MTL_PRIVATE_DEF_SEL(layers,
    "layers");
_MTL_PRIVATE_DEF_SEL(layouts,
    "layouts");
_MTL_PRIVATE_DEF_SEL(length,
    "length");
_MTL_PRIVATE_DEF_SEL(level,
    "level");
_MTL_PRIVATE_DEF_SEL(levelRange,
    "levelRange");
_MTL_PRIVATE_DEF_SEL(libraries,
    "libraries");
_MTL_PRIVATE_DEF_SEL(library,
    "library");
_MTL_PRIVATE_DEF_SEL(libraryType,
    "libraryType");
_MTL_PRIVATE_DEF_SEL(line,
    "line");
_MTL_PRIVATE_DEF_SEL(linkedFunctions,
    "linkedFunctions");
_MTL_PRIVATE_DEF_SEL(loadAction,
    "loadAction");
_MTL_PRIVATE_DEF_SEL(loadBuffer_offset_size_sourceHandle_sourceHandleOffset_,
    "loadBuffer:offset:size:sourceHandle:sourceHandleOffset:");
_MTL_PRIVATE_DEF_SEL(loadBytes_size_sourceHandle_sourceHandleOffset_,
    "loadBytes:size:sourceHandle:sourceHandleOffset:");
_MTL_PRIVATE_DEF_SEL(loadTexture_slice_level_size_sourceBytesPerRow_sourceBytesPerImage_destinationOrigin_sourceHandle_sourceHandleOffset_,
    "loadTexture:slice:level:size:sourceBytesPerRow:sourceBytesPerImage:destinationOrigin:sourceHandle:sourceHandleOffset:");
_MTL_PRIVATE_DEF_SEL(location,
    "location");
_MTL_PRIVATE_DEF_SEL(locationNumber,
    "locationNumber");
_MTL_PRIVATE_DEF_SEL(lodAverage,
    "lodAverage");
_MTL_PRIVATE_DEF_SEL(lodBias,
    "lodBias");
_MTL_PRIVATE_DEF_SEL(lodMaxClamp,
    "lodMaxClamp");
_MTL_PRIVATE_DEF_SEL(lodMinClamp,
    "lodMinClamp");
_MTL_PRIVATE_DEF_SEL(logState,
    "logState");
_MTL_PRIVATE_DEF_SEL(logs,
    "logs");
_MTL_PRIVATE_DEF_SEL(lookupArchives,
    "lookupArchives");
_MTL_PRIVATE_DEF_SEL(machineLearningCommandEncoder,
    "machineLearningCommandEncoder");
_MTL_PRIVATE_DEF_SEL(machineLearningFunctionDescriptor,
    "machineLearningFunctionDescriptor");
_MTL_PRIVATE_DEF_SEL(magFilter,
    "magFilter");
_MTL_PRIVATE_DEF_SEL(makeAliasable,
    "makeAliasable");
_MTL_PRIVATE_DEF_SEL(mapPhysicalToScreenCoordinates_forLayer_,
    "mapPhysicalToScreenCoordinates:forLayer:");
_MTL_PRIVATE_DEF_SEL(mapScreenToPhysicalCoordinates_forLayer_,
    "mapScreenToPhysicalCoordinates:forLayer:");
_MTL_PRIVATE_DEF_SEL(mathFloatingPointFunctions,
    "mathFloatingPointFunctions");
_MTL_PRIVATE_DEF_SEL(mathMode,
    "mathMode");
_MTL_PRIVATE_DEF_SEL(maxAnisotropy,
    "maxAnisotropy");
_MTL_PRIVATE_DEF_SEL(maxArgumentBufferSamplerCount,
    "maxArgumentBufferSamplerCount");
_MTL_PRIVATE_DEF_SEL(maxAvailableSizeWithAlignment_,
    "maxAvailableSizeWithAlignment:");
_MTL_PRIVATE_DEF_SEL(maxBufferBindCount,
    "maxBufferBindCount");
_MTL_PRIVATE_DEF_SEL(maxBufferLength,
    "maxBufferLength");
_MTL_PRIVATE_DEF_SEL(maxCallStackDepth,
    "maxCallStackDepth");
_MTL_PRIVATE_DEF_SEL(maxCommandBufferCount,
    "maxCommandBufferCount");
_MTL_PRIVATE_DEF_SEL(maxCommandsInFlight,
    "maxCommandsInFlight");
_MTL_PRIVATE_DEF_SEL(maxCompatiblePlacementSparsePageSize,
    "maxCompatiblePlacementSparsePageSize");
_MTL_PRIVATE_DEF_SEL(maxFragmentBufferBindCount,
    "maxFragmentBufferBindCount");
_MTL_PRIVATE_DEF_SEL(maxFragmentCallStackDepth,
    "maxFragmentCallStackDepth");
_MTL_PRIVATE_DEF_SEL(maxInstanceCount,
    "maxInstanceCount");
_MTL_PRIVATE_DEF_SEL(maxKernelBufferBindCount,
    "maxKernelBufferBindCount");
_MTL_PRIVATE_DEF_SEL(maxKernelThreadgroupMemoryBindCount,
    "maxKernelThreadgroupMemoryBindCount");
_MTL_PRIVATE_DEF_SEL(maxMeshBufferBindCount,
    "maxMeshBufferBindCount");
_MTL_PRIVATE_DEF_SEL(maxMotionTransformCount,
    "maxMotionTransformCount");
_MTL_PRIVATE_DEF_SEL(maxObjectBufferBindCount,
    "maxObjectBufferBindCount");
_MTL_PRIVATE_DEF_SEL(maxObjectThreadgroupMemoryBindCount,
    "maxObjectThreadgroupMemoryBindCount");
_MTL_PRIVATE_DEF_SEL(maxSampleCount,
    "maxSampleCount");
_MTL_PRIVATE_DEF_SEL(maxSamplerStateBindCount,
    "maxSamplerStateBindCount");
_MTL_PRIVATE_DEF_SEL(maxTessellationFactor,
    "maxTessellationFactor");
_MTL_PRIVATE_DEF_SEL(maxTextureBindCount,
    "maxTextureBindCount");
_MTL_PRIVATE_DEF_SEL(maxThreadgroupMemoryLength,
    "maxThreadgroupMemoryLength");
_MTL_PRIVATE_DEF_SEL(maxThreadsPerThreadgroup,
    "maxThreadsPerThreadgroup");
_MTL_PRIVATE_DEF_SEL(maxTotalThreadgroupsPerMeshGrid,
    "maxTotalThreadgroupsPerMeshGrid");
_MTL_PRIVATE_DEF_SEL(maxTotalThreadsPerMeshThreadgroup,
    "maxTotalThreadsPerMeshThreadgroup");
_MTL_PRIVATE_DEF_SEL(maxTotalThreadsPerObjectThreadgroup,
    "maxTotalThreadsPerObjectThreadgroup");
_MTL_PRIVATE_DEF_SEL(maxTotalThreadsPerThreadgroup,
    "maxTotalThreadsPerThreadgroup");
_MTL_PRIVATE_DEF_SEL(maxTransferRate,
    "maxTransferRate");
_MTL_PRIVATE_DEF_SEL(maxVertexAmplificationCount,
    "maxVertexAmplificationCount");
_MTL_PRIVATE_DEF_SEL(maxVertexBufferBindCount,
    "maxVertexBufferBindCount");
_MTL_PRIVATE_DEF_SEL(maxVertexCallStackDepth,
    "maxVertexCallStackDepth");
_MTL_PRIVATE_DEF_SEL(maximumConcurrentCompilationTaskCount,
    "maximumConcurrentCompilationTaskCount");
_MTL_PRIVATE_DEF_SEL(memberByName_,
    "memberByName:");
_MTL_PRIVATE_DEF_SEL(members,
    "members");
_MTL_PRIVATE_DEF_SEL(memoryBarrierWithResources_count_,
    "memoryBarrierWithResources:count:");
_MTL_PRIVATE_DEF_SEL(memoryBarrierWithResources_count_afterStages_beforeStages_,
    "memoryBarrierWithResources:count:afterStages:beforeStages:");
_MTL_PRIVATE_DEF_SEL(memoryBarrierWithScope_,
    "memoryBarrierWithScope:");
_MTL_PRIVATE_DEF_SEL(memoryBarrierWithScope_afterStages_beforeStages_,
    "memoryBarrierWithScope:afterStages:beforeStages:");
_MTL_PRIVATE_DEF_SEL(meshAdditionalBinaryFunctions,
    "meshAdditionalBinaryFunctions");
_MTL_PRIVATE_DEF_SEL(meshBindings,
    "meshBindings");
_MTL_PRIVATE_DEF_SEL(meshBuffers,
    "meshBuffers");
_MTL_PRIVATE_DEF_SEL(meshFunction,
    "meshFunction");
_MTL_PRIVATE_DEF_SEL(meshFunctionDescriptor,
    "meshFunctionDescriptor");
_MTL_PRIVATE_DEF_SEL(meshLinkedFunctions,
    "meshLinkedFunctions");
_MTL_PRIVATE_DEF_SEL(meshLinkingDescriptor,
    "meshLinkingDescriptor");
_MTL_PRIVATE_DEF_SEL(meshStaticLinkingDescriptor,
    "meshStaticLinkingDescriptor");
_MTL_PRIVATE_DEF_SEL(meshThreadExecutionWidth,
    "meshThreadExecutionWidth");
_MTL_PRIVATE_DEF_SEL(meshThreadgroupSizeIsMultipleOfThreadExecutionWidth,
    "meshThreadgroupSizeIsMultipleOfThreadExecutionWidth");
_MTL_PRIVATE_DEF_SEL(minFilter,
    "minFilter");
_MTL_PRIVATE_DEF_SEL(minimumLinearTextureAlignmentForPixelFormat_,
    "minimumLinearTextureAlignmentForPixelFormat:");
_MTL_PRIVATE_DEF_SEL(minimumTextureBufferAlignmentForPixelFormat_,
    "minimumTextureBufferAlignmentForPixelFormat:");
_MTL_PRIVATE_DEF_SEL(mipFilter,
    "mipFilter");
_MTL_PRIVATE_DEF_SEL(mipmapLevelCount,
    "mipmapLevelCount");
_MTL_PRIVATE_DEF_SEL(motionEndBorderMode,
    "motionEndBorderMode");
_MTL_PRIVATE_DEF_SEL(motionEndTime,
    "motionEndTime");
_MTL_PRIVATE_DEF_SEL(motionKeyframeCount,
    "motionKeyframeCount");
_MTL_PRIVATE_DEF_SEL(motionStartBorderMode,
    "motionStartBorderMode");
_MTL_PRIVATE_DEF_SEL(motionStartTime,
    "motionStartTime");
_MTL_PRIVATE_DEF_SEL(motionTransformBuffer,
    "motionTransformBuffer");
_MTL_PRIVATE_DEF_SEL(motionTransformBufferOffset,
    "motionTransformBufferOffset");
_MTL_PRIVATE_DEF_SEL(motionTransformCount,
    "motionTransformCount");
_MTL_PRIVATE_DEF_SEL(motionTransformCountBuffer,
    "motionTransformCountBuffer");
_MTL_PRIVATE_DEF_SEL(motionTransformCountBufferOffset,
    "motionTransformCountBufferOffset");
_MTL_PRIVATE_DEF_SEL(motionTransformStride,
    "motionTransformStride");
_MTL_PRIVATE_DEF_SEL(motionTransformType,
    "motionTransformType");
_MTL_PRIVATE_DEF_SEL(moveTextureMappingsFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin_,
    "moveTextureMappingsFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:");
_MTL_PRIVATE_DEF_SEL(mutability,
    "mutability");
_MTL_PRIVATE_DEF_SEL(name,
    "name");
_MTL_PRIVATE_DEF_SEL(newAccelerationStructureWithDescriptor_,
    "newAccelerationStructureWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(newAccelerationStructureWithDescriptor_offset_,
    "newAccelerationStructureWithDescriptor:offset:");
_MTL_PRIVATE_DEF_SEL(newAccelerationStructureWithSize_,
    "newAccelerationStructureWithSize:");
_MTL_PRIVATE_DEF_SEL(newAccelerationStructureWithSize_offset_,
    "newAccelerationStructureWithSize:offset:");
_MTL_PRIVATE_DEF_SEL(newArchiveWithURL_error_,
    "newArchiveWithURL:error:");
_MTL_PRIVATE_DEF_SEL(newArgumentEncoderForBufferAtIndex_,
    "newArgumentEncoderForBufferAtIndex:");
_MTL_PRIVATE_DEF_SEL(newArgumentEncoderWithArguments_,
    "newArgumentEncoderWithArguments:");
_MTL_PRIVATE_DEF_SEL(newArgumentEncoderWithBufferBinding_,
    "newArgumentEncoderWithBufferBinding:");
_MTL_PRIVATE_DEF_SEL(newArgumentEncoderWithBufferIndex_,
    "newArgumentEncoderWithBufferIndex:");
_MTL_PRIVATE_DEF_SEL(newArgumentEncoderWithBufferIndex_reflection_,
    "newArgumentEncoderWithBufferIndex:reflection:");
_MTL_PRIVATE_DEF_SEL(newArgumentTableWithDescriptor_error_,
    "newArgumentTableWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newBinaryArchiveWithDescriptor_error_,
    "newBinaryArchiveWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newBinaryFunctionWithDescriptor_compilerTaskOptions_completionHandler_,
    "newBinaryFunctionWithDescriptor:compilerTaskOptions:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newBinaryFunctionWithDescriptor_compilerTaskOptions_error_,
    "newBinaryFunctionWithDescriptor:compilerTaskOptions:error:");
_MTL_PRIVATE_DEF_SEL(newBinaryFunctionWithDescriptor_error_,
    "newBinaryFunctionWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newBufferWithBytes_length_options_,
    "newBufferWithBytes:length:options:");
_MTL_PRIVATE_DEF_SEL(newBufferWithBytesNoCopy_length_options_deallocator_,
    "newBufferWithBytesNoCopy:length:options:deallocator:");
_MTL_PRIVATE_DEF_SEL(newBufferWithLength_options_,
    "newBufferWithLength:options:");
_MTL_PRIVATE_DEF_SEL(newBufferWithLength_options_offset_,
    "newBufferWithLength:options:offset:");
_MTL_PRIVATE_DEF_SEL(newBufferWithLength_options_placementSparsePageSize_,
    "newBufferWithLength:options:placementSparsePageSize:");
_MTL_PRIVATE_DEF_SEL(newCaptureScopeWithCommandQueue_,
    "newCaptureScopeWithCommandQueue:");
_MTL_PRIVATE_DEF_SEL(newCaptureScopeWithDevice_,
    "newCaptureScopeWithDevice:");
_MTL_PRIVATE_DEF_SEL(newCaptureScopeWithMTL4CommandQueue_,
    "newCaptureScopeWithMTL4CommandQueue:");
_MTL_PRIVATE_DEF_SEL(newCommandAllocator,
    "newCommandAllocator");
_MTL_PRIVATE_DEF_SEL(newCommandAllocatorWithDescriptor_error_,
    "newCommandAllocatorWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newCommandBuffer,
    "newCommandBuffer");
_MTL_PRIVATE_DEF_SEL(newCommandQueue,
    "newCommandQueue");
_MTL_PRIVATE_DEF_SEL(newCommandQueueWithDescriptor_,
    "newCommandQueueWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(newCommandQueueWithMaxCommandBufferCount_,
    "newCommandQueueWithMaxCommandBufferCount:");
_MTL_PRIVATE_DEF_SEL(newCompilerWithDescriptor_error_,
    "newCompilerWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newComputePipelineStateWithAdditionalBinaryFunctions_error_,
    "newComputePipelineStateWithAdditionalBinaryFunctions:error:");
_MTL_PRIVATE_DEF_SEL(newComputePipelineStateWithBinaryFunctions_error_,
    "newComputePipelineStateWithBinaryFunctions:error:");
_MTL_PRIVATE_DEF_SEL(newComputePipelineStateWithDescriptor_compilerTaskOptions_completionHandler_,
    "newComputePipelineStateWithDescriptor:compilerTaskOptions:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newComputePipelineStateWithDescriptor_compilerTaskOptions_error_,
    "newComputePipelineStateWithDescriptor:compilerTaskOptions:error:");
_MTL_PRIVATE_DEF_SEL(newComputePipelineStateWithDescriptor_dynamicLinkingDescriptor_compilerTaskOptions_completionHandler_,
    "newComputePipelineStateWithDescriptor:dynamicLinkingDescriptor:compilerTaskOptions:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newComputePipelineStateWithDescriptor_dynamicLinkingDescriptor_compilerTaskOptions_error_,
    "newComputePipelineStateWithDescriptor:dynamicLinkingDescriptor:compilerTaskOptions:error:");
_MTL_PRIVATE_DEF_SEL(newComputePipelineStateWithDescriptor_dynamicLinkingDescriptor_error_,
    "newComputePipelineStateWithDescriptor:dynamicLinkingDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newComputePipelineStateWithDescriptor_error_,
    "newComputePipelineStateWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newComputePipelineStateWithDescriptor_options_completionHandler_,
    "newComputePipelineStateWithDescriptor:options:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newComputePipelineStateWithDescriptor_options_reflection_error_,
    "newComputePipelineStateWithDescriptor:options:reflection:error:");
_MTL_PRIVATE_DEF_SEL(newComputePipelineStateWithFunction_completionHandler_,
    "newComputePipelineStateWithFunction:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newComputePipelineStateWithFunction_error_,
    "newComputePipelineStateWithFunction:error:");
_MTL_PRIVATE_DEF_SEL(newComputePipelineStateWithFunction_options_completionHandler_,
    "newComputePipelineStateWithFunction:options:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newComputePipelineStateWithFunction_options_reflection_error_,
    "newComputePipelineStateWithFunction:options:reflection:error:");
_MTL_PRIVATE_DEF_SEL(newCounterHeapWithDescriptor_error_,
    "newCounterHeapWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newCounterSampleBufferWithDescriptor_error_,
    "newCounterSampleBufferWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newDefaultLibrary,
    "newDefaultLibrary");
_MTL_PRIVATE_DEF_SEL(newDefaultLibraryWithBundle_error_,
    "newDefaultLibraryWithBundle:error:");
_MTL_PRIVATE_DEF_SEL(newDepthStencilStateWithDescriptor_,
    "newDepthStencilStateWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(newDynamicLibrary_completionHandler_,
    "newDynamicLibrary:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newDynamicLibrary_error_,
    "newDynamicLibrary:error:");
_MTL_PRIVATE_DEF_SEL(newDynamicLibraryWithURL_completionHandler_,
    "newDynamicLibraryWithURL:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newDynamicLibraryWithURL_error_,
    "newDynamicLibraryWithURL:error:");
_MTL_PRIVATE_DEF_SEL(newEvent,
    "newEvent");
_MTL_PRIVATE_DEF_SEL(newFence,
    "newFence");
_MTL_PRIVATE_DEF_SEL(newFunctionWithDescriptor_completionHandler_,
    "newFunctionWithDescriptor:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newFunctionWithDescriptor_error_,
    "newFunctionWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newFunctionWithName_,
    "newFunctionWithName:");
_MTL_PRIVATE_DEF_SEL(newFunctionWithName_constantValues_completionHandler_,
    "newFunctionWithName:constantValues:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newFunctionWithName_constantValues_error_,
    "newFunctionWithName:constantValues:error:");
_MTL_PRIVATE_DEF_SEL(newHeapWithDescriptor_,
    "newHeapWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(newIOCommandQueueWithDescriptor_error_,
    "newIOCommandQueueWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newIOFileHandleWithURL_compressionMethod_error_,
    "newIOFileHandleWithURL:compressionMethod:error:");
_MTL_PRIVATE_DEF_SEL(newIOFileHandleWithURL_error_,
    "newIOFileHandleWithURL:error:");
_MTL_PRIVATE_DEF_SEL(newIOHandleWithURL_compressionMethod_error_,
    "newIOHandleWithURL:compressionMethod:error:");
_MTL_PRIVATE_DEF_SEL(newIOHandleWithURL_error_,
    "newIOHandleWithURL:error:");
_MTL_PRIVATE_DEF_SEL(newIndirectCommandBufferWithDescriptor_maxCommandCount_options_,
    "newIndirectCommandBufferWithDescriptor:maxCommandCount:options:");
_MTL_PRIVATE_DEF_SEL(newIntersectionFunctionTableWithDescriptor_,
    "newIntersectionFunctionTableWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(newIntersectionFunctionTableWithDescriptor_stage_,
    "newIntersectionFunctionTableWithDescriptor:stage:");
_MTL_PRIVATE_DEF_SEL(newIntersectionFunctionWithDescriptor_completionHandler_,
    "newIntersectionFunctionWithDescriptor:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newIntersectionFunctionWithDescriptor_error_,
    "newIntersectionFunctionWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newLibraryWithData_error_,
    "newLibraryWithData:error:");
_MTL_PRIVATE_DEF_SEL(newLibraryWithDescriptor_completionHandler_,
    "newLibraryWithDescriptor:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newLibraryWithDescriptor_error_,
    "newLibraryWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newLibraryWithFile_error_,
    "newLibraryWithFile:error:");
_MTL_PRIVATE_DEF_SEL(newLibraryWithSource_options_completionHandler_,
    "newLibraryWithSource:options:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newLibraryWithSource_options_error_,
    "newLibraryWithSource:options:error:");
_MTL_PRIVATE_DEF_SEL(newLibraryWithStitchedDescriptor_completionHandler_,
    "newLibraryWithStitchedDescriptor:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newLibraryWithStitchedDescriptor_error_,
    "newLibraryWithStitchedDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newLibraryWithURL_error_,
    "newLibraryWithURL:error:");
_MTL_PRIVATE_DEF_SEL(newLogStateWithDescriptor_error_,
    "newLogStateWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newMTL4CommandQueue,
    "newMTL4CommandQueue");
_MTL_PRIVATE_DEF_SEL(newMTL4CommandQueueWithDescriptor_error_,
    "newMTL4CommandQueueWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newMachineLearningPipelineStateWithDescriptor_completionHandler_,
    "newMachineLearningPipelineStateWithDescriptor:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newMachineLearningPipelineStateWithDescriptor_error_,
    "newMachineLearningPipelineStateWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newPipelineDataSetSerializerWithDescriptor_,
    "newPipelineDataSetSerializerWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(newRasterizationRateMapWithDescriptor_,
    "newRasterizationRateMapWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(newRemoteBufferViewForDevice_,
    "newRemoteBufferViewForDevice:");
_MTL_PRIVATE_DEF_SEL(newRemoteTextureViewForDevice_,
    "newRemoteTextureViewForDevice:");
_MTL_PRIVATE_DEF_SEL(newRenderPipelineDescriptorForSpecialization,
    "newRenderPipelineDescriptorForSpecialization");
_MTL_PRIVATE_DEF_SEL(newRenderPipelineStateBySpecializationWithDescriptor_pipeline_completionHandler_,
    "newRenderPipelineStateBySpecializationWithDescriptor:pipeline:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newRenderPipelineStateBySpecializationWithDescriptor_pipeline_error_,
    "newRenderPipelineStateBySpecializationWithDescriptor:pipeline:error:");
_MTL_PRIVATE_DEF_SEL(newRenderPipelineStateWithAdditionalBinaryFunctions_error_,
    "newRenderPipelineStateWithAdditionalBinaryFunctions:error:");
_MTL_PRIVATE_DEF_SEL(newRenderPipelineStateWithBinaryFunctions_error_,
    "newRenderPipelineStateWithBinaryFunctions:error:");
_MTL_PRIVATE_DEF_SEL(newRenderPipelineStateWithDescriptor_compilerTaskOptions_completionHandler_,
    "newRenderPipelineStateWithDescriptor:compilerTaskOptions:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newRenderPipelineStateWithDescriptor_compilerTaskOptions_error_,
    "newRenderPipelineStateWithDescriptor:compilerTaskOptions:error:");
_MTL_PRIVATE_DEF_SEL(newRenderPipelineStateWithDescriptor_completionHandler_,
    "newRenderPipelineStateWithDescriptor:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newRenderPipelineStateWithDescriptor_dynamicLinkingDescriptor_compilerTaskOptions_completionHandler_,
    "newRenderPipelineStateWithDescriptor:dynamicLinkingDescriptor:compilerTaskOptions:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newRenderPipelineStateWithDescriptor_dynamicLinkingDescriptor_compilerTaskOptions_error_,
    "newRenderPipelineStateWithDescriptor:dynamicLinkingDescriptor:compilerTaskOptions:error:");
_MTL_PRIVATE_DEF_SEL(newRenderPipelineStateWithDescriptor_dynamicLinkingDescriptor_error_,
    "newRenderPipelineStateWithDescriptor:dynamicLinkingDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newRenderPipelineStateWithDescriptor_error_,
    "newRenderPipelineStateWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newRenderPipelineStateWithDescriptor_options_completionHandler_,
    "newRenderPipelineStateWithDescriptor:options:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newRenderPipelineStateWithDescriptor_options_reflection_error_,
    "newRenderPipelineStateWithDescriptor:options:reflection:error:");
_MTL_PRIVATE_DEF_SEL(newRenderPipelineStateWithMeshDescriptor_options_completionHandler_,
    "newRenderPipelineStateWithMeshDescriptor:options:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newRenderPipelineStateWithMeshDescriptor_options_reflection_error_,
    "newRenderPipelineStateWithMeshDescriptor:options:reflection:error:");
_MTL_PRIVATE_DEF_SEL(newRenderPipelineStateWithTileDescriptor_options_completionHandler_,
    "newRenderPipelineStateWithTileDescriptor:options:completionHandler:");
_MTL_PRIVATE_DEF_SEL(newRenderPipelineStateWithTileDescriptor_options_reflection_error_,
    "newRenderPipelineStateWithTileDescriptor:options:reflection:error:");
_MTL_PRIVATE_DEF_SEL(newResidencySetWithDescriptor_error_,
    "newResidencySetWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newSamplerStateWithDescriptor_,
    "newSamplerStateWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(newScratchBufferWithMinimumSize_,
    "newScratchBufferWithMinimumSize:");
_MTL_PRIVATE_DEF_SEL(newSharedEvent,
    "newSharedEvent");
_MTL_PRIVATE_DEF_SEL(newSharedEventHandle,
    "newSharedEventHandle");
_MTL_PRIVATE_DEF_SEL(newSharedEventWithHandle_,
    "newSharedEventWithHandle:");
_MTL_PRIVATE_DEF_SEL(newSharedTextureHandle,
    "newSharedTextureHandle");
_MTL_PRIVATE_DEF_SEL(newSharedTextureWithDescriptor_,
    "newSharedTextureWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(newSharedTextureWithHandle_,
    "newSharedTextureWithHandle:");
_MTL_PRIVATE_DEF_SEL(newTensorWithDescriptor_error_,
    "newTensorWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newTensorWithDescriptor_offset_error_,
    "newTensorWithDescriptor:offset:error:");
_MTL_PRIVATE_DEF_SEL(newTextureViewPoolWithDescriptor_error_,
    "newTextureViewPoolWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(newTextureViewWithDescriptor_,
    "newTextureViewWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(newTextureViewWithPixelFormat_,
    "newTextureViewWithPixelFormat:");
_MTL_PRIVATE_DEF_SEL(newTextureViewWithPixelFormat_textureType_levels_slices_,
    "newTextureViewWithPixelFormat:textureType:levels:slices:");
_MTL_PRIVATE_DEF_SEL(newTextureViewWithPixelFormat_textureType_levels_slices_swizzle_,
    "newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:");
_MTL_PRIVATE_DEF_SEL(newTextureWithDescriptor_,
    "newTextureWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(newTextureWithDescriptor_iosurface_plane_,
    "newTextureWithDescriptor:iosurface:plane:");
_MTL_PRIVATE_DEF_SEL(newTextureWithDescriptor_offset_,
    "newTextureWithDescriptor:offset:");
_MTL_PRIVATE_DEF_SEL(newTextureWithDescriptor_offset_bytesPerRow_,
    "newTextureWithDescriptor:offset:bytesPerRow:");
_MTL_PRIVATE_DEF_SEL(newVisibleFunctionTableWithDescriptor_,
    "newVisibleFunctionTableWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(newVisibleFunctionTableWithDescriptor_stage_,
    "newVisibleFunctionTableWithDescriptor:stage:");
_MTL_PRIVATE_DEF_SEL(nodes,
    "nodes");
_MTL_PRIVATE_DEF_SEL(normalizedCoordinates,
    "normalizedCoordinates");
_MTL_PRIVATE_DEF_SEL(notifyListener_atValue_block_,
    "notifyListener:atValue:block:");
_MTL_PRIVATE_DEF_SEL(objectAdditionalBinaryFunctions,
    "objectAdditionalBinaryFunctions");
_MTL_PRIVATE_DEF_SEL(objectAtIndexedSubscript_,
    "objectAtIndexedSubscript:");
_MTL_PRIVATE_DEF_SEL(objectBindings,
    "objectBindings");
_MTL_PRIVATE_DEF_SEL(objectBuffers,
    "objectBuffers");
_MTL_PRIVATE_DEF_SEL(objectFunction,
    "objectFunction");
_MTL_PRIVATE_DEF_SEL(objectFunctionDescriptor,
    "objectFunctionDescriptor");
_MTL_PRIVATE_DEF_SEL(objectLinkedFunctions,
    "objectLinkedFunctions");
_MTL_PRIVATE_DEF_SEL(objectLinkingDescriptor,
    "objectLinkingDescriptor");
_MTL_PRIVATE_DEF_SEL(objectPayloadAlignment,
    "objectPayloadAlignment");
_MTL_PRIVATE_DEF_SEL(objectPayloadDataSize,
    "objectPayloadDataSize");
_MTL_PRIVATE_DEF_SEL(objectStaticLinkingDescriptor,
    "objectStaticLinkingDescriptor");
_MTL_PRIVATE_DEF_SEL(objectThreadExecutionWidth,
    "objectThreadExecutionWidth");
_MTL_PRIVATE_DEF_SEL(objectThreadgroupSizeIsMultipleOfThreadExecutionWidth,
    "objectThreadgroupSizeIsMultipleOfThreadExecutionWidth");
_MTL_PRIVATE_DEF_SEL(offset,
    "offset");
_MTL_PRIVATE_DEF_SEL(opaque,
    "opaque");
_MTL_PRIVATE_DEF_SEL(optimizationLevel,
    "optimizationLevel");
_MTL_PRIVATE_DEF_SEL(optimizeContentsForCPUAccess_,
    "optimizeContentsForCPUAccess:");
_MTL_PRIVATE_DEF_SEL(optimizeContentsForCPUAccess_slice_level_,
    "optimizeContentsForCPUAccess:slice:level:");
_MTL_PRIVATE_DEF_SEL(optimizeContentsForGPUAccess_,
    "optimizeContentsForGPUAccess:");
_MTL_PRIVATE_DEF_SEL(optimizeContentsForGPUAccess_slice_level_,
    "optimizeContentsForGPUAccess:slice:level:");
_MTL_PRIVATE_DEF_SEL(optimizeIndirectCommandBuffer_withRange_,
    "optimizeIndirectCommandBuffer:withRange:");
_MTL_PRIVATE_DEF_SEL(options,
    "options");
_MTL_PRIVATE_DEF_SEL(outputNode,
    "outputNode");
_MTL_PRIVATE_DEF_SEL(outputURL,
    "outputURL");
_MTL_PRIVATE_DEF_SEL(parallelRenderCommandEncoderWithDescriptor_,
    "parallelRenderCommandEncoderWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(parameterBufferSizeAndAlign,
    "parameterBufferSizeAndAlign");
_MTL_PRIVATE_DEF_SEL(parentRelativeLevel,
    "parentRelativeLevel");
_MTL_PRIVATE_DEF_SEL(parentRelativeSlice,
    "parentRelativeSlice");
_MTL_PRIVATE_DEF_SEL(parentTexture,
    "parentTexture");
_MTL_PRIVATE_DEF_SEL(patchControlPointCount,
    "patchControlPointCount");
_MTL_PRIVATE_DEF_SEL(patchType,
    "patchType");
_MTL_PRIVATE_DEF_SEL(payloadMemoryLength,
    "payloadMemoryLength");
_MTL_PRIVATE_DEF_SEL(peerCount,
    "peerCount");
_MTL_PRIVATE_DEF_SEL(peerGroupID,
    "peerGroupID");
_MTL_PRIVATE_DEF_SEL(peerIndex,
    "peerIndex");
_MTL_PRIVATE_DEF_SEL(physicalGranularity,
    "physicalGranularity");
_MTL_PRIVATE_DEF_SEL(physicalSizeForLayer_,
    "physicalSizeForLayer:");
_MTL_PRIVATE_DEF_SEL(pipelineDataSetSerializer,
    "pipelineDataSetSerializer");
_MTL_PRIVATE_DEF_SEL(pixelFormat,
    "pixelFormat");
_MTL_PRIVATE_DEF_SEL(placementSparsePageSize,
    "placementSparsePageSize");
_MTL_PRIVATE_DEF_SEL(pointerType,
    "pointerType");
_MTL_PRIVATE_DEF_SEL(popDebugGroup,
    "popDebugGroup");
_MTL_PRIVATE_DEF_SEL(preloadedLibraries,
    "preloadedLibraries");
_MTL_PRIVATE_DEF_SEL(preprocessorMacros,
    "preprocessorMacros");
_MTL_PRIVATE_DEF_SEL(present,
    "present");
_MTL_PRIVATE_DEF_SEL(presentAfterMinimumDuration_,
    "presentAfterMinimumDuration:");
_MTL_PRIVATE_DEF_SEL(presentAtTime_,
    "presentAtTime:");
_MTL_PRIVATE_DEF_SEL(presentDrawable_,
    "presentDrawable:");
_MTL_PRIVATE_DEF_SEL(presentDrawable_afterMinimumDuration_,
    "presentDrawable:afterMinimumDuration:");
_MTL_PRIVATE_DEF_SEL(presentDrawable_atTime_,
    "presentDrawable:atTime:");
_MTL_PRIVATE_DEF_SEL(presentedTime,
    "presentedTime");
_MTL_PRIVATE_DEF_SEL(preserveInvariance,
    "preserveInvariance");
_MTL_PRIVATE_DEF_SEL(primitiveDataBuffer,
    "primitiveDataBuffer");
_MTL_PRIVATE_DEF_SEL(primitiveDataBufferOffset,
    "primitiveDataBufferOffset");
_MTL_PRIVATE_DEF_SEL(primitiveDataElementSize,
    "primitiveDataElementSize");
_MTL_PRIVATE_DEF_SEL(primitiveDataStride,
    "primitiveDataStride");
_MTL_PRIVATE_DEF_SEL(priority,
    "priority");
_MTL_PRIVATE_DEF_SEL(privateFunctionDescriptors,
    "privateFunctionDescriptors");
_MTL_PRIVATE_DEF_SEL(privateFunctions,
    "privateFunctions");
_MTL_PRIVATE_DEF_SEL(pushDebugGroup_,
    "pushDebugGroup:");
_MTL_PRIVATE_DEF_SEL(queryTimestampFrequency,
    "queryTimestampFrequency");
_MTL_PRIVATE_DEF_SEL(rAddressMode,
    "rAddressMode");
_MTL_PRIVATE_DEF_SEL(radiusBuffer,
    "radiusBuffer");
_MTL_PRIVATE_DEF_SEL(radiusBufferOffset,
    "radiusBufferOffset");
_MTL_PRIVATE_DEF_SEL(radiusBuffers,
    "radiusBuffers");
_MTL_PRIVATE_DEF_SEL(radiusFormat,
    "radiusFormat");
_MTL_PRIVATE_DEF_SEL(radiusStride,
    "radiusStride");
_MTL_PRIVATE_DEF_SEL(rank,
    "rank");
_MTL_PRIVATE_DEF_SEL(rasterSampleCount,
    "rasterSampleCount");
_MTL_PRIVATE_DEF_SEL(rasterizationRateMap,
    "rasterizationRateMap");
_MTL_PRIVATE_DEF_SEL(rasterizationRateMapDescriptorWithScreenSize_,
    "rasterizationRateMapDescriptorWithScreenSize:");
_MTL_PRIVATE_DEF_SEL(rasterizationRateMapDescriptorWithScreenSize_layer_,
    "rasterizationRateMapDescriptorWithScreenSize:layer:");
_MTL_PRIVATE_DEF_SEL(rasterizationRateMapDescriptorWithScreenSize_layerCount_layers_,
    "rasterizationRateMapDescriptorWithScreenSize:layerCount:layers:");
_MTL_PRIVATE_DEF_SEL(readMask,
    "readMask");
_MTL_PRIVATE_DEF_SEL(readWriteTextureSupport,
    "readWriteTextureSupport");
_MTL_PRIVATE_DEF_SEL(recommendedMaxWorkingSetSize,
    "recommendedMaxWorkingSetSize");
_MTL_PRIVATE_DEF_SEL(reductionMode,
    "reductionMode");
_MTL_PRIVATE_DEF_SEL(refitAccelerationStructure_descriptor_destination_scratchBuffer_,
    "refitAccelerationStructure:descriptor:destination:scratchBuffer:");
_MTL_PRIVATE_DEF_SEL(refitAccelerationStructure_descriptor_destination_scratchBuffer_options_,
    "refitAccelerationStructure:descriptor:destination:scratchBuffer:options:");
_MTL_PRIVATE_DEF_SEL(refitAccelerationStructure_descriptor_destination_scratchBuffer_scratchBufferOffset_,
    "refitAccelerationStructure:descriptor:destination:scratchBuffer:scratchBufferOffset:");
_MTL_PRIVATE_DEF_SEL(refitAccelerationStructure_descriptor_destination_scratchBuffer_scratchBufferOffset_options_,
    "refitAccelerationStructure:descriptor:destination:scratchBuffer:scratchBufferOffset:options:");
_MTL_PRIVATE_DEF_SEL(reflection,
    "reflection");
_MTL_PRIVATE_DEF_SEL(reflectionForFunctionWithName_,
    "reflectionForFunctionWithName:");
_MTL_PRIVATE_DEF_SEL(registryID,
    "registryID");
_MTL_PRIVATE_DEF_SEL(remoteStorageBuffer,
    "remoteStorageBuffer");
_MTL_PRIVATE_DEF_SEL(remoteStorageTexture,
    "remoteStorageTexture");
_MTL_PRIVATE_DEF_SEL(removeAllAllocations,
    "removeAllAllocations");
_MTL_PRIVATE_DEF_SEL(removeAllDebugMarkers,
    "removeAllDebugMarkers");
_MTL_PRIVATE_DEF_SEL(removeAllocation_,
    "removeAllocation:");
_MTL_PRIVATE_DEF_SEL(removeAllocations_count_,
    "removeAllocations:count:");
_MTL_PRIVATE_DEF_SEL(removeResidencySet_,
    "removeResidencySet:");
_MTL_PRIVATE_DEF_SEL(removeResidencySets_count_,
    "removeResidencySets:count:");
_MTL_PRIVATE_DEF_SEL(renderCommandEncoder,
    "renderCommandEncoder");
_MTL_PRIVATE_DEF_SEL(renderCommandEncoderWithDescriptor_,
    "renderCommandEncoderWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(renderCommandEncoderWithDescriptor_options_,
    "renderCommandEncoderWithDescriptor:options:");
_MTL_PRIVATE_DEF_SEL(renderPassDescriptor,
    "renderPassDescriptor");
_MTL_PRIVATE_DEF_SEL(renderTargetArrayLength,
    "renderTargetArrayLength");
_MTL_PRIVATE_DEF_SEL(renderTargetHeight,
    "renderTargetHeight");
_MTL_PRIVATE_DEF_SEL(renderTargetWidth,
    "renderTargetWidth");
_MTL_PRIVATE_DEF_SEL(replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage_,
    "replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:");
_MTL_PRIVATE_DEF_SEL(replaceRegion_mipmapLevel_withBytes_bytesPerRow_,
    "replaceRegion:mipmapLevel:withBytes:bytesPerRow:");
_MTL_PRIVATE_DEF_SEL(replaceSliceOrigin_sliceDimensions_withBytes_strides_,
    "replaceSliceOrigin:sliceDimensions:withBytes:strides:");
_MTL_PRIVATE_DEF_SEL(requestResidency,
    "requestResidency");
_MTL_PRIVATE_DEF_SEL(required,
    "required");
_MTL_PRIVATE_DEF_SEL(requiredThreadsPerMeshThreadgroup,
    "requiredThreadsPerMeshThreadgroup");
_MTL_PRIVATE_DEF_SEL(requiredThreadsPerObjectThreadgroup,
    "requiredThreadsPerObjectThreadgroup");
_MTL_PRIVATE_DEF_SEL(requiredThreadsPerThreadgroup,
    "requiredThreadsPerThreadgroup");
_MTL_PRIVATE_DEF_SEL(requiredThreadsPerTileThreadgroup,
    "requiredThreadsPerTileThreadgroup");
_MTL_PRIVATE_DEF_SEL(reset,
    "reset");
_MTL_PRIVATE_DEF_SEL(resetCommandsInBuffer_withRange_,
    "resetCommandsInBuffer:withRange:");
_MTL_PRIVATE_DEF_SEL(resetTextureAccessCounters_region_mipLevel_slice_,
    "resetTextureAccessCounters:region:mipLevel:slice:");
_MTL_PRIVATE_DEF_SEL(resetWithRange_,
    "resetWithRange:");
_MTL_PRIVATE_DEF_SEL(resolveCounterHeap_withRange_intoBuffer_waitFence_updateFence_,
    "resolveCounterHeap:withRange:intoBuffer:waitFence:updateFence:");
_MTL_PRIVATE_DEF_SEL(resolveCounterRange_,
    "resolveCounterRange:");
_MTL_PRIVATE_DEF_SEL(resolveCounters_inRange_destinationBuffer_destinationOffset_,
    "resolveCounters:inRange:destinationBuffer:destinationOffset:");
_MTL_PRIVATE_DEF_SEL(resolveDepthPlane,
    "resolveDepthPlane");
_MTL_PRIVATE_DEF_SEL(resolveLevel,
    "resolveLevel");
_MTL_PRIVATE_DEF_SEL(resolveSlice,
    "resolveSlice");
_MTL_PRIVATE_DEF_SEL(resolveTexture,
    "resolveTexture");
_MTL_PRIVATE_DEF_SEL(resourceOptions,
    "resourceOptions");
_MTL_PRIVATE_DEF_SEL(resourceStateCommandEncoder,
    "resourceStateCommandEncoder");
_MTL_PRIVATE_DEF_SEL(resourceStateCommandEncoderWithDescriptor_,
    "resourceStateCommandEncoderWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(resourceStatePassDescriptor,
    "resourceStatePassDescriptor");
_MTL_PRIVATE_DEF_SEL(resourceViewCount,
    "resourceViewCount");
_MTL_PRIVATE_DEF_SEL(retainedReferences,
    "retainedReferences");
_MTL_PRIVATE_DEF_SEL(rgbBlendOperation,
    "rgbBlendOperation");
_MTL_PRIVATE_DEF_SEL(rootResource,
    "rootResource");
_MTL_PRIVATE_DEF_SEL(sAddressMode,
    "sAddressMode");
_MTL_PRIVATE_DEF_SEL(sampleBuffer,
    "sampleBuffer");
_MTL_PRIVATE_DEF_SEL(sampleBufferAttachments,
    "sampleBufferAttachments");
_MTL_PRIVATE_DEF_SEL(sampleCount,
    "sampleCount");
_MTL_PRIVATE_DEF_SEL(sampleCountersInBuffer_atSampleIndex_withBarrier_,
    "sampleCountersInBuffer:atSampleIndex:withBarrier:");
_MTL_PRIVATE_DEF_SEL(sampleTimestamps_gpuTimestamp_,
    "sampleTimestamps:gpuTimestamp:");
_MTL_PRIVATE_DEF_SEL(scratchBufferAllocator,
    "scratchBufferAllocator");
_MTL_PRIVATE_DEF_SEL(screenSize,
    "screenSize");
_MTL_PRIVATE_DEF_SEL(segmentControlPointCount,
    "segmentControlPointCount");
_MTL_PRIVATE_DEF_SEL(segmentCount,
    "segmentCount");
_MTL_PRIVATE_DEF_SEL(serializeAsArchiveAndFlushToURL_error_,
    "serializeAsArchiveAndFlushToURL:error:");
_MTL_PRIVATE_DEF_SEL(serializeAsPipelinesScriptWithError_,
    "serializeAsPipelinesScriptWithError:");
_MTL_PRIVATE_DEF_SEL(serializeToURL_error_,
    "serializeToURL:error:");
_MTL_PRIVATE_DEF_SEL(setAccelerationStructure_atBufferIndex_,
    "setAccelerationStructure:atBufferIndex:");
_MTL_PRIVATE_DEF_SEL(setAccelerationStructure_atIndex_,
    "setAccelerationStructure:atIndex:");
_MTL_PRIVATE_DEF_SEL(setAccess_,
    "setAccess:");
_MTL_PRIVATE_DEF_SEL(setAddress_atIndex_,
    "setAddress:atIndex:");
_MTL_PRIVATE_DEF_SEL(setAddress_attributeStride_atIndex_,
    "setAddress:attributeStride:atIndex:");
_MTL_PRIVATE_DEF_SEL(setAllowDuplicateIntersectionFunctionInvocation_,
    "setAllowDuplicateIntersectionFunctionInvocation:");
_MTL_PRIVATE_DEF_SEL(setAllowGPUOptimizedContents_,
    "setAllowGPUOptimizedContents:");
_MTL_PRIVATE_DEF_SEL(setAllowReferencingUndefinedSymbols_,
    "setAllowReferencingUndefinedSymbols:");
_MTL_PRIVATE_DEF_SEL(setAlphaBlendOperation_,
    "setAlphaBlendOperation:");
_MTL_PRIVATE_DEF_SEL(setAlphaToCoverageEnabled_,
    "setAlphaToCoverageEnabled:");
_MTL_PRIVATE_DEF_SEL(setAlphaToCoverageState_,
    "setAlphaToCoverageState:");
_MTL_PRIVATE_DEF_SEL(setAlphaToOneEnabled_,
    "setAlphaToOneEnabled:");
_MTL_PRIVATE_DEF_SEL(setAlphaToOneState_,
    "setAlphaToOneState:");
_MTL_PRIVATE_DEF_SEL(setArgumentBuffer_offset_,
    "setArgumentBuffer:offset:");
_MTL_PRIVATE_DEF_SEL(setArgumentBuffer_startOffset_arrayElement_,
    "setArgumentBuffer:startOffset:arrayElement:");
_MTL_PRIVATE_DEF_SEL(setArgumentIndex_,
    "setArgumentIndex:");
_MTL_PRIVATE_DEF_SEL(setArgumentTable_,
    "setArgumentTable:");
_MTL_PRIVATE_DEF_SEL(setArgumentTable_atStages_,
    "setArgumentTable:atStages:");
_MTL_PRIVATE_DEF_SEL(setArguments_,
    "setArguments:");
_MTL_PRIVATE_DEF_SEL(setArrayLength_,
    "setArrayLength:");
_MTL_PRIVATE_DEF_SEL(setAttributes_,
    "setAttributes:");
_MTL_PRIVATE_DEF_SEL(setBackFaceStencil_,
    "setBackFaceStencil:");
_MTL_PRIVATE_DEF_SEL(setBarrier,
    "setBarrier");
_MTL_PRIVATE_DEF_SEL(setBinaryArchives_,
    "setBinaryArchives:");
_MTL_PRIVATE_DEF_SEL(setBinaryFunctions_,
    "setBinaryFunctions:");
_MTL_PRIVATE_DEF_SEL(setBinaryLinkedFunctions_,
    "setBinaryLinkedFunctions:");
_MTL_PRIVATE_DEF_SEL(setBlendColorRed_green_blue_alpha_,
    "setBlendColorRed:green:blue:alpha:");
_MTL_PRIVATE_DEF_SEL(setBlendingEnabled_,
    "setBlendingEnabled:");
_MTL_PRIVATE_DEF_SEL(setBlendingState_,
    "setBlendingState:");
_MTL_PRIVATE_DEF_SEL(setBorderColor_,
    "setBorderColor:");
_MTL_PRIVATE_DEF_SEL(setBoundingBoxBuffer_,
    "setBoundingBoxBuffer:");
_MTL_PRIVATE_DEF_SEL(setBoundingBoxBufferOffset_,
    "setBoundingBoxBufferOffset:");
_MTL_PRIVATE_DEF_SEL(setBoundingBoxBuffers_,
    "setBoundingBoxBuffers:");
_MTL_PRIVATE_DEF_SEL(setBoundingBoxCount_,
    "setBoundingBoxCount:");
_MTL_PRIVATE_DEF_SEL(setBoundingBoxStride_,
    "setBoundingBoxStride:");
_MTL_PRIVATE_DEF_SEL(setBuffer_,
    "setBuffer:");
_MTL_PRIVATE_DEF_SEL(setBuffer_offset_atIndex_,
    "setBuffer:offset:atIndex:");
_MTL_PRIVATE_DEF_SEL(setBuffer_offset_attributeStride_atIndex_,
    "setBuffer:offset:attributeStride:atIndex:");
_MTL_PRIVATE_DEF_SEL(setBufferIndex_,
    "setBufferIndex:");
_MTL_PRIVATE_DEF_SEL(setBufferOffset_atIndex_,
    "setBufferOffset:atIndex:");
_MTL_PRIVATE_DEF_SEL(setBufferOffset_attributeStride_atIndex_,
    "setBufferOffset:attributeStride:atIndex:");
_MTL_PRIVATE_DEF_SEL(setBufferSize_,
    "setBufferSize:");
_MTL_PRIVATE_DEF_SEL(setBuffers_offsets_attributeStrides_withRange_,
    "setBuffers:offsets:attributeStrides:withRange:");
_MTL_PRIVATE_DEF_SEL(setBuffers_offsets_withRange_,
    "setBuffers:offsets:withRange:");
_MTL_PRIVATE_DEF_SEL(setBytes_length_atIndex_,
    "setBytes:length:atIndex:");
_MTL_PRIVATE_DEF_SEL(setBytes_length_attributeStride_atIndex_,
    "setBytes:length:attributeStride:atIndex:");
_MTL_PRIVATE_DEF_SEL(setCaptureObject_,
    "setCaptureObject:");
_MTL_PRIVATE_DEF_SEL(setClearColor_,
    "setClearColor:");
_MTL_PRIVATE_DEF_SEL(setClearDepth_,
    "setClearDepth:");
_MTL_PRIVATE_DEF_SEL(setClearStencil_,
    "setClearStencil:");
_MTL_PRIVATE_DEF_SEL(setColorAttachmentMap_,
    "setColorAttachmentMap:");
_MTL_PRIVATE_DEF_SEL(setColorAttachmentMappingState_,
    "setColorAttachmentMappingState:");
_MTL_PRIVATE_DEF_SEL(setColorStoreAction_atIndex_,
    "setColorStoreAction:atIndex:");
_MTL_PRIVATE_DEF_SEL(setColorStoreActionOptions_atIndex_,
    "setColorStoreActionOptions:atIndex:");
_MTL_PRIVATE_DEF_SEL(setCommandTypes_,
    "setCommandTypes:");
_MTL_PRIVATE_DEF_SEL(setCompareFunction_,
    "setCompareFunction:");
_MTL_PRIVATE_DEF_SEL(setCompileSymbolVisibility_,
    "setCompileSymbolVisibility:");
_MTL_PRIVATE_DEF_SEL(setCompressionType_,
    "setCompressionType:");
_MTL_PRIVATE_DEF_SEL(setComputeFunction_,
    "setComputeFunction:");
_MTL_PRIVATE_DEF_SEL(setComputeFunctionDescriptor_,
    "setComputeFunctionDescriptor:");
_MTL_PRIVATE_DEF_SEL(setComputePipelineState_,
    "setComputePipelineState:");
_MTL_PRIVATE_DEF_SEL(setComputePipelineState_atIndex_,
    "setComputePipelineState:atIndex:");
_MTL_PRIVATE_DEF_SEL(setComputePipelineStates_withRange_,
    "setComputePipelineStates:withRange:");
_MTL_PRIVATE_DEF_SEL(setConfiguration_,
    "setConfiguration:");
_MTL_PRIVATE_DEF_SEL(setConstantBlockAlignment_,
    "setConstantBlockAlignment:");
_MTL_PRIVATE_DEF_SEL(setConstantValue_type_atIndex_,
    "setConstantValue:type:atIndex:");
_MTL_PRIVATE_DEF_SEL(setConstantValue_type_withName_,
    "setConstantValue:type:withName:");
_MTL_PRIVATE_DEF_SEL(setConstantValues_,
    "setConstantValues:");
_MTL_PRIVATE_DEF_SEL(setConstantValues_type_withRange_,
    "setConstantValues:type:withRange:");
_MTL_PRIVATE_DEF_SEL(setControlDependencies_,
    "setControlDependencies:");
_MTL_PRIVATE_DEF_SEL(setControlPointBuffer_,
    "setControlPointBuffer:");
_MTL_PRIVATE_DEF_SEL(setControlPointBufferOffset_,
    "setControlPointBufferOffset:");
_MTL_PRIVATE_DEF_SEL(setControlPointBuffers_,
    "setControlPointBuffers:");
_MTL_PRIVATE_DEF_SEL(setControlPointCount_,
    "setControlPointCount:");
_MTL_PRIVATE_DEF_SEL(setControlPointFormat_,
    "setControlPointFormat:");
_MTL_PRIVATE_DEF_SEL(setControlPointStride_,
    "setControlPointStride:");
_MTL_PRIVATE_DEF_SEL(setCount_,
    "setCount:");
_MTL_PRIVATE_DEF_SEL(setCounterSet_,
    "setCounterSet:");
_MTL_PRIVATE_DEF_SEL(setCpuCacheMode_,
    "setCpuCacheMode:");
_MTL_PRIVATE_DEF_SEL(setCullMode_,
    "setCullMode:");
_MTL_PRIVATE_DEF_SEL(setCurveBasis_,
    "setCurveBasis:");
_MTL_PRIVATE_DEF_SEL(setCurveEndCaps_,
    "setCurveEndCaps:");
_MTL_PRIVATE_DEF_SEL(setCurveType_,
    "setCurveType:");
_MTL_PRIVATE_DEF_SEL(setDataType_,
    "setDataType:");
_MTL_PRIVATE_DEF_SEL(setDefaultCaptureScope_,
    "setDefaultCaptureScope:");
_MTL_PRIVATE_DEF_SEL(setDefaultRasterSampleCount_,
    "setDefaultRasterSampleCount:");
_MTL_PRIVATE_DEF_SEL(setDepth_,
    "setDepth:");
_MTL_PRIVATE_DEF_SEL(setDepthAttachment_,
    "setDepthAttachment:");
_MTL_PRIVATE_DEF_SEL(setDepthAttachmentPixelFormat_,
    "setDepthAttachmentPixelFormat:");
_MTL_PRIVATE_DEF_SEL(setDepthBias_slopeScale_clamp_,
    "setDepthBias:slopeScale:clamp:");
_MTL_PRIVATE_DEF_SEL(setDepthClipMode_,
    "setDepthClipMode:");
_MTL_PRIVATE_DEF_SEL(setDepthCompareFunction_,
    "setDepthCompareFunction:");
_MTL_PRIVATE_DEF_SEL(setDepthFailureOperation_,
    "setDepthFailureOperation:");
_MTL_PRIVATE_DEF_SEL(setDepthPlane_,
    "setDepthPlane:");
_MTL_PRIVATE_DEF_SEL(setDepthResolveFilter_,
    "setDepthResolveFilter:");
_MTL_PRIVATE_DEF_SEL(setDepthStencilPassOperation_,
    "setDepthStencilPassOperation:");
_MTL_PRIVATE_DEF_SEL(setDepthStencilState_,
    "setDepthStencilState:");
_MTL_PRIVATE_DEF_SEL(setDepthStencilState_atIndex_,
    "setDepthStencilState:atIndex:");
_MTL_PRIVATE_DEF_SEL(setDepthStencilStates_withRange_,
    "setDepthStencilStates:withRange:");
_MTL_PRIVATE_DEF_SEL(setDepthStoreAction_,
    "setDepthStoreAction:");
_MTL_PRIVATE_DEF_SEL(setDepthStoreActionOptions_,
    "setDepthStoreActionOptions:");
_MTL_PRIVATE_DEF_SEL(setDepthTestMinBound_maxBound_,
    "setDepthTestMinBound:maxBound:");
_MTL_PRIVATE_DEF_SEL(setDepthWriteEnabled_,
    "setDepthWriteEnabled:");
_MTL_PRIVATE_DEF_SEL(setDestination_,
    "setDestination:");
_MTL_PRIVATE_DEF_SEL(setDestinationAlphaBlendFactor_,
    "setDestinationAlphaBlendFactor:");
_MTL_PRIVATE_DEF_SEL(setDestinationRGBBlendFactor_,
    "setDestinationRGBBlendFactor:");
_MTL_PRIVATE_DEF_SEL(setDimensions_,
    "setDimensions:");
_MTL_PRIVATE_DEF_SEL(setDispatchType_,
    "setDispatchType:");
_MTL_PRIVATE_DEF_SEL(setEnableLogging_,
    "setEnableLogging:");
_MTL_PRIVATE_DEF_SEL(setEndOfEncoderSampleIndex_,
    "setEndOfEncoderSampleIndex:");
_MTL_PRIVATE_DEF_SEL(setEndOfFragmentSampleIndex_,
    "setEndOfFragmentSampleIndex:");
_MTL_PRIVATE_DEF_SEL(setEndOfVertexSampleIndex_,
    "setEndOfVertexSampleIndex:");
_MTL_PRIVATE_DEF_SEL(setErrorOptions_,
    "setErrorOptions:");
_MTL_PRIVATE_DEF_SEL(setFastMathEnabled_,
    "setFastMathEnabled:");
_MTL_PRIVATE_DEF_SEL(setFeedbackQueue_,
    "setFeedbackQueue:");
_MTL_PRIVATE_DEF_SEL(setFormat_,
    "setFormat:");
_MTL_PRIVATE_DEF_SEL(setFragmentAccelerationStructure_atBufferIndex_,
    "setFragmentAccelerationStructure:atBufferIndex:");
_MTL_PRIVATE_DEF_SEL(setFragmentAdditionalBinaryFunctions_,
    "setFragmentAdditionalBinaryFunctions:");
_MTL_PRIVATE_DEF_SEL(setFragmentBuffer_offset_atIndex_,
    "setFragmentBuffer:offset:atIndex:");
_MTL_PRIVATE_DEF_SEL(setFragmentBufferOffset_atIndex_,
    "setFragmentBufferOffset:atIndex:");
_MTL_PRIVATE_DEF_SEL(setFragmentBuffers_offsets_withRange_,
    "setFragmentBuffers:offsets:withRange:");
_MTL_PRIVATE_DEF_SEL(setFragmentBytes_length_atIndex_,
    "setFragmentBytes:length:atIndex:");
_MTL_PRIVATE_DEF_SEL(setFragmentFunction_,
    "setFragmentFunction:");
_MTL_PRIVATE_DEF_SEL(setFragmentFunctionDescriptor_,
    "setFragmentFunctionDescriptor:");
_MTL_PRIVATE_DEF_SEL(setFragmentIntersectionFunctionTable_atBufferIndex_,
    "setFragmentIntersectionFunctionTable:atBufferIndex:");
_MTL_PRIVATE_DEF_SEL(setFragmentIntersectionFunctionTables_withBufferRange_,
    "setFragmentIntersectionFunctionTables:withBufferRange:");
_MTL_PRIVATE_DEF_SEL(setFragmentLinkedFunctions_,
    "setFragmentLinkedFunctions:");
_MTL_PRIVATE_DEF_SEL(setFragmentPreloadedLibraries_,
    "setFragmentPreloadedLibraries:");
_MTL_PRIVATE_DEF_SEL(setFragmentSamplerState_atIndex_,
    "setFragmentSamplerState:atIndex:");
_MTL_PRIVATE_DEF_SEL(setFragmentSamplerState_lodMinClamp_lodMaxClamp_atIndex_,
    "setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:");
_MTL_PRIVATE_DEF_SEL(setFragmentSamplerStates_lodMinClamps_lodMaxClamps_withRange_,
    "setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:");
_MTL_PRIVATE_DEF_SEL(setFragmentSamplerStates_withRange_,
    "setFragmentSamplerStates:withRange:");
_MTL_PRIVATE_DEF_SEL(setFragmentStaticLinkingDescriptor_,
    "setFragmentStaticLinkingDescriptor:");
_MTL_PRIVATE_DEF_SEL(setFragmentTexture_atIndex_,
    "setFragmentTexture:atIndex:");
_MTL_PRIVATE_DEF_SEL(setFragmentTextures_withRange_,
    "setFragmentTextures:withRange:");
_MTL_PRIVATE_DEF_SEL(setFragmentVisibleFunctionTable_atBufferIndex_,
    "setFragmentVisibleFunctionTable:atBufferIndex:");
_MTL_PRIVATE_DEF_SEL(setFragmentVisibleFunctionTables_withBufferRange_,
    "setFragmentVisibleFunctionTables:withBufferRange:");
_MTL_PRIVATE_DEF_SEL(setFrontFaceStencil_,
    "setFrontFaceStencil:");
_MTL_PRIVATE_DEF_SEL(setFrontFacingWinding_,
    "setFrontFacingWinding:");
_MTL_PRIVATE_DEF_SEL(setFunction_atIndex_,
    "setFunction:atIndex:");
_MTL_PRIVATE_DEF_SEL(setFunctionCount_,
    "setFunctionCount:");
_MTL_PRIVATE_DEF_SEL(setFunctionDescriptor_,
    "setFunctionDescriptor:");
_MTL_PRIVATE_DEF_SEL(setFunctionDescriptors_,
    "setFunctionDescriptors:");
_MTL_PRIVATE_DEF_SEL(setFunctionGraph_,
    "setFunctionGraph:");
_MTL_PRIVATE_DEF_SEL(setFunctionGraphs_,
    "setFunctionGraphs:");
_MTL_PRIVATE_DEF_SEL(setFunctionName_,
    "setFunctionName:");
_MTL_PRIVATE_DEF_SEL(setFunctions_,
    "setFunctions:");
_MTL_PRIVATE_DEF_SEL(setFunctions_withRange_,
    "setFunctions:withRange:");
_MTL_PRIVATE_DEF_SEL(setGeometryDescriptors_,
    "setGeometryDescriptors:");
_MTL_PRIVATE_DEF_SEL(setGroups_,
    "setGroups:");
_MTL_PRIVATE_DEF_SEL(setHazardTrackingMode_,
    "setHazardTrackingMode:");
_MTL_PRIVATE_DEF_SEL(setHeight_,
    "setHeight:");
_MTL_PRIVATE_DEF_SEL(setImageblockSampleLength_,
    "setImageblockSampleLength:");
_MTL_PRIVATE_DEF_SEL(setImageblockWidth_height_,
    "setImageblockWidth:height:");
_MTL_PRIVATE_DEF_SEL(setIndex_,
    "setIndex:");
_MTL_PRIVATE_DEF_SEL(setIndexBuffer_,
    "setIndexBuffer:");
_MTL_PRIVATE_DEF_SEL(setIndexBufferIndex_,
    "setIndexBufferIndex:");
_MTL_PRIVATE_DEF_SEL(setIndexBufferOffset_,
    "setIndexBufferOffset:");
_MTL_PRIVATE_DEF_SEL(setIndexType_,
    "setIndexType:");
_MTL_PRIVATE_DEF_SEL(setIndirectCommandBuffer_atIndex_,
    "setIndirectCommandBuffer:atIndex:");
_MTL_PRIVATE_DEF_SEL(setIndirectCommandBuffers_withRange_,
    "setIndirectCommandBuffers:withRange:");
_MTL_PRIVATE_DEF_SEL(setInheritBuffers_,
    "setInheritBuffers:");
_MTL_PRIVATE_DEF_SEL(setInheritCullMode_,
    "setInheritCullMode:");
_MTL_PRIVATE_DEF_SEL(setInheritDepthBias_,
    "setInheritDepthBias:");
_MTL_PRIVATE_DEF_SEL(setInheritDepthClipMode_,
    "setInheritDepthClipMode:");
_MTL_PRIVATE_DEF_SEL(setInheritDepthStencilState_,
    "setInheritDepthStencilState:");
_MTL_PRIVATE_DEF_SEL(setInheritFrontFacingWinding_,
    "setInheritFrontFacingWinding:");
_MTL_PRIVATE_DEF_SEL(setInheritPipelineState_,
    "setInheritPipelineState:");
_MTL_PRIVATE_DEF_SEL(setInheritTriangleFillMode_,
    "setInheritTriangleFillMode:");
_MTL_PRIVATE_DEF_SEL(setInitialCapacity_,
    "setInitialCapacity:");
_MTL_PRIVATE_DEF_SEL(setInitializeBindings_,
    "setInitializeBindings:");
_MTL_PRIVATE_DEF_SEL(setInputDimensions_atBufferIndex_,
    "setInputDimensions:atBufferIndex:");
_MTL_PRIVATE_DEF_SEL(setInputDimensions_withRange_,
    "setInputDimensions:withRange:");
_MTL_PRIVATE_DEF_SEL(setInputPrimitiveTopology_,
    "setInputPrimitiveTopology:");
_MTL_PRIVATE_DEF_SEL(setInsertLibraries_,
    "setInsertLibraries:");
_MTL_PRIVATE_DEF_SEL(setInstallName_,
    "setInstallName:");
_MTL_PRIVATE_DEF_SEL(setInstanceCount_,
    "setInstanceCount:");
_MTL_PRIVATE_DEF_SEL(setInstanceCountBuffer_,
    "setInstanceCountBuffer:");
_MTL_PRIVATE_DEF_SEL(setInstanceCountBufferOffset_,
    "setInstanceCountBufferOffset:");
_MTL_PRIVATE_DEF_SEL(setInstanceDescriptorBuffer_,
    "setInstanceDescriptorBuffer:");
_MTL_PRIVATE_DEF_SEL(setInstanceDescriptorBufferOffset_,
    "setInstanceDescriptorBufferOffset:");
_MTL_PRIVATE_DEF_SEL(setInstanceDescriptorStride_,
    "setInstanceDescriptorStride:");
_MTL_PRIVATE_DEF_SEL(setInstanceDescriptorType_,
    "setInstanceDescriptorType:");
_MTL_PRIVATE_DEF_SEL(setInstanceTransformationMatrixLayout_,
    "setInstanceTransformationMatrixLayout:");
_MTL_PRIVATE_DEF_SEL(setInstancedAccelerationStructures_,
    "setInstancedAccelerationStructures:");
_MTL_PRIVATE_DEF_SEL(setIntersectionFunctionTable_atBufferIndex_,
    "setIntersectionFunctionTable:atBufferIndex:");
_MTL_PRIVATE_DEF_SEL(setIntersectionFunctionTable_atIndex_,
    "setIntersectionFunctionTable:atIndex:");
_MTL_PRIVATE_DEF_SEL(setIntersectionFunctionTableOffset_,
    "setIntersectionFunctionTableOffset:");
_MTL_PRIVATE_DEF_SEL(setIntersectionFunctionTables_withBufferRange_,
    "setIntersectionFunctionTables:withBufferRange:");
_MTL_PRIVATE_DEF_SEL(setIntersectionFunctionTables_withRange_,
    "setIntersectionFunctionTables:withRange:");
_MTL_PRIVATE_DEF_SEL(setKernelBuffer_offset_atIndex_,
    "setKernelBuffer:offset:atIndex:");
_MTL_PRIVATE_DEF_SEL(setKernelBuffer_offset_attributeStride_atIndex_,
    "setKernelBuffer:offset:attributeStride:atIndex:");
_MTL_PRIVATE_DEF_SEL(setLabel_,
    "setLabel:");
_MTL_PRIVATE_DEF_SEL(setLanguageVersion_,
    "setLanguageVersion:");
_MTL_PRIVATE_DEF_SEL(setLayer_atIndex_,
    "setLayer:atIndex:");
_MTL_PRIVATE_DEF_SEL(setLevel_,
    "setLevel:");
_MTL_PRIVATE_DEF_SEL(setLevelRange_,
    "setLevelRange:");
_MTL_PRIVATE_DEF_SEL(setLibraries_,
    "setLibraries:");
_MTL_PRIVATE_DEF_SEL(setLibrary_,
    "setLibrary:");
_MTL_PRIVATE_DEF_SEL(setLibraryType_,
    "setLibraryType:");
_MTL_PRIVATE_DEF_SEL(setLinkedFunctions_,
    "setLinkedFunctions:");
_MTL_PRIVATE_DEF_SEL(setLoadAction_,
    "setLoadAction:");
_MTL_PRIVATE_DEF_SEL(setLodAverage_,
    "setLodAverage:");
_MTL_PRIVATE_DEF_SEL(setLodBias_,
    "setLodBias:");
_MTL_PRIVATE_DEF_SEL(setLodMaxClamp_,
    "setLodMaxClamp:");
_MTL_PRIVATE_DEF_SEL(setLodMinClamp_,
    "setLodMinClamp:");
_MTL_PRIVATE_DEF_SEL(setLogState_,
    "setLogState:");
_MTL_PRIVATE_DEF_SEL(setLookupArchives_,
    "setLookupArchives:");
_MTL_PRIVATE_DEF_SEL(setMachineLearningFunctionDescriptor_,
    "setMachineLearningFunctionDescriptor:");
_MTL_PRIVATE_DEF_SEL(setMagFilter_,
    "setMagFilter:");
_MTL_PRIVATE_DEF_SEL(setMathFloatingPointFunctions_,
    "setMathFloatingPointFunctions:");
_MTL_PRIVATE_DEF_SEL(setMathMode_,
    "setMathMode:");
_MTL_PRIVATE_DEF_SEL(setMaxAnisotropy_,
    "setMaxAnisotropy:");
_MTL_PRIVATE_DEF_SEL(setMaxBufferBindCount_,
    "setMaxBufferBindCount:");
_MTL_PRIVATE_DEF_SEL(setMaxCallStackDepth_,
    "setMaxCallStackDepth:");
_MTL_PRIVATE_DEF_SEL(setMaxCommandBufferCount_,
    "setMaxCommandBufferCount:");
_MTL_PRIVATE_DEF_SEL(setMaxCommandsInFlight_,
    "setMaxCommandsInFlight:");
_MTL_PRIVATE_DEF_SEL(setMaxCompatiblePlacementSparsePageSize_,
    "setMaxCompatiblePlacementSparsePageSize:");
_MTL_PRIVATE_DEF_SEL(setMaxFragmentBufferBindCount_,
    "setMaxFragmentBufferBindCount:");
_MTL_PRIVATE_DEF_SEL(setMaxFragmentCallStackDepth_,
    "setMaxFragmentCallStackDepth:");
_MTL_PRIVATE_DEF_SEL(setMaxInstanceCount_,
    "setMaxInstanceCount:");
_MTL_PRIVATE_DEF_SEL(setMaxKernelBufferBindCount_,
    "setMaxKernelBufferBindCount:");
_MTL_PRIVATE_DEF_SEL(setMaxKernelThreadgroupMemoryBindCount_,
    "setMaxKernelThreadgroupMemoryBindCount:");
_MTL_PRIVATE_DEF_SEL(setMaxMeshBufferBindCount_,
    "setMaxMeshBufferBindCount:");
_MTL_PRIVATE_DEF_SEL(setMaxMotionTransformCount_,
    "setMaxMotionTransformCount:");
_MTL_PRIVATE_DEF_SEL(setMaxObjectBufferBindCount_,
    "setMaxObjectBufferBindCount:");
_MTL_PRIVATE_DEF_SEL(setMaxObjectThreadgroupMemoryBindCount_,
    "setMaxObjectThreadgroupMemoryBindCount:");
_MTL_PRIVATE_DEF_SEL(setMaxSamplerStateBindCount_,
    "setMaxSamplerStateBindCount:");
_MTL_PRIVATE_DEF_SEL(setMaxTessellationFactor_,
    "setMaxTessellationFactor:");
_MTL_PRIVATE_DEF_SEL(setMaxTextureBindCount_,
    "setMaxTextureBindCount:");
_MTL_PRIVATE_DEF_SEL(setMaxTotalThreadgroupsPerMeshGrid_,
    "setMaxTotalThreadgroupsPerMeshGrid:");
_MTL_PRIVATE_DEF_SEL(setMaxTotalThreadsPerMeshThreadgroup_,
    "setMaxTotalThreadsPerMeshThreadgroup:");
_MTL_PRIVATE_DEF_SEL(setMaxTotalThreadsPerObjectThreadgroup_,
    "setMaxTotalThreadsPerObjectThreadgroup:");
_MTL_PRIVATE_DEF_SEL(setMaxTotalThreadsPerThreadgroup_,
    "setMaxTotalThreadsPerThreadgroup:");
_MTL_PRIVATE_DEF_SEL(setMaxVertexAmplificationCount_,
    "setMaxVertexAmplificationCount:");
_MTL_PRIVATE_DEF_SEL(setMaxVertexBufferBindCount_,
    "setMaxVertexBufferBindCount:");
_MTL_PRIVATE_DEF_SEL(setMaxVertexCallStackDepth_,
    "setMaxVertexCallStackDepth:");
_MTL_PRIVATE_DEF_SEL(setMeshAdditionalBinaryFunctions_,
    "setMeshAdditionalBinaryFunctions:");
_MTL_PRIVATE_DEF_SEL(setMeshBuffer_offset_atIndex_,
    "setMeshBuffer:offset:atIndex:");
_MTL_PRIVATE_DEF_SEL(setMeshBufferOffset_atIndex_,
    "setMeshBufferOffset:atIndex:");
_MTL_PRIVATE_DEF_SEL(setMeshBuffers_offsets_withRange_,
    "setMeshBuffers:offsets:withRange:");
_MTL_PRIVATE_DEF_SEL(setMeshBytes_length_atIndex_,
    "setMeshBytes:length:atIndex:");
_MTL_PRIVATE_DEF_SEL(setMeshFunction_,
    "setMeshFunction:");
_MTL_PRIVATE_DEF_SEL(setMeshFunctionDescriptor_,
    "setMeshFunctionDescriptor:");
_MTL_PRIVATE_DEF_SEL(setMeshLinkedFunctions_,
    "setMeshLinkedFunctions:");
_MTL_PRIVATE_DEF_SEL(setMeshSamplerState_atIndex_,
    "setMeshSamplerState:atIndex:");
_MTL_PRIVATE_DEF_SEL(setMeshSamplerState_lodMinClamp_lodMaxClamp_atIndex_,
    "setMeshSamplerState:lodMinClamp:lodMaxClamp:atIndex:");
_MTL_PRIVATE_DEF_SEL(setMeshSamplerStates_lodMinClamps_lodMaxClamps_withRange_,
    "setMeshSamplerStates:lodMinClamps:lodMaxClamps:withRange:");
_MTL_PRIVATE_DEF_SEL(setMeshSamplerStates_withRange_,
    "setMeshSamplerStates:withRange:");
_MTL_PRIVATE_DEF_SEL(setMeshStaticLinkingDescriptor_,
    "setMeshStaticLinkingDescriptor:");
_MTL_PRIVATE_DEF_SEL(setMeshTexture_atIndex_,
    "setMeshTexture:atIndex:");
_MTL_PRIVATE_DEF_SEL(setMeshTextures_withRange_,
    "setMeshTextures:withRange:");
_MTL_PRIVATE_DEF_SEL(setMeshThreadgroupSizeIsMultipleOfThreadExecutionWidth_,
    "setMeshThreadgroupSizeIsMultipleOfThreadExecutionWidth:");
_MTL_PRIVATE_DEF_SEL(setMinFilter_,
    "setMinFilter:");
_MTL_PRIVATE_DEF_SEL(setMipFilter_,
    "setMipFilter:");
_MTL_PRIVATE_DEF_SEL(setMipmapLevelCount_,
    "setMipmapLevelCount:");
_MTL_PRIVATE_DEF_SEL(setMotionEndBorderMode_,
    "setMotionEndBorderMode:");
_MTL_PRIVATE_DEF_SEL(setMotionEndTime_,
    "setMotionEndTime:");
_MTL_PRIVATE_DEF_SEL(setMotionKeyframeCount_,
    "setMotionKeyframeCount:");
_MTL_PRIVATE_DEF_SEL(setMotionStartBorderMode_,
    "setMotionStartBorderMode:");
_MTL_PRIVATE_DEF_SEL(setMotionStartTime_,
    "setMotionStartTime:");
_MTL_PRIVATE_DEF_SEL(setMotionTransformBuffer_,
    "setMotionTransformBuffer:");
_MTL_PRIVATE_DEF_SEL(setMotionTransformBufferOffset_,
    "setMotionTransformBufferOffset:");
_MTL_PRIVATE_DEF_SEL(setMotionTransformCount_,
    "setMotionTransformCount:");
_MTL_PRIVATE_DEF_SEL(setMotionTransformCountBuffer_,
    "setMotionTransformCountBuffer:");
_MTL_PRIVATE_DEF_SEL(setMotionTransformCountBufferOffset_,
    "setMotionTransformCountBufferOffset:");
_MTL_PRIVATE_DEF_SEL(setMotionTransformStride_,
    "setMotionTransformStride:");
_MTL_PRIVATE_DEF_SEL(setMotionTransformType_,
    "setMotionTransformType:");
_MTL_PRIVATE_DEF_SEL(setMutability_,
    "setMutability:");
_MTL_PRIVATE_DEF_SEL(setName_,
    "setName:");
_MTL_PRIVATE_DEF_SEL(setNodes_,
    "setNodes:");
_MTL_PRIVATE_DEF_SEL(setNormalizedCoordinates_,
    "setNormalizedCoordinates:");
_MTL_PRIVATE_DEF_SEL(setObject_atIndexedSubscript_,
    "setObject:atIndexedSubscript:");
_MTL_PRIVATE_DEF_SEL(setObjectAdditionalBinaryFunctions_,
    "setObjectAdditionalBinaryFunctions:");
_MTL_PRIVATE_DEF_SEL(setObjectBuffer_offset_atIndex_,
    "setObjectBuffer:offset:atIndex:");
_MTL_PRIVATE_DEF_SEL(setObjectBufferOffset_atIndex_,
    "setObjectBufferOffset:atIndex:");
_MTL_PRIVATE_DEF_SEL(setObjectBuffers_offsets_withRange_,
    "setObjectBuffers:offsets:withRange:");
_MTL_PRIVATE_DEF_SEL(setObjectBytes_length_atIndex_,
    "setObjectBytes:length:atIndex:");
_MTL_PRIVATE_DEF_SEL(setObjectFunction_,
    "setObjectFunction:");
_MTL_PRIVATE_DEF_SEL(setObjectFunctionDescriptor_,
    "setObjectFunctionDescriptor:");
_MTL_PRIVATE_DEF_SEL(setObjectLinkedFunctions_,
    "setObjectLinkedFunctions:");
_MTL_PRIVATE_DEF_SEL(setObjectSamplerState_atIndex_,
    "setObjectSamplerState:atIndex:");
_MTL_PRIVATE_DEF_SEL(setObjectSamplerState_lodMinClamp_lodMaxClamp_atIndex_,
    "setObjectSamplerState:lodMinClamp:lodMaxClamp:atIndex:");
_MTL_PRIVATE_DEF_SEL(setObjectSamplerStates_lodMinClamps_lodMaxClamps_withRange_,
    "setObjectSamplerStates:lodMinClamps:lodMaxClamps:withRange:");
_MTL_PRIVATE_DEF_SEL(setObjectSamplerStates_withRange_,
    "setObjectSamplerStates:withRange:");
_MTL_PRIVATE_DEF_SEL(setObjectStaticLinkingDescriptor_,
    "setObjectStaticLinkingDescriptor:");
_MTL_PRIVATE_DEF_SEL(setObjectTexture_atIndex_,
    "setObjectTexture:atIndex:");
_MTL_PRIVATE_DEF_SEL(setObjectTextures_withRange_,
    "setObjectTextures:withRange:");
_MTL_PRIVATE_DEF_SEL(setObjectThreadgroupMemoryLength_atIndex_,
    "setObjectThreadgroupMemoryLength:atIndex:");
_MTL_PRIVATE_DEF_SEL(setObjectThreadgroupSizeIsMultipleOfThreadExecutionWidth_,
    "setObjectThreadgroupSizeIsMultipleOfThreadExecutionWidth:");
_MTL_PRIVATE_DEF_SEL(setOffset_,
    "setOffset:");
_MTL_PRIVATE_DEF_SEL(setOpaque_,
    "setOpaque:");
_MTL_PRIVATE_DEF_SEL(setOpaqueCurveIntersectionFunctionWithSignature_atIndex_,
    "setOpaqueCurveIntersectionFunctionWithSignature:atIndex:");
_MTL_PRIVATE_DEF_SEL(setOpaqueCurveIntersectionFunctionWithSignature_withRange_,
    "setOpaqueCurveIntersectionFunctionWithSignature:withRange:");
_MTL_PRIVATE_DEF_SEL(setOpaqueTriangleIntersectionFunctionWithSignature_atIndex_,
    "setOpaqueTriangleIntersectionFunctionWithSignature:atIndex:");
_MTL_PRIVATE_DEF_SEL(setOpaqueTriangleIntersectionFunctionWithSignature_withRange_,
    "setOpaqueTriangleIntersectionFunctionWithSignature:withRange:");
_MTL_PRIVATE_DEF_SEL(setOptimizationLevel_,
    "setOptimizationLevel:");
_MTL_PRIVATE_DEF_SEL(setOptions_,
    "setOptions:");
_MTL_PRIVATE_DEF_SEL(setOutputNode_,
    "setOutputNode:");
_MTL_PRIVATE_DEF_SEL(setOutputURL_,
    "setOutputURL:");
_MTL_PRIVATE_DEF_SEL(setOwnerWithIdentity_,
    "setOwnerWithIdentity:");
_MTL_PRIVATE_DEF_SEL(setPayloadMemoryLength_,
    "setPayloadMemoryLength:");
_MTL_PRIVATE_DEF_SEL(setPhysicalIndex_forLogicalIndex_,
    "setPhysicalIndex:forLogicalIndex:");
_MTL_PRIVATE_DEF_SEL(setPipelineDataSetSerializer_,
    "setPipelineDataSetSerializer:");
_MTL_PRIVATE_DEF_SEL(setPipelineState_,
    "setPipelineState:");
_MTL_PRIVATE_DEF_SEL(setPixelFormat_,
    "setPixelFormat:");
_MTL_PRIVATE_DEF_SEL(setPlacementSparsePageSize_,
    "setPlacementSparsePageSize:");
_MTL_PRIVATE_DEF_SEL(setPreloadedLibraries_,
    "setPreloadedLibraries:");
_MTL_PRIVATE_DEF_SEL(setPreprocessorMacros_,
    "setPreprocessorMacros:");
_MTL_PRIVATE_DEF_SEL(setPreserveInvariance_,
    "setPreserveInvariance:");
_MTL_PRIVATE_DEF_SEL(setPrimitiveDataBuffer_,
    "setPrimitiveDataBuffer:");
_MTL_PRIVATE_DEF_SEL(setPrimitiveDataBufferOffset_,
    "setPrimitiveDataBufferOffset:");
_MTL_PRIVATE_DEF_SEL(setPrimitiveDataElementSize_,
    "setPrimitiveDataElementSize:");
_MTL_PRIVATE_DEF_SEL(setPrimitiveDataStride_,
    "setPrimitiveDataStride:");
_MTL_PRIVATE_DEF_SEL(setPriority_,
    "setPriority:");
_MTL_PRIVATE_DEF_SEL(setPrivateFunctionDescriptors_,
    "setPrivateFunctionDescriptors:");
_MTL_PRIVATE_DEF_SEL(setPrivateFunctions_,
    "setPrivateFunctions:");
_MTL_PRIVATE_DEF_SEL(setPurgeableState_,
    "setPurgeableState:");
_MTL_PRIVATE_DEF_SEL(setRAddressMode_,
    "setRAddressMode:");
_MTL_PRIVATE_DEF_SEL(setRadiusBuffer_,
    "setRadiusBuffer:");
_MTL_PRIVATE_DEF_SEL(setRadiusBufferOffset_,
    "setRadiusBufferOffset:");
_MTL_PRIVATE_DEF_SEL(setRadiusBuffers_,
    "setRadiusBuffers:");
_MTL_PRIVATE_DEF_SEL(setRadiusFormat_,
    "setRadiusFormat:");
_MTL_PRIVATE_DEF_SEL(setRadiusStride_,
    "setRadiusStride:");
_MTL_PRIVATE_DEF_SEL(setRasterSampleCount_,
    "setRasterSampleCount:");
_MTL_PRIVATE_DEF_SEL(setRasterizationEnabled_,
    "setRasterizationEnabled:");
_MTL_PRIVATE_DEF_SEL(setRasterizationRateMap_,
    "setRasterizationRateMap:");
_MTL_PRIVATE_DEF_SEL(setReadMask_,
    "setReadMask:");
_MTL_PRIVATE_DEF_SEL(setReductionMode_,
    "setReductionMode:");
_MTL_PRIVATE_DEF_SEL(setRenderPipelineState_,
    "setRenderPipelineState:");
_MTL_PRIVATE_DEF_SEL(setRenderPipelineState_atIndex_,
    "setRenderPipelineState:atIndex:");
_MTL_PRIVATE_DEF_SEL(setRenderPipelineStates_withRange_,
    "setRenderPipelineStates:withRange:");
_MTL_PRIVATE_DEF_SEL(setRenderTargetArrayLength_,
    "setRenderTargetArrayLength:");
_MTL_PRIVATE_DEF_SEL(setRenderTargetHeight_,
    "setRenderTargetHeight:");
_MTL_PRIVATE_DEF_SEL(setRenderTargetWidth_,
    "setRenderTargetWidth:");
_MTL_PRIVATE_DEF_SEL(setRequiredThreadsPerMeshThreadgroup_,
    "setRequiredThreadsPerMeshThreadgroup:");
_MTL_PRIVATE_DEF_SEL(setRequiredThreadsPerObjectThreadgroup_,
    "setRequiredThreadsPerObjectThreadgroup:");
_MTL_PRIVATE_DEF_SEL(setRequiredThreadsPerThreadgroup_,
    "setRequiredThreadsPerThreadgroup:");
_MTL_PRIVATE_DEF_SEL(setResolveDepthPlane_,
    "setResolveDepthPlane:");
_MTL_PRIVATE_DEF_SEL(setResolveLevel_,
    "setResolveLevel:");
_MTL_PRIVATE_DEF_SEL(setResolveSlice_,
    "setResolveSlice:");
_MTL_PRIVATE_DEF_SEL(setResolveTexture_,
    "setResolveTexture:");
_MTL_PRIVATE_DEF_SEL(setResource_atBufferIndex_,
    "setResource:atBufferIndex:");
_MTL_PRIVATE_DEF_SEL(setResourceOptions_,
    "setResourceOptions:");
_MTL_PRIVATE_DEF_SEL(setResourceViewCount_,
    "setResourceViewCount:");
_MTL_PRIVATE_DEF_SEL(setRetainedReferences_,
    "setRetainedReferences:");
_MTL_PRIVATE_DEF_SEL(setRgbBlendOperation_,
    "setRgbBlendOperation:");
_MTL_PRIVATE_DEF_SEL(setSAddressMode_,
    "setSAddressMode:");
_MTL_PRIVATE_DEF_SEL(setSampleBuffer_,
    "setSampleBuffer:");
_MTL_PRIVATE_DEF_SEL(setSampleCount_,
    "setSampleCount:");
_MTL_PRIVATE_DEF_SEL(setSamplePositions_count_,
    "setSamplePositions:count:");
_MTL_PRIVATE_DEF_SEL(setSamplerState_atIndex_,
    "setSamplerState:atIndex:");
_MTL_PRIVATE_DEF_SEL(setSamplerState_lodMinClamp_lodMaxClamp_atIndex_,
    "setSamplerState:lodMinClamp:lodMaxClamp:atIndex:");
_MTL_PRIVATE_DEF_SEL(setSamplerStates_lodMinClamps_lodMaxClamps_withRange_,
    "setSamplerStates:lodMinClamps:lodMaxClamps:withRange:");
_MTL_PRIVATE_DEF_SEL(setSamplerStates_withRange_,
    "setSamplerStates:withRange:");
_MTL_PRIVATE_DEF_SEL(setScissorRect_,
    "setScissorRect:");
_MTL_PRIVATE_DEF_SEL(setScissorRects_count_,
    "setScissorRects:count:");
_MTL_PRIVATE_DEF_SEL(setScratchBufferAllocator_,
    "setScratchBufferAllocator:");
_MTL_PRIVATE_DEF_SEL(setScreenSize_,
    "setScreenSize:");
_MTL_PRIVATE_DEF_SEL(setSegmentControlPointCount_,
    "setSegmentControlPointCount:");
_MTL_PRIVATE_DEF_SEL(setSegmentCount_,
    "setSegmentCount:");
_MTL_PRIVATE_DEF_SEL(setShaderReflection_,
    "setShaderReflection:");
_MTL_PRIVATE_DEF_SEL(setShaderValidation_,
    "setShaderValidation:");
_MTL_PRIVATE_DEF_SEL(setShouldMaximizeConcurrentCompilation_,
    "setShouldMaximizeConcurrentCompilation:");
_MTL_PRIVATE_DEF_SEL(setSignaledValue_,
    "setSignaledValue:");
_MTL_PRIVATE_DEF_SEL(setSize_,
    "setSize:");
_MTL_PRIVATE_DEF_SEL(setSlice_,
    "setSlice:");
_MTL_PRIVATE_DEF_SEL(setSliceRange_,
    "setSliceRange:");
_MTL_PRIVATE_DEF_SEL(setSource_,
    "setSource:");
_MTL_PRIVATE_DEF_SEL(setSourceAlphaBlendFactor_,
    "setSourceAlphaBlendFactor:");
_MTL_PRIVATE_DEF_SEL(setSourceRGBBlendFactor_,
    "setSourceRGBBlendFactor:");
_MTL_PRIVATE_DEF_SEL(setSparsePageSize_,
    "setSparsePageSize:");
_MTL_PRIVATE_DEF_SEL(setSpecializedName_,
    "setSpecializedName:");
_MTL_PRIVATE_DEF_SEL(setStageInRegion_,
    "setStageInRegion:");
_MTL_PRIVATE_DEF_SEL(setStageInRegionWithIndirectBuffer_indirectBufferOffset_,
    "setStageInRegionWithIndirectBuffer:indirectBufferOffset:");
_MTL_PRIVATE_DEF_SEL(setStageInputDescriptor_,
    "setStageInputDescriptor:");
_MTL_PRIVATE_DEF_SEL(setStartOfEncoderSampleIndex_,
    "setStartOfEncoderSampleIndex:");
_MTL_PRIVATE_DEF_SEL(setStartOfFragmentSampleIndex_,
    "setStartOfFragmentSampleIndex:");
_MTL_PRIVATE_DEF_SEL(setStartOfVertexSampleIndex_,
    "setStartOfVertexSampleIndex:");
_MTL_PRIVATE_DEF_SEL(setStaticLinkingDescriptor_,
    "setStaticLinkingDescriptor:");
_MTL_PRIVATE_DEF_SEL(setStencilAttachment_,
    "setStencilAttachment:");
_MTL_PRIVATE_DEF_SEL(setStencilAttachmentPixelFormat_,
    "setStencilAttachmentPixelFormat:");
_MTL_PRIVATE_DEF_SEL(setStencilCompareFunction_,
    "setStencilCompareFunction:");
_MTL_PRIVATE_DEF_SEL(setStencilFailureOperation_,
    "setStencilFailureOperation:");
_MTL_PRIVATE_DEF_SEL(setStencilFrontReferenceValue_backReferenceValue_,
    "setStencilFrontReferenceValue:backReferenceValue:");
_MTL_PRIVATE_DEF_SEL(setStencilReferenceValue_,
    "setStencilReferenceValue:");
_MTL_PRIVATE_DEF_SEL(setStencilResolveFilter_,
    "setStencilResolveFilter:");
_MTL_PRIVATE_DEF_SEL(setStencilStoreAction_,
    "setStencilStoreAction:");
_MTL_PRIVATE_DEF_SEL(setStencilStoreActionOptions_,
    "setStencilStoreActionOptions:");
_MTL_PRIVATE_DEF_SEL(setStepFunction_,
    "setStepFunction:");
_MTL_PRIVATE_DEF_SEL(setStepRate_,
    "setStepRate:");
_MTL_PRIVATE_DEF_SEL(setStorageMode_,
    "setStorageMode:");
_MTL_PRIVATE_DEF_SEL(setStoreAction_,
    "setStoreAction:");
_MTL_PRIVATE_DEF_SEL(setStoreActionOptions_,
    "setStoreActionOptions:");
_MTL_PRIVATE_DEF_SEL(setStride_,
    "setStride:");
_MTL_PRIVATE_DEF_SEL(setStrides_,
    "setStrides:");
_MTL_PRIVATE_DEF_SEL(setSupportAddingBinaryFunctions_,
    "setSupportAddingBinaryFunctions:");
_MTL_PRIVATE_DEF_SEL(setSupportAddingFragmentBinaryFunctions_,
    "setSupportAddingFragmentBinaryFunctions:");
_MTL_PRIVATE_DEF_SEL(setSupportAddingVertexBinaryFunctions_,
    "setSupportAddingVertexBinaryFunctions:");
_MTL_PRIVATE_DEF_SEL(setSupportArgumentBuffers_,
    "setSupportArgumentBuffers:");
_MTL_PRIVATE_DEF_SEL(setSupportAttributeStrides_,
    "setSupportAttributeStrides:");
_MTL_PRIVATE_DEF_SEL(setSupportBinaryLinking_,
    "setSupportBinaryLinking:");
_MTL_PRIVATE_DEF_SEL(setSupportColorAttachmentMapping_,
    "setSupportColorAttachmentMapping:");
_MTL_PRIVATE_DEF_SEL(setSupportDynamicAttributeStride_,
    "setSupportDynamicAttributeStride:");
_MTL_PRIVATE_DEF_SEL(setSupportFragmentBinaryLinking_,
    "setSupportFragmentBinaryLinking:");
_MTL_PRIVATE_DEF_SEL(setSupportIndirectCommandBuffers_,
    "setSupportIndirectCommandBuffers:");
_MTL_PRIVATE_DEF_SEL(setSupportMeshBinaryLinking_,
    "setSupportMeshBinaryLinking:");
_MTL_PRIVATE_DEF_SEL(setSupportObjectBinaryLinking_,
    "setSupportObjectBinaryLinking:");
_MTL_PRIVATE_DEF_SEL(setSupportRayTracing_,
    "setSupportRayTracing:");
_MTL_PRIVATE_DEF_SEL(setSupportVertexBinaryLinking_,
    "setSupportVertexBinaryLinking:");
_MTL_PRIVATE_DEF_SEL(setSwizzle_,
    "setSwizzle:");
_MTL_PRIVATE_DEF_SEL(setTAddressMode_,
    "setTAddressMode:");
_MTL_PRIVATE_DEF_SEL(setTessellationControlPointIndexType_,
    "setTessellationControlPointIndexType:");
_MTL_PRIVATE_DEF_SEL(setTessellationFactorBuffer_offset_instanceStride_,
    "setTessellationFactorBuffer:offset:instanceStride:");
_MTL_PRIVATE_DEF_SEL(setTessellationFactorFormat_,
    "setTessellationFactorFormat:");
_MTL_PRIVATE_DEF_SEL(setTessellationFactorScale_,
    "setTessellationFactorScale:");
_MTL_PRIVATE_DEF_SEL(setTessellationFactorScaleEnabled_,
    "setTessellationFactorScaleEnabled:");
_MTL_PRIVATE_DEF_SEL(setTessellationFactorStepFunction_,
    "setTessellationFactorStepFunction:");
_MTL_PRIVATE_DEF_SEL(setTessellationOutputWindingOrder_,
    "setTessellationOutputWindingOrder:");
_MTL_PRIVATE_DEF_SEL(setTessellationPartitionMode_,
    "setTessellationPartitionMode:");
_MTL_PRIVATE_DEF_SEL(setTexture_,
    "setTexture:");
_MTL_PRIVATE_DEF_SEL(setTexture_atIndex_,
    "setTexture:atIndex:");
_MTL_PRIVATE_DEF_SEL(setTextureType_,
    "setTextureType:");
_MTL_PRIVATE_DEF_SEL(setTextureView_atIndex_,
    "setTextureView:atIndex:");
_MTL_PRIVATE_DEF_SEL(setTextureView_descriptor_atIndex_,
    "setTextureView:descriptor:atIndex:");
_MTL_PRIVATE_DEF_SEL(setTextureViewFromBuffer_descriptor_offset_bytesPerRow_atIndex_,
    "setTextureViewFromBuffer:descriptor:offset:bytesPerRow:atIndex:");
_MTL_PRIVATE_DEF_SEL(setTextures_withRange_,
    "setTextures:withRange:");
_MTL_PRIVATE_DEF_SEL(setThreadGroupSizeIsMultipleOfThreadExecutionWidth_,
    "setThreadGroupSizeIsMultipleOfThreadExecutionWidth:");
_MTL_PRIVATE_DEF_SEL(setThreadgroupMemoryLength_,
    "setThreadgroupMemoryLength:");
_MTL_PRIVATE_DEF_SEL(setThreadgroupMemoryLength_atIndex_,
    "setThreadgroupMemoryLength:atIndex:");
_MTL_PRIVATE_DEF_SEL(setThreadgroupMemoryLength_offset_atIndex_,
    "setThreadgroupMemoryLength:offset:atIndex:");
_MTL_PRIVATE_DEF_SEL(setThreadgroupSizeMatchesTileSize_,
    "setThreadgroupSizeMatchesTileSize:");
_MTL_PRIVATE_DEF_SEL(setTileAccelerationStructure_atBufferIndex_,
    "setTileAccelerationStructure:atBufferIndex:");
_MTL_PRIVATE_DEF_SEL(setTileAdditionalBinaryFunctions_,
    "setTileAdditionalBinaryFunctions:");
_MTL_PRIVATE_DEF_SEL(setTileBuffer_offset_atIndex_,
    "setTileBuffer:offset:atIndex:");
_MTL_PRIVATE_DEF_SEL(setTileBufferOffset_atIndex_,
    "setTileBufferOffset:atIndex:");
_MTL_PRIVATE_DEF_SEL(setTileBuffers_offsets_withRange_,
    "setTileBuffers:offsets:withRange:");
_MTL_PRIVATE_DEF_SEL(setTileBytes_length_atIndex_,
    "setTileBytes:length:atIndex:");
_MTL_PRIVATE_DEF_SEL(setTileFunction_,
    "setTileFunction:");
_MTL_PRIVATE_DEF_SEL(setTileFunctionDescriptor_,
    "setTileFunctionDescriptor:");
_MTL_PRIVATE_DEF_SEL(setTileHeight_,
    "setTileHeight:");
_MTL_PRIVATE_DEF_SEL(setTileIntersectionFunctionTable_atBufferIndex_,
    "setTileIntersectionFunctionTable:atBufferIndex:");
_MTL_PRIVATE_DEF_SEL(setTileIntersectionFunctionTables_withBufferRange_,
    "setTileIntersectionFunctionTables:withBufferRange:");
_MTL_PRIVATE_DEF_SEL(setTileSamplerState_atIndex_,
    "setTileSamplerState:atIndex:");
_MTL_PRIVATE_DEF_SEL(setTileSamplerState_lodMinClamp_lodMaxClamp_atIndex_,
    "setTileSamplerState:lodMinClamp:lodMaxClamp:atIndex:");
_MTL_PRIVATE_DEF_SEL(setTileSamplerStates_lodMinClamps_lodMaxClamps_withRange_,
    "setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange:");
_MTL_PRIVATE_DEF_SEL(setTileSamplerStates_withRange_,
    "setTileSamplerStates:withRange:");
_MTL_PRIVATE_DEF_SEL(setTileTexture_atIndex_,
    "setTileTexture:atIndex:");
_MTL_PRIVATE_DEF_SEL(setTileTextures_withRange_,
    "setTileTextures:withRange:");
_MTL_PRIVATE_DEF_SEL(setTileVisibleFunctionTable_atBufferIndex_,
    "setTileVisibleFunctionTable:atBufferIndex:");
_MTL_PRIVATE_DEF_SEL(setTileVisibleFunctionTables_withBufferRange_,
    "setTileVisibleFunctionTables:withBufferRange:");
_MTL_PRIVATE_DEF_SEL(setTileWidth_,
    "setTileWidth:");
_MTL_PRIVATE_DEF_SEL(setTransformationMatrixBuffer_,
    "setTransformationMatrixBuffer:");
_MTL_PRIVATE_DEF_SEL(setTransformationMatrixBufferOffset_,
    "setTransformationMatrixBufferOffset:");
_MTL_PRIVATE_DEF_SEL(setTransformationMatrixLayout_,
    "setTransformationMatrixLayout:");
_MTL_PRIVATE_DEF_SEL(setTriangleCount_,
    "setTriangleCount:");
_MTL_PRIVATE_DEF_SEL(setTriangleFillMode_,
    "setTriangleFillMode:");
_MTL_PRIVATE_DEF_SEL(setType_,
    "setType:");
_MTL_PRIVATE_DEF_SEL(setUrl_,
    "setUrl:");
_MTL_PRIVATE_DEF_SEL(setUsage_,
    "setUsage:");
_MTL_PRIVATE_DEF_SEL(setVertexAccelerationStructure_atBufferIndex_,
    "setVertexAccelerationStructure:atBufferIndex:");
_MTL_PRIVATE_DEF_SEL(setVertexAdditionalBinaryFunctions_,
    "setVertexAdditionalBinaryFunctions:");
_MTL_PRIVATE_DEF_SEL(setVertexAmplificationCount_viewMappings_,
    "setVertexAmplificationCount:viewMappings:");
_MTL_PRIVATE_DEF_SEL(setVertexBuffer_,
    "setVertexBuffer:");
_MTL_PRIVATE_DEF_SEL(setVertexBuffer_offset_atIndex_,
    "setVertexBuffer:offset:atIndex:");
_MTL_PRIVATE_DEF_SEL(setVertexBuffer_offset_attributeStride_atIndex_,
    "setVertexBuffer:offset:attributeStride:atIndex:");
_MTL_PRIVATE_DEF_SEL(setVertexBufferOffset_,
    "setVertexBufferOffset:");
_MTL_PRIVATE_DEF_SEL(setVertexBufferOffset_atIndex_,
    "setVertexBufferOffset:atIndex:");
_MTL_PRIVATE_DEF_SEL(setVertexBufferOffset_attributeStride_atIndex_,
    "setVertexBufferOffset:attributeStride:atIndex:");
_MTL_PRIVATE_DEF_SEL(setVertexBuffers_,
    "setVertexBuffers:");
_MTL_PRIVATE_DEF_SEL(setVertexBuffers_offsets_attributeStrides_withRange_,
    "setVertexBuffers:offsets:attributeStrides:withRange:");
_MTL_PRIVATE_DEF_SEL(setVertexBuffers_offsets_withRange_,
    "setVertexBuffers:offsets:withRange:");
_MTL_PRIVATE_DEF_SEL(setVertexBytes_length_atIndex_,
    "setVertexBytes:length:atIndex:");
_MTL_PRIVATE_DEF_SEL(setVertexBytes_length_attributeStride_atIndex_,
    "setVertexBytes:length:attributeStride:atIndex:");
_MTL_PRIVATE_DEF_SEL(setVertexDescriptor_,
    "setVertexDescriptor:");
_MTL_PRIVATE_DEF_SEL(setVertexFormat_,
    "setVertexFormat:");
_MTL_PRIVATE_DEF_SEL(setVertexFunction_,
    "setVertexFunction:");
_MTL_PRIVATE_DEF_SEL(setVertexFunctionDescriptor_,
    "setVertexFunctionDescriptor:");
_MTL_PRIVATE_DEF_SEL(setVertexIntersectionFunctionTable_atBufferIndex_,
    "setVertexIntersectionFunctionTable:atBufferIndex:");
_MTL_PRIVATE_DEF_SEL(setVertexIntersectionFunctionTables_withBufferRange_,
    "setVertexIntersectionFunctionTables:withBufferRange:");
_MTL_PRIVATE_DEF_SEL(setVertexLinkedFunctions_,
    "setVertexLinkedFunctions:");
_MTL_PRIVATE_DEF_SEL(setVertexPreloadedLibraries_,
    "setVertexPreloadedLibraries:");
_MTL_PRIVATE_DEF_SEL(setVertexSamplerState_atIndex_,
    "setVertexSamplerState:atIndex:");
_MTL_PRIVATE_DEF_SEL(setVertexSamplerState_lodMinClamp_lodMaxClamp_atIndex_,
    "setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:");
_MTL_PRIVATE_DEF_SEL(setVertexSamplerStates_lodMinClamps_lodMaxClamps_withRange_,
    "setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:");
_MTL_PRIVATE_DEF_SEL(setVertexSamplerStates_withRange_,
    "setVertexSamplerStates:withRange:");
_MTL_PRIVATE_DEF_SEL(setVertexStaticLinkingDescriptor_,
    "setVertexStaticLinkingDescriptor:");
_MTL_PRIVATE_DEF_SEL(setVertexStride_,
    "setVertexStride:");
_MTL_PRIVATE_DEF_SEL(setVertexTexture_atIndex_,
    "setVertexTexture:atIndex:");
_MTL_PRIVATE_DEF_SEL(setVertexTextures_withRange_,
    "setVertexTextures:withRange:");
_MTL_PRIVATE_DEF_SEL(setVertexVisibleFunctionTable_atBufferIndex_,
    "setVertexVisibleFunctionTable:atBufferIndex:");
_MTL_PRIVATE_DEF_SEL(setVertexVisibleFunctionTables_withBufferRange_,
    "setVertexVisibleFunctionTables:withBufferRange:");
_MTL_PRIVATE_DEF_SEL(setViewport_,
    "setViewport:");
_MTL_PRIVATE_DEF_SEL(setViewports_count_,
    "setViewports:count:");
_MTL_PRIVATE_DEF_SEL(setVisibilityResultBuffer_,
    "setVisibilityResultBuffer:");
_MTL_PRIVATE_DEF_SEL(setVisibilityResultMode_offset_,
    "setVisibilityResultMode:offset:");
_MTL_PRIVATE_DEF_SEL(setVisibilityResultType_,
    "setVisibilityResultType:");
_MTL_PRIVATE_DEF_SEL(setVisibleFunctionTable_atBufferIndex_,
    "setVisibleFunctionTable:atBufferIndex:");
_MTL_PRIVATE_DEF_SEL(setVisibleFunctionTable_atIndex_,
    "setVisibleFunctionTable:atIndex:");
_MTL_PRIVATE_DEF_SEL(setVisibleFunctionTables_withBufferRange_,
    "setVisibleFunctionTables:withBufferRange:");
_MTL_PRIVATE_DEF_SEL(setVisibleFunctionTables_withRange_,
    "setVisibleFunctionTables:withRange:");
_MTL_PRIVATE_DEF_SEL(setWidth_,
    "setWidth:");
_MTL_PRIVATE_DEF_SEL(setWriteMask_,
    "setWriteMask:");
_MTL_PRIVATE_DEF_SEL(shaderReflection,
    "shaderReflection");
_MTL_PRIVATE_DEF_SEL(shaderValidation,
    "shaderValidation");
_MTL_PRIVATE_DEF_SEL(sharedCaptureManager,
    "sharedCaptureManager");
_MTL_PRIVATE_DEF_SEL(sharedListener,
    "sharedListener");
_MTL_PRIVATE_DEF_SEL(shouldMaximizeConcurrentCompilation,
    "shouldMaximizeConcurrentCompilation");
_MTL_PRIVATE_DEF_SEL(signalDrawable_,
    "signalDrawable:");
_MTL_PRIVATE_DEF_SEL(signalEvent_value_,
    "signalEvent:value:");
_MTL_PRIVATE_DEF_SEL(signaledValue,
    "signaledValue");
_MTL_PRIVATE_DEF_SEL(size,
    "size");
_MTL_PRIVATE_DEF_SEL(sizeOfCounterHeapEntry_,
    "sizeOfCounterHeapEntry:");
_MTL_PRIVATE_DEF_SEL(slice,
    "slice");
_MTL_PRIVATE_DEF_SEL(sliceRange,
    "sliceRange");
_MTL_PRIVATE_DEF_SEL(source,
    "source");
_MTL_PRIVATE_DEF_SEL(sourceAlphaBlendFactor,
    "sourceAlphaBlendFactor");
_MTL_PRIVATE_DEF_SEL(sourceRGBBlendFactor,
    "sourceRGBBlendFactor");
_MTL_PRIVATE_DEF_SEL(sparseBufferTier,
    "sparseBufferTier");
_MTL_PRIVATE_DEF_SEL(sparsePageSize,
    "sparsePageSize");
_MTL_PRIVATE_DEF_SEL(sparseTextureTier,
    "sparseTextureTier");
_MTL_PRIVATE_DEF_SEL(sparseTileSizeInBytes,
    "sparseTileSizeInBytes");
_MTL_PRIVATE_DEF_SEL(sparseTileSizeInBytesForSparsePageSize_,
    "sparseTileSizeInBytesForSparsePageSize:");
_MTL_PRIVATE_DEF_SEL(sparseTileSizeWithTextureType_pixelFormat_sampleCount_,
    "sparseTileSizeWithTextureType:pixelFormat:sampleCount:");
_MTL_PRIVATE_DEF_SEL(sparseTileSizeWithTextureType_pixelFormat_sampleCount_sparsePageSize_,
    "sparseTileSizeWithTextureType:pixelFormat:sampleCount:sparsePageSize:");
_MTL_PRIVATE_DEF_SEL(specializedName,
    "specializedName");
_MTL_PRIVATE_DEF_SEL(stageInputAttributes,
    "stageInputAttributes");
_MTL_PRIVATE_DEF_SEL(stageInputDescriptor,
    "stageInputDescriptor");
_MTL_PRIVATE_DEF_SEL(stageInputOutputDescriptor,
    "stageInputOutputDescriptor");
_MTL_PRIVATE_DEF_SEL(stages,
    "stages");
_MTL_PRIVATE_DEF_SEL(startCaptureWithCommandQueue_,
    "startCaptureWithCommandQueue:");
_MTL_PRIVATE_DEF_SEL(startCaptureWithDescriptor_error_,
    "startCaptureWithDescriptor:error:");
_MTL_PRIVATE_DEF_SEL(startCaptureWithDevice_,
    "startCaptureWithDevice:");
_MTL_PRIVATE_DEF_SEL(startCaptureWithScope_,
    "startCaptureWithScope:");
_MTL_PRIVATE_DEF_SEL(startOfEncoderSampleIndex,
    "startOfEncoderSampleIndex");
_MTL_PRIVATE_DEF_SEL(startOfFragmentSampleIndex,
    "startOfFragmentSampleIndex");
_MTL_PRIVATE_DEF_SEL(startOfVertexSampleIndex,
    "startOfVertexSampleIndex");
_MTL_PRIVATE_DEF_SEL(staticLinkingDescriptor,
    "staticLinkingDescriptor");
_MTL_PRIVATE_DEF_SEL(staticThreadgroupMemoryLength,
    "staticThreadgroupMemoryLength");
_MTL_PRIVATE_DEF_SEL(status,
    "status");
_MTL_PRIVATE_DEF_SEL(stencilAttachment,
    "stencilAttachment");
_MTL_PRIVATE_DEF_SEL(stencilAttachmentPixelFormat,
    "stencilAttachmentPixelFormat");
_MTL_PRIVATE_DEF_SEL(stencilCompareFunction,
    "stencilCompareFunction");
_MTL_PRIVATE_DEF_SEL(stencilFailureOperation,
    "stencilFailureOperation");
_MTL_PRIVATE_DEF_SEL(stencilResolveFilter,
    "stencilResolveFilter");
_MTL_PRIVATE_DEF_SEL(stepFunction,
    "stepFunction");
_MTL_PRIVATE_DEF_SEL(stepRate,
    "stepRate");
_MTL_PRIVATE_DEF_SEL(stopCapture,
    "stopCapture");
_MTL_PRIVATE_DEF_SEL(storageMode,
    "storageMode");
_MTL_PRIVATE_DEF_SEL(storeAction,
    "storeAction");
_MTL_PRIVATE_DEF_SEL(storeActionOptions,
    "storeActionOptions");
_MTL_PRIVATE_DEF_SEL(stride,
    "stride");
_MTL_PRIVATE_DEF_SEL(strides,
    "strides");
_MTL_PRIVATE_DEF_SEL(structType,
    "structType");
_MTL_PRIVATE_DEF_SEL(supportAddingBinaryFunctions,
    "supportAddingBinaryFunctions");
_MTL_PRIVATE_DEF_SEL(supportAddingFragmentBinaryFunctions,
    "supportAddingFragmentBinaryFunctions");
_MTL_PRIVATE_DEF_SEL(supportAddingVertexBinaryFunctions,
    "supportAddingVertexBinaryFunctions");
_MTL_PRIVATE_DEF_SEL(supportArgumentBuffers,
    "supportArgumentBuffers");
_MTL_PRIVATE_DEF_SEL(supportAttributeStrides,
    "supportAttributeStrides");
_MTL_PRIVATE_DEF_SEL(supportBinaryLinking,
    "supportBinaryLinking");
_MTL_PRIVATE_DEF_SEL(supportColorAttachmentMapping,
    "supportColorAttachmentMapping");
_MTL_PRIVATE_DEF_SEL(supportDynamicAttributeStride,
    "supportDynamicAttributeStride");
_MTL_PRIVATE_DEF_SEL(supportFragmentBinaryLinking,
    "supportFragmentBinaryLinking");
_MTL_PRIVATE_DEF_SEL(supportIndirectCommandBuffers,
    "supportIndirectCommandBuffers");
_MTL_PRIVATE_DEF_SEL(supportMeshBinaryLinking,
    "supportMeshBinaryLinking");
_MTL_PRIVATE_DEF_SEL(supportObjectBinaryLinking,
    "supportObjectBinaryLinking");
_MTL_PRIVATE_DEF_SEL(supportRayTracing,
    "supportRayTracing");
_MTL_PRIVATE_DEF_SEL(supportVertexBinaryLinking,
    "supportVertexBinaryLinking");
_MTL_PRIVATE_DEF_SEL(supports32BitFloatFiltering,
    "supports32BitFloatFiltering");
_MTL_PRIVATE_DEF_SEL(supports32BitMSAA,
    "supports32BitMSAA");
_MTL_PRIVATE_DEF_SEL(supportsBCTextureCompression,
    "supportsBCTextureCompression");
_MTL_PRIVATE_DEF_SEL(supportsCounterSampling_,
    "supportsCounterSampling:");
_MTL_PRIVATE_DEF_SEL(supportsDestination_,
    "supportsDestination:");
_MTL_PRIVATE_DEF_SEL(supportsDynamicLibraries,
    "supportsDynamicLibraries");
_MTL_PRIVATE_DEF_SEL(supportsFamily_,
    "supportsFamily:");
_MTL_PRIVATE_DEF_SEL(supportsFeatureSet_,
    "supportsFeatureSet:");
_MTL_PRIVATE_DEF_SEL(supportsFunctionPointers,
    "supportsFunctionPointers");
_MTL_PRIVATE_DEF_SEL(supportsFunctionPointersFromRender,
    "supportsFunctionPointersFromRender");
_MTL_PRIVATE_DEF_SEL(supportsPrimitiveMotionBlur,
    "supportsPrimitiveMotionBlur");
_MTL_PRIVATE_DEF_SEL(supportsPullModelInterpolation,
    "supportsPullModelInterpolation");
_MTL_PRIVATE_DEF_SEL(supportsQueryTextureLOD,
    "supportsQueryTextureLOD");
_MTL_PRIVATE_DEF_SEL(supportsRasterizationRateMapWithLayerCount_,
    "supportsRasterizationRateMapWithLayerCount:");
_MTL_PRIVATE_DEF_SEL(supportsRaytracing,
    "supportsRaytracing");
_MTL_PRIVATE_DEF_SEL(supportsRaytracingFromRender,
    "supportsRaytracingFromRender");
_MTL_PRIVATE_DEF_SEL(supportsRenderDynamicLibraries,
    "supportsRenderDynamicLibraries");
_MTL_PRIVATE_DEF_SEL(supportsShaderBarycentricCoordinates,
    "supportsShaderBarycentricCoordinates");
_MTL_PRIVATE_DEF_SEL(supportsTextureSampleCount_,
    "supportsTextureSampleCount:");
_MTL_PRIVATE_DEF_SEL(supportsVertexAmplificationCount_,
    "supportsVertexAmplificationCount:");
_MTL_PRIVATE_DEF_SEL(swizzle,
    "swizzle");
_MTL_PRIVATE_DEF_SEL(synchronizeResource_,
    "synchronizeResource:");
_MTL_PRIVATE_DEF_SEL(synchronizeTexture_slice_level_,
    "synchronizeTexture:slice:level:");
_MTL_PRIVATE_DEF_SEL(tAddressMode,
    "tAddressMode");
_MTL_PRIVATE_DEF_SEL(tailSizeInBytes,
    "tailSizeInBytes");
_MTL_PRIVATE_DEF_SEL(tensorDataType,
    "tensorDataType");
_MTL_PRIVATE_DEF_SEL(tensorReferenceType,
    "tensorReferenceType");
_MTL_PRIVATE_DEF_SEL(tensorSizeAndAlignWithDescriptor_,
    "tensorSizeAndAlignWithDescriptor:");
_MTL_PRIVATE_DEF_SEL(tessellationControlPointIndexType,
    "tessellationControlPointIndexType");
_MTL_PRIVATE_DEF_SEL(tessellationFactorFormat,
    "tessellationFactorFormat");
_MTL_PRIVATE_DEF_SEL(tessellationFactorStepFunction,
    "tessellationFactorStepFunction");
_MTL_PRIVATE_DEF_SEL(tessellationOutputWindingOrder,
    "tessellationOutputWindingOrder");
_MTL_PRIVATE_DEF_SEL(tessellationPartitionMode,
    "tessellationPartitionMode");
_MTL_PRIVATE_DEF_SEL(texture,
    "texture");
_MTL_PRIVATE_DEF_SEL(texture2DDescriptorWithPixelFormat_width_height_mipmapped_,
    "texture2DDescriptorWithPixelFormat:width:height:mipmapped:");
_MTL_PRIVATE_DEF_SEL(textureBarrier,
    "textureBarrier");
_MTL_PRIVATE_DEF_SEL(textureBufferDescriptorWithPixelFormat_width_resourceOptions_usage_,
    "textureBufferDescriptorWithPixelFormat:width:resourceOptions:usage:");
_MTL_PRIVATE_DEF_SEL(textureCubeDescriptorWithPixelFormat_size_mipmapped_,
    "textureCubeDescriptorWithPixelFormat:size:mipmapped:");
_MTL_PRIVATE_DEF_SEL(textureDataType,
    "textureDataType");
_MTL_PRIVATE_DEF_SEL(textureReferenceType,
    "textureReferenceType");
_MTL_PRIVATE_DEF_SEL(textureType,
    "textureType");
_MTL_PRIVATE_DEF_SEL(threadExecutionWidth,
    "threadExecutionWidth");
_MTL_PRIVATE_DEF_SEL(threadGroupSizeIsMultipleOfThreadExecutionWidth,
    "threadGroupSizeIsMultipleOfThreadExecutionWidth");
_MTL_PRIVATE_DEF_SEL(threadgroupMemoryAlignment,
    "threadgroupMemoryAlignment");
_MTL_PRIVATE_DEF_SEL(threadgroupMemoryDataSize,
    "threadgroupMemoryDataSize");
_MTL_PRIVATE_DEF_SEL(threadgroupMemoryLength,
    "threadgroupMemoryLength");
_MTL_PRIVATE_DEF_SEL(threadgroupSizeMatchesTileSize,
    "threadgroupSizeMatchesTileSize");
_MTL_PRIVATE_DEF_SEL(tileAdditionalBinaryFunctions,
    "tileAdditionalBinaryFunctions");
_MTL_PRIVATE_DEF_SEL(tileArguments,
    "tileArguments");
_MTL_PRIVATE_DEF_SEL(tileBindings,
    "tileBindings");
_MTL_PRIVATE_DEF_SEL(tileBuffers,
    "tileBuffers");
_MTL_PRIVATE_DEF_SEL(tileFunction,
    "tileFunction");
_MTL_PRIVATE_DEF_SEL(tileFunctionDescriptor,
    "tileFunctionDescriptor");
_MTL_PRIVATE_DEF_SEL(tileHeight,
    "tileHeight");
_MTL_PRIVATE_DEF_SEL(tileLinkingDescriptor,
    "tileLinkingDescriptor");
_MTL_PRIVATE_DEF_SEL(tileWidth,
    "tileWidth");
_MTL_PRIVATE_DEF_SEL(transformationMatrixBuffer,
    "transformationMatrixBuffer");
_MTL_PRIVATE_DEF_SEL(transformationMatrixBufferOffset,
    "transformationMatrixBufferOffset");
_MTL_PRIVATE_DEF_SEL(transformationMatrixLayout,
    "transformationMatrixLayout");
_MTL_PRIVATE_DEF_SEL(triangleCount,
    "triangleCount");
_MTL_PRIVATE_DEF_SEL(tryCancel,
    "tryCancel");
_MTL_PRIVATE_DEF_SEL(type,
    "type");
_MTL_PRIVATE_DEF_SEL(updateBufferMappings_heap_operations_count_,
    "updateBufferMappings:heap:operations:count:");
_MTL_PRIVATE_DEF_SEL(updateFence_,
    "updateFence:");
_MTL_PRIVATE_DEF_SEL(updateFence_afterEncoderStages_,
    "updateFence:afterEncoderStages:");
_MTL_PRIVATE_DEF_SEL(updateFence_afterStages_,
    "updateFence:afterStages:");
_MTL_PRIVATE_DEF_SEL(updateTextureMapping_mode_indirectBuffer_indirectBufferOffset_,
    "updateTextureMapping:mode:indirectBuffer:indirectBufferOffset:");
_MTL_PRIVATE_DEF_SEL(updateTextureMapping_mode_region_mipLevel_slice_,
    "updateTextureMapping:mode:region:mipLevel:slice:");
_MTL_PRIVATE_DEF_SEL(updateTextureMappings_heap_operations_count_,
    "updateTextureMappings:heap:operations:count:");
_MTL_PRIVATE_DEF_SEL(updateTextureMappings_mode_regions_mipLevels_slices_numRegions_,
    "updateTextureMappings:mode:regions:mipLevels:slices:numRegions:");
_MTL_PRIVATE_DEF_SEL(url,
    "url");
_MTL_PRIVATE_DEF_SEL(usage,
    "usage");
_MTL_PRIVATE_DEF_SEL(useHeap_,
    "useHeap:");
_MTL_PRIVATE_DEF_SEL(useHeap_stages_,
    "useHeap:stages:");
_MTL_PRIVATE_DEF_SEL(useHeaps_count_,
    "useHeaps:count:");
_MTL_PRIVATE_DEF_SEL(useHeaps_count_stages_,
    "useHeaps:count:stages:");
_MTL_PRIVATE_DEF_SEL(useResidencySet_,
    "useResidencySet:");
_MTL_PRIVATE_DEF_SEL(useResidencySets_count_,
    "useResidencySets:count:");
_MTL_PRIVATE_DEF_SEL(useResource_usage_,
    "useResource:usage:");
_MTL_PRIVATE_DEF_SEL(useResource_usage_stages_,
    "useResource:usage:stages:");
_MTL_PRIVATE_DEF_SEL(useResources_count_usage_,
    "useResources:count:usage:");
_MTL_PRIVATE_DEF_SEL(useResources_count_usage_stages_,
    "useResources:count:usage:stages:");
_MTL_PRIVATE_DEF_SEL(usedSize,
    "usedSize");
_MTL_PRIVATE_DEF_SEL(vertexAdditionalBinaryFunctions,
    "vertexAdditionalBinaryFunctions");
_MTL_PRIVATE_DEF_SEL(vertexArguments,
    "vertexArguments");
_MTL_PRIVATE_DEF_SEL(vertexAttributes,
    "vertexAttributes");
_MTL_PRIVATE_DEF_SEL(vertexBindings,
    "vertexBindings");
_MTL_PRIVATE_DEF_SEL(vertexBuffer,
    "vertexBuffer");
_MTL_PRIVATE_DEF_SEL(vertexBufferOffset,
    "vertexBufferOffset");
_MTL_PRIVATE_DEF_SEL(vertexBuffers,
    "vertexBuffers");
_MTL_PRIVATE_DEF_SEL(vertexDescriptor,
    "vertexDescriptor");
_MTL_PRIVATE_DEF_SEL(vertexFormat,
    "vertexFormat");
_MTL_PRIVATE_DEF_SEL(vertexFunction,
    "vertexFunction");
_MTL_PRIVATE_DEF_SEL(vertexFunctionDescriptor,
    "vertexFunctionDescriptor");
_MTL_PRIVATE_DEF_SEL(vertexLinkedFunctions,
    "vertexLinkedFunctions");
_MTL_PRIVATE_DEF_SEL(vertexLinkingDescriptor,
    "vertexLinkingDescriptor");
_MTL_PRIVATE_DEF_SEL(vertexPreloadedLibraries,
    "vertexPreloadedLibraries");
_MTL_PRIVATE_DEF_SEL(vertexStaticLinkingDescriptor,
    "vertexStaticLinkingDescriptor");
_MTL_PRIVATE_DEF_SEL(vertexStride,
    "vertexStride");
_MTL_PRIVATE_DEF_SEL(vertical,
    "vertical");
_MTL_PRIVATE_DEF_SEL(verticalSampleStorage,
    "verticalSampleStorage");
_MTL_PRIVATE_DEF_SEL(visibilityResultBuffer,
    "visibilityResultBuffer");
_MTL_PRIVATE_DEF_SEL(visibilityResultType,
    "visibilityResultType");
_MTL_PRIVATE_DEF_SEL(visibleFunctionTableDescriptor,
    "visibleFunctionTableDescriptor");
_MTL_PRIVATE_DEF_SEL(waitForDrawable_,
    "waitForDrawable:");
_MTL_PRIVATE_DEF_SEL(waitForEvent_value_,
    "waitForEvent:value:");
_MTL_PRIVATE_DEF_SEL(waitForFence_,
    "waitForFence:");
_MTL_PRIVATE_DEF_SEL(waitForFence_beforeEncoderStages_,
    "waitForFence:beforeEncoderStages:");
_MTL_PRIVATE_DEF_SEL(waitForFence_beforeStages_,
    "waitForFence:beforeStages:");
_MTL_PRIVATE_DEF_SEL(waitUntilCompleted,
    "waitUntilCompleted");
_MTL_PRIVATE_DEF_SEL(waitUntilScheduled,
    "waitUntilScheduled");
_MTL_PRIVATE_DEF_SEL(waitUntilSignaledValue_timeoutMS_,
    "waitUntilSignaledValue:timeoutMS:");
_MTL_PRIVATE_DEF_SEL(width,
    "width");
_MTL_PRIVATE_DEF_SEL(writeCompactedAccelerationStructureSize_toBuffer_,
    "writeCompactedAccelerationStructureSize:toBuffer:");
_MTL_PRIVATE_DEF_SEL(writeCompactedAccelerationStructureSize_toBuffer_offset_,
    "writeCompactedAccelerationStructureSize:toBuffer:offset:");
_MTL_PRIVATE_DEF_SEL(writeCompactedAccelerationStructureSize_toBuffer_offset_sizeDataType_,
    "writeCompactedAccelerationStructureSize:toBuffer:offset:sizeDataType:");
_MTL_PRIVATE_DEF_SEL(writeMask,
    "writeMask");
_MTL_PRIVATE_DEF_SEL(writeTimestampIntoHeap_atIndex_,
    "writeTimestampIntoHeap:atIndex:");
_MTL_PRIVATE_DEF_SEL(writeTimestampWithGranularity_afterStage_intoHeap_atIndex_,
    "writeTimestampWithGranularity:afterStage:intoHeap:atIndex:");
_MTL_PRIVATE_DEF_SEL(writeTimestampWithGranularity_intoHeap_atIndex_,
    "writeTimestampWithGranularity:intoHeap:atIndex:");

}

#include <CoreFoundation/CoreFoundation.h>

#include <CoreFoundation/CoreFoundation.h>
#include <functional>

namespace MTL
{
class Drawable;

using DrawablePresentedHandler = void (^)(MTL::Drawable*);
using DrawablePresentedHandlerFunction = std::function<void(MTL::Drawable*)>;

class Drawable : public NS::Referencing<Drawable>
{
public:
    void           addPresentedHandler(const MTL::DrawablePresentedHandler block);
    void           addPresentedHandler(const MTL::DrawablePresentedHandlerFunction& function);

    NS::UInteger   drawableID() const;

    void           present();
    void           presentAfterMinimumDuration(CFTimeInterval duration);

    void           presentAtTime(CFTimeInterval presentationTime);

    CFTimeInterval presentedTime() const;
};

}
_MTL_INLINE void MTL::Drawable::addPresentedHandler(const MTL::DrawablePresentedHandler block)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(addPresentedHandler_), block);
}

_MTL_INLINE void MTL::Drawable::addPresentedHandler(const MTL::DrawablePresentedHandlerFunction& function)
{
    __block DrawablePresentedHandlerFunction blockFunction = function;
    addPresentedHandler(^(Drawable* pDrawable) { blockFunction(pDrawable); });
}

_MTL_INLINE NS::UInteger MTL::Drawable::drawableID() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(drawableID));
}

_MTL_INLINE void MTL::Drawable::present()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(present));
}

_MTL_INLINE void MTL::Drawable::presentAfterMinimumDuration(CFTimeInterval duration)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(presentAfterMinimumDuration_), duration);
}

_MTL_INLINE void MTL::Drawable::presentAtTime(CFTimeInterval presentationTime)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(presentAtTime_), presentationTime);
}

_MTL_INLINE CFTimeInterval MTL::Drawable::presentedTime() const
{
    return Object::sendMessage<CFTimeInterval>(this, _MTL_PRIVATE_SEL(presentedTime));
}

#pragma once

#pragma once

namespace MTL
{
_MTL_ENUM(NS::UInteger, PixelFormat) {
    PixelFormatInvalid = 0,
    PixelFormatA8Unorm = 1,
    PixelFormatR8Unorm = 10,
    PixelFormatR8Unorm_sRGB = 11,
    PixelFormatR8Snorm = 12,
    PixelFormatR8Uint = 13,
    PixelFormatR8Sint = 14,
    PixelFormatR16Unorm = 20,
    PixelFormatR16Snorm = 22,
    PixelFormatR16Uint = 23,
    PixelFormatR16Sint = 24,
    PixelFormatR16Float = 25,
    PixelFormatRG8Unorm = 30,
    PixelFormatRG8Unorm_sRGB = 31,
    PixelFormatRG8Snorm = 32,
    PixelFormatRG8Uint = 33,
    PixelFormatRG8Sint = 34,
    PixelFormatB5G6R5Unorm = 40,
    PixelFormatA1BGR5Unorm = 41,
    PixelFormatABGR4Unorm = 42,
    PixelFormatBGR5A1Unorm = 43,
    PixelFormatR32Uint = 53,
    PixelFormatR32Sint = 54,
    PixelFormatR32Float = 55,
    PixelFormatRG16Unorm = 60,
    PixelFormatRG16Snorm = 62,
    PixelFormatRG16Uint = 63,
    PixelFormatRG16Sint = 64,
    PixelFormatRG16Float = 65,
    PixelFormatRGBA8Unorm = 70,
    PixelFormatRGBA8Unorm_sRGB = 71,
    PixelFormatRGBA8Snorm = 72,
    PixelFormatRGBA8Uint = 73,
    PixelFormatRGBA8Sint = 74,
    PixelFormatBGRA8Unorm = 80,
    PixelFormatBGRA8Unorm_sRGB = 81,
    PixelFormatRGB10A2Unorm = 90,
    PixelFormatRGB10A2Uint = 91,
    PixelFormatRG11B10Float = 92,
    PixelFormatRGB9E5Float = 93,
    PixelFormatBGR10A2Unorm = 94,
    PixelFormatBGR10_XR = 554,
    PixelFormatBGR10_XR_sRGB = 555,
    PixelFormatRG32Uint = 103,
    PixelFormatRG32Sint = 104,
    PixelFormatRG32Float = 105,
    PixelFormatRGBA16Unorm = 110,
    PixelFormatRGBA16Snorm = 112,
    PixelFormatRGBA16Uint = 113,
    PixelFormatRGBA16Sint = 114,
    PixelFormatRGBA16Float = 115,
    PixelFormatBGRA10_XR = 552,
    PixelFormatBGRA10_XR_sRGB = 553,
    PixelFormatRGBA32Uint = 123,
    PixelFormatRGBA32Sint = 124,
    PixelFormatRGBA32Float = 125,
    PixelFormatBC1_RGBA = 130,
    PixelFormatBC1_RGBA_sRGB = 131,
    PixelFormatBC2_RGBA = 132,
    PixelFormatBC2_RGBA_sRGB = 133,
    PixelFormatBC3_RGBA = 134,
    PixelFormatBC3_RGBA_sRGB = 135,
    PixelFormatBC4_RUnorm = 140,
    PixelFormatBC4_RSnorm = 141,
    PixelFormatBC5_RGUnorm = 142,
    PixelFormatBC5_RGSnorm = 143,
    PixelFormatBC6H_RGBFloat = 150,
    PixelFormatBC6H_RGBUfloat = 151,
    PixelFormatBC7_RGBAUnorm = 152,
    PixelFormatBC7_RGBAUnorm_sRGB = 153,
    PixelFormatPVRTC_RGB_2BPP = 160,
    PixelFormatPVRTC_RGB_2BPP_sRGB = 161,
    PixelFormatPVRTC_RGB_4BPP = 162,
    PixelFormatPVRTC_RGB_4BPP_sRGB = 163,
    PixelFormatPVRTC_RGBA_2BPP = 164,
    PixelFormatPVRTC_RGBA_2BPP_sRGB = 165,
    PixelFormatPVRTC_RGBA_4BPP = 166,
    PixelFormatPVRTC_RGBA_4BPP_sRGB = 167,
    PixelFormatEAC_R11Unorm = 170,
    PixelFormatEAC_R11Snorm = 172,
    PixelFormatEAC_RG11Unorm = 174,
    PixelFormatEAC_RG11Snorm = 176,
    PixelFormatEAC_RGBA8 = 178,
    PixelFormatEAC_RGBA8_sRGB = 179,
    PixelFormatETC2_RGB8 = 180,
    PixelFormatETC2_RGB8_sRGB = 181,
    PixelFormatETC2_RGB8A1 = 182,
    PixelFormatETC2_RGB8A1_sRGB = 183,
    PixelFormatASTC_4x4_sRGB = 186,
    PixelFormatASTC_5x4_sRGB = 187,
    PixelFormatASTC_5x5_sRGB = 188,
    PixelFormatASTC_6x5_sRGB = 189,
    PixelFormatASTC_6x6_sRGB = 190,
    PixelFormatASTC_8x5_sRGB = 192,
    PixelFormatASTC_8x6_sRGB = 193,
    PixelFormatASTC_8x8_sRGB = 194,
    PixelFormatASTC_10x5_sRGB = 195,
    PixelFormatASTC_10x6_sRGB = 196,
    PixelFormatASTC_10x8_sRGB = 197,
    PixelFormatASTC_10x10_sRGB = 198,
    PixelFormatASTC_12x10_sRGB = 199,
    PixelFormatASTC_12x12_sRGB = 200,
    PixelFormatASTC_4x4_LDR = 204,
    PixelFormatASTC_5x4_LDR = 205,
    PixelFormatASTC_5x5_LDR = 206,
    PixelFormatASTC_6x5_LDR = 207,
    PixelFormatASTC_6x6_LDR = 208,
    PixelFormatASTC_8x5_LDR = 210,
    PixelFormatASTC_8x6_LDR = 211,
    PixelFormatASTC_8x8_LDR = 212,
    PixelFormatASTC_10x5_LDR = 213,
    PixelFormatASTC_10x6_LDR = 214,
    PixelFormatASTC_10x8_LDR = 215,
    PixelFormatASTC_10x10_LDR = 216,
    PixelFormatASTC_12x10_LDR = 217,
    PixelFormatASTC_12x12_LDR = 218,
    PixelFormatASTC_4x4_HDR = 222,
    PixelFormatASTC_5x4_HDR = 223,
    PixelFormatASTC_5x5_HDR = 224,
    PixelFormatASTC_6x5_HDR = 225,
    PixelFormatASTC_6x6_HDR = 226,
    PixelFormatASTC_8x5_HDR = 228,
    PixelFormatASTC_8x6_HDR = 229,
    PixelFormatASTC_8x8_HDR = 230,
    PixelFormatASTC_10x5_HDR = 231,
    PixelFormatASTC_10x6_HDR = 232,
    PixelFormatASTC_10x8_HDR = 233,
    PixelFormatASTC_10x10_HDR = 234,
    PixelFormatASTC_12x10_HDR = 235,
    PixelFormatASTC_12x12_HDR = 236,
    PixelFormatGBGR422 = 240,
    PixelFormatBGRG422 = 241,
    PixelFormatDepth16Unorm = 250,
    PixelFormatDepth32Float = 252,
    PixelFormatStencil8 = 253,
    PixelFormatDepth24Unorm_Stencil8 = 255,
    PixelFormatDepth32Float_Stencil8 = 260,
    PixelFormatX32_Stencil8 = 261,
    PixelFormatX24_Stencil8 = 262,
    PixelFormatUnspecialized = 263,
};

}

#pragma once

#pragma once

namespace MTL
{
class Allocation : public NS::Referencing<Allocation>
{
public:
    NS::UInteger allocatedSize() const;
};

}
_MTL_INLINE NS::UInteger MTL::Allocation::allocatedSize() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(allocatedSize));
}

#include <mach/mach.h>

namespace MTL
{
class Device;
class Heap;
_MTL_ENUM(NS::UInteger, PurgeableState) {
    PurgeableStateKeepCurrent = 1,
    PurgeableStateNonVolatile = 2,
    PurgeableStateVolatile = 3,
    PurgeableStateEmpty = 4,
};

_MTL_ENUM(NS::UInteger, CPUCacheMode) {
    CPUCacheModeDefaultCache = 0,
    CPUCacheModeWriteCombined = 1,
};

_MTL_ENUM(NS::UInteger, StorageMode) {
    StorageModeShared = 0,
    StorageModeManaged = 1,
    StorageModePrivate = 2,
    StorageModeMemoryless = 3,
};

_MTL_ENUM(NS::UInteger, HazardTrackingMode) {
    HazardTrackingModeDefault = 0,
    HazardTrackingModeUntracked = 1,
    HazardTrackingModeTracked = 2,
};

_MTL_ENUM(NS::Integer, SparsePageSize) {
    SparsePageSize16 = 101,
    SparsePageSize64 = 102,
    SparsePageSize256 = 103,
};

_MTL_ENUM(NS::Integer, BufferSparseTier) {
    BufferSparseTierNone = 0,
    BufferSparseTier1 = 1,
};

_MTL_ENUM(NS::Integer, TextureSparseTier) {
    TextureSparseTierNone = 0,
    TextureSparseTier1 = 1,
    TextureSparseTier2 = 2,
};

_MTL_OPTIONS(NS::UInteger, ResourceOptions) {
    ResourceCPUCacheModeDefaultCache = 0,
    ResourceCPUCacheModeWriteCombined = 1,
    ResourceStorageModeShared = 0,
    ResourceStorageModeManaged = 1 << 4,
    ResourceStorageModePrivate = 1 << 5,
    ResourceStorageModeMemoryless = 1 << 5,
    ResourceHazardTrackingModeDefault = 0,
    ResourceHazardTrackingModeUntracked = 1 << 8,
    ResourceHazardTrackingModeTracked = 1 << 9,
    ResourceOptionCPUCacheModeDefault = 0,
    ResourceOptionCPUCacheModeWriteCombined = 1,
};

class Resource : public NS::Referencing<Resource, Allocation>
{
public:
    NS::UInteger       allocatedSize() const;

    CPUCacheMode       cpuCacheMode() const;

    Device*            device() const;

    HazardTrackingMode hazardTrackingMode() const;

    Heap*              heap() const;
    NS::UInteger       heapOffset() const;

    bool               isAliasable();

    NS::String*        label() const;

    void               makeAliasable();

    ResourceOptions    resourceOptions() const;

    void               setLabel(const NS::String* label);

    kern_return_t      setOwner(task_id_token_t task_id_token);

    PurgeableState     setPurgeableState(MTL::PurgeableState state);

    StorageMode        storageMode() const;
};

}
_MTL_INLINE NS::UInteger MTL::Resource::allocatedSize() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(allocatedSize));
}

_MTL_INLINE MTL::CPUCacheMode MTL::Resource::cpuCacheMode() const
{
    return Object::sendMessage<MTL::CPUCacheMode>(this, _MTL_PRIVATE_SEL(cpuCacheMode));
}

_MTL_INLINE MTL::Device* MTL::Resource::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE MTL::HazardTrackingMode MTL::Resource::hazardTrackingMode() const
{
    return Object::sendMessage<MTL::HazardTrackingMode>(this, _MTL_PRIVATE_SEL(hazardTrackingMode));
}

_MTL_INLINE MTL::Heap* MTL::Resource::heap() const
{
    return Object::sendMessage<MTL::Heap*>(this, _MTL_PRIVATE_SEL(heap));
}

_MTL_INLINE NS::UInteger MTL::Resource::heapOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(heapOffset));
}

_MTL_INLINE bool MTL::Resource::isAliasable()
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isAliasable));
}

_MTL_INLINE NS::String* MTL::Resource::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE void MTL::Resource::makeAliasable()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(makeAliasable));
}

_MTL_INLINE MTL::ResourceOptions MTL::Resource::resourceOptions() const
{
    return Object::sendMessage<MTL::ResourceOptions>(this, _MTL_PRIVATE_SEL(resourceOptions));
}

_MTL_INLINE void MTL::Resource::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE kern_return_t MTL::Resource::setOwner(task_id_token_t task_id_token)
{
    return Object::sendMessage<kern_return_t>(this, _MTL_PRIVATE_SEL(setOwnerWithIdentity_), task_id_token);
}

_MTL_INLINE MTL::PurgeableState MTL::Resource::setPurgeableState(MTL::PurgeableState state)
{
    return Object::sendMessage<MTL::PurgeableState>(this, _MTL_PRIVATE_SEL(setPurgeableState_), state);
}

_MTL_INLINE MTL::StorageMode MTL::Resource::storageMode() const
{
    return Object::sendMessage<MTL::StorageMode>(this, _MTL_PRIVATE_SEL(storageMode));
}

#pragma once

namespace MTL
{
struct SamplePosition;

using Coordinate2D = MTL::SamplePosition;

struct Origin
{
    Origin() = default;

    Origin(NS::UInteger x, NS::UInteger y, NS::UInteger z);

    static Origin Make(NS::UInteger x, NS::UInteger y, NS::UInteger z);

    NS::UInteger  x;
    NS::UInteger  y;
    NS::UInteger  z;
} _MTL_PACKED;

struct Size
{
    Size() = default;

    Size(NS::UInteger width, NS::UInteger height, NS::UInteger depth);

    static Size  Make(NS::UInteger width, NS::UInteger height, NS::UInteger depth);

    NS::UInteger width;
    NS::UInteger height;
    NS::UInteger depth;
} _MTL_PACKED;

struct Region
{
    Region() = default;

    Region(NS::UInteger x, NS::UInteger width);

    Region(NS::UInteger x, NS::UInteger y, NS::UInteger width, NS::UInteger height);

    Region(NS::UInteger x, NS::UInteger y, NS::UInteger z, NS::UInteger width, NS::UInteger height, NS::UInteger depth);

    static Region Make1D(NS::UInteger x, NS::UInteger width);

    static Region Make2D(NS::UInteger x, NS::UInteger y, NS::UInteger width, NS::UInteger height);

    static Region Make3D(NS::UInteger x, NS::UInteger y, NS::UInteger z, NS::UInteger width, NS::UInteger height, NS::UInteger depth);

    MTL::Origin   origin;
    MTL::Size     size;
} _MTL_PACKED;

struct SamplePosition
{
    SamplePosition() = default;

    SamplePosition(float x, float y);

    static SamplePosition Make(float x, float y);

    float                 x;
    float                 y;
} _MTL_PACKED;

struct ResourceID
{
    uint64_t _impl;
} _MTL_PACKED;

}
_MTL_INLINE MTL::Origin::Origin(NS::UInteger x, NS::UInteger y, NS::UInteger z)
    : x(x)
    , y(y)
    , z(z)
{
}

_MTL_INLINE MTL::Origin MTL::Origin::Make(NS::UInteger x, NS::UInteger y, NS::UInteger z)
{
    return Origin(x, y, z);
}

_MTL_INLINE MTL::Size::Size(NS::UInteger width, NS::UInteger height, NS::UInteger depth)
    : width(width)
    , height(height)
    , depth(depth)
{
}

_MTL_INLINE MTL::Size MTL::Size::Make(NS::UInteger width, NS::UInteger height, NS::UInteger depth)
{
    return Size(width, height, depth);
}

_MTL_INLINE MTL::Region::Region(NS::UInteger x, NS::UInteger width)
    : origin(x, 0, 0)
    , size(width, 1, 1)
{
}

_MTL_INLINE MTL::Region::Region(NS::UInteger x, NS::UInteger y, NS::UInteger width, NS::UInteger height)
    : origin(x, y, 0)
    , size(width, height, 1)
{
}

_MTL_INLINE MTL::Region::Region(NS::UInteger x, NS::UInteger y, NS::UInteger z, NS::UInteger width, NS::UInteger height, NS::UInteger depth)
    : origin(x, y, z)
    , size(width, height, depth)
{
}

_MTL_INLINE MTL::Region MTL::Region::Make1D(NS::UInteger x, NS::UInteger width)
{
    return Region(x, width);
}

_MTL_INLINE MTL::Region MTL::Region::Make2D(NS::UInteger x, NS::UInteger y, NS::UInteger width, NS::UInteger height)
{
    return Region(x, y, width, height);
}

_MTL_INLINE MTL::Region MTL::Region::Make3D(NS::UInteger x, NS::UInteger y, NS::UInteger z, NS::UInteger width, NS::UInteger height, NS::UInteger depth)
{
    return Region(x, y, z, width, height, depth);
}

_MTL_INLINE MTL::SamplePosition::SamplePosition(float x, float y)
    : x(x)
    , y(y)
{
}

_MTL_INLINE MTL::SamplePosition MTL::SamplePosition::Make(float x, float y)
{
    return SamplePosition(x, y);
}

#include <IOSurface/IOSurfaceRef.h>

namespace MTL
{
class Buffer;
class Device;
class Resource;
class SharedTextureHandle;
class Texture;
class TextureDescriptor;
class TextureViewDescriptor;
}

namespace MTL
{
_MTL_ENUM(NS::UInteger, TextureType) {
    TextureType1D = 0,
    TextureType1DArray = 1,
    TextureType2D = 2,
    TextureType2DArray = 3,
    TextureType2DMultisample = 4,
    TextureTypeCube = 5,
    TextureTypeCubeArray = 6,
    TextureType3D = 7,
    TextureType2DMultisampleArray = 8,
    TextureTypeTextureBuffer = 9,
};

_MTL_ENUM(uint8_t, TextureSwizzle) {
    TextureSwizzleZero = 0,
    TextureSwizzleOne = 1,
    TextureSwizzleRed = 2,
    TextureSwizzleGreen = 3,
    TextureSwizzleBlue = 4,
    TextureSwizzleAlpha = 5,
};

_MTL_ENUM(NS::Integer, TextureCompressionType) {
    TextureCompressionTypeLossless = 0,
    TextureCompressionTypeLossy = 1,
};

_MTL_OPTIONS(NS::UInteger, TextureUsage) {
    TextureUsageUnknown = 0,
    TextureUsageShaderRead = 1,
    TextureUsageShaderWrite = 1 << 1,
    TextureUsageRenderTarget = 1 << 2,
    TextureUsagePixelFormatView = 1 << 4,
    TextureUsageShaderAtomic = 1 << 5,
};

struct TextureSwizzleChannels
{

    TextureSwizzleChannels(MTL::TextureSwizzle r, MTL::TextureSwizzle g, MTL::TextureSwizzle b, MTL::TextureSwizzle a);

    TextureSwizzleChannels();

    static TextureSwizzleChannels Default();

    static TextureSwizzleChannels Make(MTL::TextureSwizzle r, MTL::TextureSwizzle g, MTL::TextureSwizzle b, MTL::TextureSwizzle a);

    MTL::TextureSwizzle           red;
    MTL::TextureSwizzle           green;
    MTL::TextureSwizzle           blue;
    MTL::TextureSwizzle           alpha;
} _MTL_PACKED;

class SharedTextureHandle : public NS::SecureCoding<SharedTextureHandle>
{
public:
    static SharedTextureHandle* alloc();

    Device*                     device() const;

    SharedTextureHandle*        init();

    NS::String*                 label() const;
};
class TextureDescriptor : public NS::Copying<TextureDescriptor>
{
public:
    static TextureDescriptor* alloc();

    bool                      allowGPUOptimizedContents() const;

    NS::UInteger              arrayLength() const;

    TextureCompressionType    compressionType() const;

    CPUCacheMode              cpuCacheMode() const;

    NS::UInteger              depth() const;

    HazardTrackingMode        hazardTrackingMode() const;

    NS::UInteger              height() const;

    TextureDescriptor*        init();

    NS::UInteger              mipmapLevelCount() const;

    PixelFormat               pixelFormat() const;

    SparsePageSize            placementSparsePageSize() const;

    ResourceOptions           resourceOptions() const;

    NS::UInteger              sampleCount() const;

    void                      setAllowGPUOptimizedContents(bool allowGPUOptimizedContents);

    void                      setArrayLength(NS::UInteger arrayLength);

    void                      setCompressionType(MTL::TextureCompressionType compressionType);

    void                      setCpuCacheMode(MTL::CPUCacheMode cpuCacheMode);

    void                      setDepth(NS::UInteger depth);

    void                      setHazardTrackingMode(MTL::HazardTrackingMode hazardTrackingMode);

    void                      setHeight(NS::UInteger height);

    void                      setMipmapLevelCount(NS::UInteger mipmapLevelCount);

    void                      setPixelFormat(MTL::PixelFormat pixelFormat);

    void                      setPlacementSparsePageSize(MTL::SparsePageSize placementSparsePageSize);

    void                      setResourceOptions(MTL::ResourceOptions resourceOptions);

    void                      setSampleCount(NS::UInteger sampleCount);

    void                      setStorageMode(MTL::StorageMode storageMode);

    void                      setSwizzle(MTL::TextureSwizzleChannels swizzle);

    void                      setTextureType(MTL::TextureType textureType);

    void                      setUsage(MTL::TextureUsage usage);

    void                      setWidth(NS::UInteger width);

    StorageMode               storageMode() const;

    TextureSwizzleChannels    swizzle() const;

    static TextureDescriptor* texture2DDescriptor(MTL::PixelFormat pixelFormat, NS::UInteger width, NS::UInteger height, bool mipmapped);

    static TextureDescriptor* textureBufferDescriptor(MTL::PixelFormat pixelFormat, NS::UInteger width, MTL::ResourceOptions resourceOptions, MTL::TextureUsage usage);

    static TextureDescriptor* textureCubeDescriptor(MTL::PixelFormat pixelFormat, NS::UInteger size, bool mipmapped);

    TextureType               textureType() const;

    TextureUsage              usage() const;

    NS::UInteger              width() const;
};
class TextureViewDescriptor : public NS::Copying<TextureViewDescriptor>
{
public:
    static TextureViewDescriptor* alloc();

    TextureViewDescriptor*        init();

    NS::Range                     levelRange() const;

    PixelFormat                   pixelFormat() const;

    void                          setLevelRange(NS::Range levelRange);

    void                          setPixelFormat(MTL::PixelFormat pixelFormat);

    void                          setSliceRange(NS::Range sliceRange);

    void                          setSwizzle(MTL::TextureSwizzleChannels swizzle);

    void                          setTextureType(MTL::TextureType textureType);

    NS::Range                     sliceRange() const;

    TextureSwizzleChannels        swizzle() const;

    TextureType                   textureType() const;
};
class Texture : public NS::Referencing<Texture, Resource>
{
public:
    bool                   allowGPUOptimizedContents() const;

    NS::UInteger           arrayLength() const;

    Buffer*                buffer() const;
    NS::UInteger           bufferBytesPerRow() const;

    NS::UInteger           bufferOffset() const;

    TextureCompressionType compressionType() const;

    NS::UInteger           depth() const;

    NS::UInteger           firstMipmapInTail() const;

    [[deprecated("please use isFramebufferOnly instead")]]
    bool                 framebufferOnly() const;

    void                 getBytes(void* pixelBytes, NS::UInteger bytesPerRow, NS::UInteger bytesPerImage, MTL::Region region, NS::UInteger level, NS::UInteger slice);
    void                 getBytes(void* pixelBytes, NS::UInteger bytesPerRow, MTL::Region region, NS::UInteger level);

    ResourceID           gpuResourceID() const;

    NS::UInteger         height() const;

    IOSurfaceRef         iosurface() const;
    NS::UInteger         iosurfacePlane() const;

    bool                 isFramebufferOnly() const;

    bool                 isShareable() const;

    bool                 isSparse() const;

    NS::UInteger         mipmapLevelCount() const;

    Texture*             newRemoteTextureViewForDevice(const MTL::Device* device);

    SharedTextureHandle* newSharedTextureHandle();

    Texture*             newTextureView(MTL::PixelFormat pixelFormat);
    Texture*             newTextureView(MTL::PixelFormat pixelFormat, MTL::TextureType textureType, NS::Range levelRange, NS::Range sliceRange);
    Texture*             newTextureView(const MTL::TextureViewDescriptor* descriptor);
    Texture*             newTextureView(MTL::PixelFormat pixelFormat, MTL::TextureType textureType, NS::Range levelRange, NS::Range sliceRange, MTL::TextureSwizzleChannels swizzle);

    NS::UInteger         parentRelativeLevel() const;

    NS::UInteger         parentRelativeSlice() const;

    Texture*             parentTexture() const;

    PixelFormat          pixelFormat() const;

    Texture*             remoteStorageTexture() const;

    void                 replaceRegion(MTL::Region region, NS::UInteger level, NS::UInteger slice, const void* pixelBytes, NS::UInteger bytesPerRow, NS::UInteger bytesPerImage);
    void                 replaceRegion(MTL::Region region, NS::UInteger level, const void* pixelBytes, NS::UInteger bytesPerRow);

    Resource*            rootResource() const;

    NS::UInteger         sampleCount() const;

    [[deprecated("please use isShareable instead")]]
    bool                   shareable() const;

    TextureSparseTier      sparseTextureTier() const;

    TextureSwizzleChannels swizzle() const;

    NS::UInteger           tailSizeInBytes() const;

    TextureType            textureType() const;

    TextureUsage           usage() const;

    NS::UInteger           width() const;
};

}
_MTL_INLINE MTL::TextureSwizzleChannels::TextureSwizzleChannels(MTL::TextureSwizzle r, MTL::TextureSwizzle g, MTL::TextureSwizzle b, MTL::TextureSwizzle a)
    : red(r)
    , green(g)
    , blue(b)
    , alpha(a)
{
}

_MTL_INLINE MTL::TextureSwizzleChannels::TextureSwizzleChannels()
    : red(MTL::TextureSwizzleRed)
    , green(MTL::TextureSwizzleGreen)
    , blue(MTL::TextureSwizzleBlue)
    , alpha(MTL::TextureSwizzleAlpha)
{
}

_MTL_INLINE MTL::TextureSwizzleChannels MTL::TextureSwizzleChannels::Default()
{
    return MTL::TextureSwizzleChannels();
}

_MTL_INLINE MTL::TextureSwizzleChannels MTL::TextureSwizzleChannels::Make(MTL::TextureSwizzle r, MTL::TextureSwizzle g, MTL::TextureSwizzle b, MTL::TextureSwizzle a)
{
    return TextureSwizzleChannels(r, g, b, a);
}

_MTL_INLINE MTL::SharedTextureHandle* MTL::SharedTextureHandle::alloc()
{
    return NS::Object::alloc<MTL::SharedTextureHandle>(_MTL_PRIVATE_CLS(MTLSharedTextureHandle));
}

_MTL_INLINE MTL::Device* MTL::SharedTextureHandle::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE MTL::SharedTextureHandle* MTL::SharedTextureHandle::init()
{
    return NS::Object::init<MTL::SharedTextureHandle>();
}

_MTL_INLINE NS::String* MTL::SharedTextureHandle::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE MTL::TextureDescriptor* MTL::TextureDescriptor::alloc()
{
    return NS::Object::alloc<MTL::TextureDescriptor>(_MTL_PRIVATE_CLS(MTLTextureDescriptor));
}

_MTL_INLINE bool MTL::TextureDescriptor::allowGPUOptimizedContents() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(allowGPUOptimizedContents));
}

_MTL_INLINE NS::UInteger MTL::TextureDescriptor::arrayLength() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(arrayLength));
}

_MTL_INLINE MTL::TextureCompressionType MTL::TextureDescriptor::compressionType() const
{
    return Object::sendMessage<MTL::TextureCompressionType>(this, _MTL_PRIVATE_SEL(compressionType));
}

_MTL_INLINE MTL::CPUCacheMode MTL::TextureDescriptor::cpuCacheMode() const
{
    return Object::sendMessage<MTL::CPUCacheMode>(this, _MTL_PRIVATE_SEL(cpuCacheMode));
}

_MTL_INLINE NS::UInteger MTL::TextureDescriptor::depth() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(depth));
}

_MTL_INLINE MTL::HazardTrackingMode MTL::TextureDescriptor::hazardTrackingMode() const
{
    return Object::sendMessage<MTL::HazardTrackingMode>(this, _MTL_PRIVATE_SEL(hazardTrackingMode));
}

_MTL_INLINE NS::UInteger MTL::TextureDescriptor::height() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(height));
}

_MTL_INLINE MTL::TextureDescriptor* MTL::TextureDescriptor::init()
{
    return NS::Object::init<MTL::TextureDescriptor>();
}

_MTL_INLINE NS::UInteger MTL::TextureDescriptor::mipmapLevelCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(mipmapLevelCount));
}

_MTL_INLINE MTL::PixelFormat MTL::TextureDescriptor::pixelFormat() const
{
    return Object::sendMessage<MTL::PixelFormat>(this, _MTL_PRIVATE_SEL(pixelFormat));
}

_MTL_INLINE MTL::SparsePageSize MTL::TextureDescriptor::placementSparsePageSize() const
{
    return Object::sendMessage<MTL::SparsePageSize>(this, _MTL_PRIVATE_SEL(placementSparsePageSize));
}

_MTL_INLINE MTL::ResourceOptions MTL::TextureDescriptor::resourceOptions() const
{
    return Object::sendMessage<MTL::ResourceOptions>(this, _MTL_PRIVATE_SEL(resourceOptions));
}

_MTL_INLINE NS::UInteger MTL::TextureDescriptor::sampleCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(sampleCount));
}

_MTL_INLINE void MTL::TextureDescriptor::setAllowGPUOptimizedContents(bool allowGPUOptimizedContents)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setAllowGPUOptimizedContents_), allowGPUOptimizedContents);
}

_MTL_INLINE void MTL::TextureDescriptor::setArrayLength(NS::UInteger arrayLength)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setArrayLength_), arrayLength);
}

_MTL_INLINE void MTL::TextureDescriptor::setCompressionType(MTL::TextureCompressionType compressionType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setCompressionType_), compressionType);
}

_MTL_INLINE void MTL::TextureDescriptor::setCpuCacheMode(MTL::CPUCacheMode cpuCacheMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setCpuCacheMode_), cpuCacheMode);
}

_MTL_INLINE void MTL::TextureDescriptor::setDepth(NS::UInteger depth)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepth_), depth);
}

_MTL_INLINE void MTL::TextureDescriptor::setHazardTrackingMode(MTL::HazardTrackingMode hazardTrackingMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setHazardTrackingMode_), hazardTrackingMode);
}

_MTL_INLINE void MTL::TextureDescriptor::setHeight(NS::UInteger height)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setHeight_), height);
}

_MTL_INLINE void MTL::TextureDescriptor::setMipmapLevelCount(NS::UInteger mipmapLevelCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMipmapLevelCount_), mipmapLevelCount);
}

_MTL_INLINE void MTL::TextureDescriptor::setPixelFormat(MTL::PixelFormat pixelFormat)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPixelFormat_), pixelFormat);
}

_MTL_INLINE void MTL::TextureDescriptor::setPlacementSparsePageSize(MTL::SparsePageSize placementSparsePageSize)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPlacementSparsePageSize_), placementSparsePageSize);
}

_MTL_INLINE void MTL::TextureDescriptor::setResourceOptions(MTL::ResourceOptions resourceOptions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setResourceOptions_), resourceOptions);
}

_MTL_INLINE void MTL::TextureDescriptor::setSampleCount(NS::UInteger sampleCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSampleCount_), sampleCount);
}

_MTL_INLINE void MTL::TextureDescriptor::setStorageMode(MTL::StorageMode storageMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStorageMode_), storageMode);
}

_MTL_INLINE void MTL::TextureDescriptor::setSwizzle(MTL::TextureSwizzleChannels swizzle)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSwizzle_), swizzle);
}

_MTL_INLINE void MTL::TextureDescriptor::setTextureType(MTL::TextureType textureType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTextureType_), textureType);
}

_MTL_INLINE void MTL::TextureDescriptor::setUsage(MTL::TextureUsage usage)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setUsage_), usage);
}

_MTL_INLINE void MTL::TextureDescriptor::setWidth(NS::UInteger width)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setWidth_), width);
}

_MTL_INLINE MTL::StorageMode MTL::TextureDescriptor::storageMode() const
{
    return Object::sendMessage<MTL::StorageMode>(this, _MTL_PRIVATE_SEL(storageMode));
}

_MTL_INLINE MTL::TextureSwizzleChannels MTL::TextureDescriptor::swizzle() const
{
    return Object::sendMessage<MTL::TextureSwizzleChannels>(this, _MTL_PRIVATE_SEL(swizzle));
}

_MTL_INLINE MTL::TextureDescriptor* MTL::TextureDescriptor::texture2DDescriptor(MTL::PixelFormat pixelFormat, NS::UInteger width, NS::UInteger height, bool mipmapped)
{
    return Object::sendMessage<MTL::TextureDescriptor*>(_MTL_PRIVATE_CLS(MTLTextureDescriptor), _MTL_PRIVATE_SEL(texture2DDescriptorWithPixelFormat_width_height_mipmapped_), pixelFormat, width, height, mipmapped);
}

_MTL_INLINE MTL::TextureDescriptor* MTL::TextureDescriptor::textureBufferDescriptor(MTL::PixelFormat pixelFormat, NS::UInteger width, MTL::ResourceOptions resourceOptions, MTL::TextureUsage usage)
{
    return Object::sendMessage<MTL::TextureDescriptor*>(_MTL_PRIVATE_CLS(MTLTextureDescriptor), _MTL_PRIVATE_SEL(textureBufferDescriptorWithPixelFormat_width_resourceOptions_usage_), pixelFormat, width, resourceOptions, usage);
}

_MTL_INLINE MTL::TextureDescriptor* MTL::TextureDescriptor::textureCubeDescriptor(MTL::PixelFormat pixelFormat, NS::UInteger size, bool mipmapped)
{
    return Object::sendMessage<MTL::TextureDescriptor*>(_MTL_PRIVATE_CLS(MTLTextureDescriptor), _MTL_PRIVATE_SEL(textureCubeDescriptorWithPixelFormat_size_mipmapped_), pixelFormat, size, mipmapped);
}

_MTL_INLINE MTL::TextureType MTL::TextureDescriptor::textureType() const
{
    return Object::sendMessage<MTL::TextureType>(this, _MTL_PRIVATE_SEL(textureType));
}

_MTL_INLINE MTL::TextureUsage MTL::TextureDescriptor::usage() const
{
    return Object::sendMessage<MTL::TextureUsage>(this, _MTL_PRIVATE_SEL(usage));
}

_MTL_INLINE NS::UInteger MTL::TextureDescriptor::width() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(width));
}

_MTL_INLINE MTL::TextureViewDescriptor* MTL::TextureViewDescriptor::alloc()
{
    return NS::Object::alloc<MTL::TextureViewDescriptor>(_MTL_PRIVATE_CLS(MTLTextureViewDescriptor));
}

_MTL_INLINE MTL::TextureViewDescriptor* MTL::TextureViewDescriptor::init()
{
    return NS::Object::init<MTL::TextureViewDescriptor>();
}

_MTL_INLINE NS::Range MTL::TextureViewDescriptor::levelRange() const
{
    return Object::sendMessage<NS::Range>(this, _MTL_PRIVATE_SEL(levelRange));
}

_MTL_INLINE MTL::PixelFormat MTL::TextureViewDescriptor::pixelFormat() const
{
    return Object::sendMessage<MTL::PixelFormat>(this, _MTL_PRIVATE_SEL(pixelFormat));
}

_MTL_INLINE void MTL::TextureViewDescriptor::setLevelRange(NS::Range levelRange)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLevelRange_), levelRange);
}

_MTL_INLINE void MTL::TextureViewDescriptor::setPixelFormat(MTL::PixelFormat pixelFormat)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPixelFormat_), pixelFormat);
}

_MTL_INLINE void MTL::TextureViewDescriptor::setSliceRange(NS::Range sliceRange)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSliceRange_), sliceRange);
}

_MTL_INLINE void MTL::TextureViewDescriptor::setSwizzle(MTL::TextureSwizzleChannels swizzle)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSwizzle_), swizzle);
}

_MTL_INLINE void MTL::TextureViewDescriptor::setTextureType(MTL::TextureType textureType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTextureType_), textureType);
}

_MTL_INLINE NS::Range MTL::TextureViewDescriptor::sliceRange() const
{
    return Object::sendMessage<NS::Range>(this, _MTL_PRIVATE_SEL(sliceRange));
}

_MTL_INLINE MTL::TextureSwizzleChannels MTL::TextureViewDescriptor::swizzle() const
{
    return Object::sendMessage<MTL::TextureSwizzleChannels>(this, _MTL_PRIVATE_SEL(swizzle));
}

_MTL_INLINE MTL::TextureType MTL::TextureViewDescriptor::textureType() const
{
    return Object::sendMessage<MTL::TextureType>(this, _MTL_PRIVATE_SEL(textureType));
}

_MTL_INLINE bool MTL::Texture::allowGPUOptimizedContents() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(allowGPUOptimizedContents));
}

_MTL_INLINE NS::UInteger MTL::Texture::arrayLength() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(arrayLength));
}

_MTL_INLINE MTL::Buffer* MTL::Texture::buffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(buffer));
}

_MTL_INLINE NS::UInteger MTL::Texture::bufferBytesPerRow() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(bufferBytesPerRow));
}

_MTL_INLINE NS::UInteger MTL::Texture::bufferOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(bufferOffset));
}

_MTL_INLINE MTL::TextureCompressionType MTL::Texture::compressionType() const
{
    return Object::sendMessage<MTL::TextureCompressionType>(this, _MTL_PRIVATE_SEL(compressionType));
}

_MTL_INLINE NS::UInteger MTL::Texture::depth() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(depth));
}

_MTL_INLINE NS::UInteger MTL::Texture::firstMipmapInTail() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(firstMipmapInTail));
}

_MTL_INLINE bool MTL::Texture::framebufferOnly() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isFramebufferOnly));
}

_MTL_INLINE void MTL::Texture::getBytes(void* pixelBytes, NS::UInteger bytesPerRow, NS::UInteger bytesPerImage, MTL::Region region, NS::UInteger level, NS::UInteger slice)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(getBytes_bytesPerRow_bytesPerImage_fromRegion_mipmapLevel_slice_), pixelBytes, bytesPerRow, bytesPerImage, region, level, slice);
}

_MTL_INLINE void MTL::Texture::getBytes(void* pixelBytes, NS::UInteger bytesPerRow, MTL::Region region, NS::UInteger level)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(getBytes_bytesPerRow_fromRegion_mipmapLevel_), pixelBytes, bytesPerRow, region, level);
}

_MTL_INLINE MTL::ResourceID MTL::Texture::gpuResourceID() const
{
    return Object::sendMessage<MTL::ResourceID>(this, _MTL_PRIVATE_SEL(gpuResourceID));
}

_MTL_INLINE NS::UInteger MTL::Texture::height() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(height));
}

_MTL_INLINE IOSurfaceRef MTL::Texture::iosurface() const
{
    return Object::sendMessage<IOSurfaceRef>(this, _MTL_PRIVATE_SEL(iosurface));
}

_MTL_INLINE NS::UInteger MTL::Texture::iosurfacePlane() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(iosurfacePlane));
}

_MTL_INLINE bool MTL::Texture::isFramebufferOnly() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isFramebufferOnly));
}

_MTL_INLINE bool MTL::Texture::isShareable() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isShareable));
}

_MTL_INLINE bool MTL::Texture::isSparse() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isSparse));
}

_MTL_INLINE NS::UInteger MTL::Texture::mipmapLevelCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(mipmapLevelCount));
}

_MTL_INLINE MTL::Texture* MTL::Texture::newRemoteTextureViewForDevice(const MTL::Device* device)
{
    return Object::sendMessage<MTL::Texture*>(this, _MTL_PRIVATE_SEL(newRemoteTextureViewForDevice_), device);
}

_MTL_INLINE MTL::SharedTextureHandle* MTL::Texture::newSharedTextureHandle()
{
    return Object::sendMessage<MTL::SharedTextureHandle*>(this, _MTL_PRIVATE_SEL(newSharedTextureHandle));
}

_MTL_INLINE MTL::Texture* MTL::Texture::newTextureView(MTL::PixelFormat pixelFormat)
{
    return Object::sendMessage<MTL::Texture*>(this, _MTL_PRIVATE_SEL(newTextureViewWithPixelFormat_), pixelFormat);
}

_MTL_INLINE MTL::Texture* MTL::Texture::newTextureView(MTL::PixelFormat pixelFormat, MTL::TextureType textureType, NS::Range levelRange, NS::Range sliceRange)
{
    return Object::sendMessage<MTL::Texture*>(this, _MTL_PRIVATE_SEL(newTextureViewWithPixelFormat_textureType_levels_slices_), pixelFormat, textureType, levelRange, sliceRange);
}

_MTL_INLINE MTL::Texture* MTL::Texture::newTextureView(const MTL::TextureViewDescriptor* descriptor)
{
    return Object::sendMessage<MTL::Texture*>(this, _MTL_PRIVATE_SEL(newTextureViewWithDescriptor_), descriptor);
}

_MTL_INLINE MTL::Texture* MTL::Texture::newTextureView(MTL::PixelFormat pixelFormat, MTL::TextureType textureType, NS::Range levelRange, NS::Range sliceRange, MTL::TextureSwizzleChannels swizzle)
{
    return Object::sendMessage<MTL::Texture*>(this, _MTL_PRIVATE_SEL(newTextureViewWithPixelFormat_textureType_levels_slices_swizzle_), pixelFormat, textureType, levelRange, sliceRange, swizzle);
}

_MTL_INLINE NS::UInteger MTL::Texture::parentRelativeLevel() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(parentRelativeLevel));
}

_MTL_INLINE NS::UInteger MTL::Texture::parentRelativeSlice() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(parentRelativeSlice));
}

_MTL_INLINE MTL::Texture* MTL::Texture::parentTexture() const
{
    return Object::sendMessage<MTL::Texture*>(this, _MTL_PRIVATE_SEL(parentTexture));
}

_MTL_INLINE MTL::PixelFormat MTL::Texture::pixelFormat() const
{
    return Object::sendMessage<MTL::PixelFormat>(this, _MTL_PRIVATE_SEL(pixelFormat));
}

_MTL_INLINE MTL::Texture* MTL::Texture::remoteStorageTexture() const
{
    return Object::sendMessage<MTL::Texture*>(this, _MTL_PRIVATE_SEL(remoteStorageTexture));
}

_MTL_INLINE void MTL::Texture::replaceRegion(MTL::Region region, NS::UInteger level, NS::UInteger slice, const void* pixelBytes, NS::UInteger bytesPerRow, NS::UInteger bytesPerImage)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage_), region, level, slice, pixelBytes, bytesPerRow, bytesPerImage);
}

_MTL_INLINE void MTL::Texture::replaceRegion(MTL::Region region, NS::UInteger level, const void* pixelBytes, NS::UInteger bytesPerRow)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(replaceRegion_mipmapLevel_withBytes_bytesPerRow_), region, level, pixelBytes, bytesPerRow);
}

_MTL_INLINE MTL::Resource* MTL::Texture::rootResource() const
{
    return Object::sendMessage<MTL::Resource*>(this, _MTL_PRIVATE_SEL(rootResource));
}

_MTL_INLINE NS::UInteger MTL::Texture::sampleCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(sampleCount));
}

_MTL_INLINE bool MTL::Texture::shareable() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isShareable));
}

_MTL_INLINE MTL::TextureSparseTier MTL::Texture::sparseTextureTier() const
{
    return Object::sendMessage<MTL::TextureSparseTier>(this, _MTL_PRIVATE_SEL(sparseTextureTier));
}

_MTL_INLINE MTL::TextureSwizzleChannels MTL::Texture::swizzle() const
{
    return Object::sendMessage<MTL::TextureSwizzleChannels>(this, _MTL_PRIVATE_SEL(swizzle));
}

_MTL_INLINE NS::UInteger MTL::Texture::tailSizeInBytes() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(tailSizeInBytes));
}

_MTL_INLINE MTL::TextureType MTL::Texture::textureType() const
{
    return Object::sendMessage<MTL::TextureType>(this, _MTL_PRIVATE_SEL(textureType));
}

_MTL_INLINE MTL::TextureUsage MTL::Texture::usage() const
{
    return Object::sendMessage<MTL::TextureUsage>(this, _MTL_PRIVATE_SEL(usage));
}

_MTL_INLINE NS::UInteger MTL::Texture::width() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(width));
}

#define _CA_EXPORT _NS_EXPORT
#define _CA_EXTERN _NS_EXTERN
#define _CA_INLINE _NS_INLINE
#define _CA_PACKED _NS_PACKED

#define _CA_CONST(type, name) _NS_CONST(type, name)
#define _CA_ENUM(type, name) _NS_ENUM(type, name)
#define _CA_OPTIONS(type, name) _NS_OPTIONS(type, name)

#define _CA_VALIDATE_SIZE(ns, name) _NS_VALIDATE_SIZE(ns, name)
#define _CA_VALIDATE_ENUM(ns, name) _NS_VALIDATE_ENUM(ns, name)

#include <objc/runtime.h>

#define _CA_PRIVATE_CLS(symbol) (Private::Class::s_k##symbol)
#define _CA_PRIVATE_SEL(accessor) (Private::Selector::s_k##accessor)

#if defined(CA_PRIVATE_IMPLEMENTATION)

#ifdef METALCPP_SYMBOL_VISIBILITY_HIDDEN
#define _CA_PRIVATE_VISIBILITY __attribute__((visibility("hidden")))
#else
#define _CA_PRIVATE_VISIBILITY __attribute__((visibility("default")))
#endif // METALCPP_SYMBOL_VISIBILITY_HIDDEN

#define _CA_PRIVATE_IMPORT __attribute__((weak_import))

#ifdef __OBJC__
#define _CA_PRIVATE_OBJC_LOOKUP_CLASS(symbol) ((__bridge void*)objc_lookUpClass(#symbol))
#define _CA_PRIVATE_OBJC_GET_PROTOCOL(symbol) ((__bridge void*)objc_getProtocol(#symbol))
#else
#define _CA_PRIVATE_OBJC_LOOKUP_CLASS(symbol) objc_lookUpClass(#symbol)
#define _CA_PRIVATE_OBJC_GET_PROTOCOL(symbol) objc_getProtocol(#symbol)
#endif // __OBJC__

#define _CA_PRIVATE_DEF_CLS(symbol) void* s_k##symbol _CA_PRIVATE_VISIBILITY = _CA_PRIVATE_OBJC_LOOKUP_CLASS(symbol)
#define _CA_PRIVATE_DEF_PRO(symbol) void* s_k##symbol _CA_PRIVATE_VISIBILITY = _CA_PRIVATE_OBJC_GET_PROTOCOL(symbol)
#define _CA_PRIVATE_DEF_SEL(accessor, symbol) SEL s_k##accessor _CA_PRIVATE_VISIBILITY = sel_registerName(symbol)
#define _CA_PRIVATE_DEF_STR(type, symbol)                \
    _CA_EXTERN type const CA##symbol _CA_PRIVATE_IMPORT; \
    type const                       CA::symbol = (nullptr != &CA##symbol) ? CA##symbol : nullptr

#else

#define _CA_PRIVATE_DEF_CLS(symbol) extern void* s_k##symbol
#define _CA_PRIVATE_DEF_PRO(symbol) extern void* s_k##symbol
#define _CA_PRIVATE_DEF_SEL(accessor, symbol) extern SEL s_k##accessor
#define _CA_PRIVATE_DEF_STR(type, symbol) extern type const CA::symbol

#endif // CA_PRIVATE_IMPLEMENTATION

namespace CA
{
namespace Private
{
    namespace Class
    {
        _CA_PRIVATE_DEF_CLS(CAMetalLayer);
    } // Class
} // Private
} // CA

namespace CA
{
namespace Private
{
    namespace Protocol
    {

        _CA_PRIVATE_DEF_PRO(CAMetalDrawable);

    } // Protocol
} // Private
} // CA

namespace CA
{
namespace Private
{
    namespace Selector
    {
        _CA_PRIVATE_DEF_SEL(allowsNextDrawableTimeout,
            "allowsNextDrawableTimeout");
        _CA_PRIVATE_DEF_SEL(colorspace,
            "colorspace");
        _CA_PRIVATE_DEF_SEL(device,
            "device");
        _CA_PRIVATE_DEF_SEL(displaySyncEnabled,
            "displaySyncEnabled");
        _CA_PRIVATE_DEF_SEL(drawableSize,
            "drawableSize");
        _CA_PRIVATE_DEF_SEL(framebufferOnly,
            "framebufferOnly");
        _CA_PRIVATE_DEF_SEL(layer,
            "layer");
        _CA_PRIVATE_DEF_SEL(maximumDrawableCount,
            "maximumDrawableCount");
        _CA_PRIVATE_DEF_SEL(nextDrawable,
            "nextDrawable");
        _CA_PRIVATE_DEF_SEL(pixelFormat,
            "pixelFormat");
        _CA_PRIVATE_DEF_SEL(residencySet,
            "residencySet");
        _CA_PRIVATE_DEF_SEL(setAllowsNextDrawableTimeout_,
            "setAllowsNextDrawableTimeout:");
        _CA_PRIVATE_DEF_SEL(setColorspace_,
            "setColorspace:");
        _CA_PRIVATE_DEF_SEL(setDevice_,
            "setDevice:");
        _CA_PRIVATE_DEF_SEL(setDisplaySyncEnabled_,
            "setDisplaySyncEnabled:");
        _CA_PRIVATE_DEF_SEL(setDrawableSize_,
            "setDrawableSize:");
        _CA_PRIVATE_DEF_SEL(setFramebufferOnly_,
            "setFramebufferOnly:");
        _CA_PRIVATE_DEF_SEL(setMaximumDrawableCount_,
            "setMaximumDrawableCount:");
        _CA_PRIVATE_DEF_SEL(setPixelFormat_,
            "setPixelFormat:");
        _CA_PRIVATE_DEF_SEL(texture,
            "texture");
    } // Class
} // Private
} // CA

namespace CA
{
class MetalDrawable : public NS::Referencing<MetalDrawable, MTL::Drawable>
{
public:
    class MetalLayer* layer() const;
    MTL::Texture*     texture() const;
};
}

_CA_INLINE CA::MetalLayer* CA::MetalDrawable::layer() const
{
    return Object::sendMessage<MetalLayer*>(this, _CA_PRIVATE_SEL(layer));
}

_CA_INLINE MTL::Texture* CA::MetalDrawable::texture() const
{
    return Object::sendMessage<MTL::Texture*>(this, _CA_PRIVATE_SEL(texture));
}

#pragma once

#include <cstdint>

namespace MTL
{
class Allocation;
class Device;
class ResidencySetDescriptor;

class ResidencySetDescriptor : public NS::Copying<ResidencySetDescriptor>
{
public:
    static ResidencySetDescriptor* alloc();

    ResidencySetDescriptor*        init();
    NS::UInteger                   initialCapacity() const;

    NS::String*                    label() const;

    void                           setInitialCapacity(NS::UInteger initialCapacity);

    void                           setLabel(const NS::String* label);
};
class ResidencySet : public NS::Referencing<ResidencySet>
{
public:
    void         addAllocation(const MTL::Allocation* allocation);
    void         addAllocations(const MTL::Allocation* const allocations[], NS::UInteger count);

    NS::Array*   allAllocations() const;

    uint64_t     allocatedSize() const;

    NS::UInteger allocationCount() const;

    void         commit();

    bool         containsAllocation(const MTL::Allocation* anAllocation);

    Device*      device() const;

    void         endResidency();

    NS::String*  label() const;

    void         removeAllAllocations();

    void         removeAllocation(const MTL::Allocation* allocation);
    void         removeAllocations(const MTL::Allocation* const allocations[], NS::UInteger count);

    void         requestResidency();
};

}
_MTL_INLINE MTL::ResidencySetDescriptor* MTL::ResidencySetDescriptor::alloc()
{
    return NS::Object::alloc<MTL::ResidencySetDescriptor>(_MTL_PRIVATE_CLS(MTLResidencySetDescriptor));
}

_MTL_INLINE MTL::ResidencySetDescriptor* MTL::ResidencySetDescriptor::init()
{
    return NS::Object::init<MTL::ResidencySetDescriptor>();
}

_MTL_INLINE NS::UInteger MTL::ResidencySetDescriptor::initialCapacity() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(initialCapacity));
}

_MTL_INLINE NS::String* MTL::ResidencySetDescriptor::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE void MTL::ResidencySetDescriptor::setInitialCapacity(NS::UInteger initialCapacity)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInitialCapacity_), initialCapacity);
}

_MTL_INLINE void MTL::ResidencySetDescriptor::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE void MTL::ResidencySet::addAllocation(const MTL::Allocation* allocation)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(addAllocation_), allocation);
}

_MTL_INLINE void MTL::ResidencySet::addAllocations(const MTL::Allocation* const allocations[], NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(addAllocations_count_), allocations, count);
}

_MTL_INLINE NS::Array* MTL::ResidencySet::allAllocations() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(allAllocations));
}

_MTL_INLINE uint64_t MTL::ResidencySet::allocatedSize() const
{
    return Object::sendMessage<uint64_t>(this, _MTL_PRIVATE_SEL(allocatedSize));
}

_MTL_INLINE NS::UInteger MTL::ResidencySet::allocationCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(allocationCount));
}

_MTL_INLINE void MTL::ResidencySet::commit()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(commit));
}

_MTL_INLINE bool MTL::ResidencySet::containsAllocation(const MTL::Allocation* anAllocation)
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(containsAllocation_), anAllocation);
}

_MTL_INLINE MTL::Device* MTL::ResidencySet::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE void MTL::ResidencySet::endResidency()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(endResidency));
}

_MTL_INLINE NS::String* MTL::ResidencySet::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE void MTL::ResidencySet::removeAllAllocations()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(removeAllAllocations));
}

_MTL_INLINE void MTL::ResidencySet::removeAllocation(const MTL::Allocation* allocation)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(removeAllocation_), allocation);
}

_MTL_INLINE void MTL::ResidencySet::removeAllocations(const MTL::Allocation* const allocations[], NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(removeAllocations_count_), allocations, count);
}

_MTL_INLINE void MTL::ResidencySet::requestResidency()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(requestResidency));
}

#include <CoreGraphics/CGGeometry.h>
#include <CoreGraphics/CGColorSpace.h>

namespace CA
{

class MetalLayer : public NS::Referencing<MetalLayer>
{
public:
    static class MetalLayer* layer();

    MTL::Device*             device() const;
    void                     setDevice(MTL::Device* device);

    MTL::PixelFormat         pixelFormat() const;
    void                     setPixelFormat(MTL::PixelFormat pixelFormat);

    bool                     framebufferOnly() const;
    void                     setFramebufferOnly(bool framebufferOnly);

    CGSize                   drawableSize() const;
    void                     setDrawableSize(CGSize drawableSize);

    class MetalDrawable*     nextDrawable();

    NS::UInteger             maximumDrawableCount() const;
    void                     setMaximumDrawableCount(NS::UInteger maximumDrawableCount);

    bool                     displaySyncEnabled() const;
    void                     setDisplaySyncEnabled(bool displaySyncEnabled);

    CGColorSpaceRef          colorspace() const;
    void                     setColorspace(CGColorSpaceRef colorspace);

    bool                     allowsNextDrawableTimeout() const;
    void                     setAllowsNextDrawableTimeout(bool allowsNextDrawableTimeout);

    MTL::ResidencySet*       residencySet() const;
};
} // namespace CA

_CA_INLINE CA::MetalLayer* CA::MetalLayer::layer()
{
    return Object::sendMessage<CA::MetalLayer*>(_CA_PRIVATE_CLS(CAMetalLayer), _CA_PRIVATE_SEL(layer));
}

_CA_INLINE MTL::Device* CA::MetalLayer::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _CA_PRIVATE_SEL(device));
}

_CA_INLINE void CA::MetalLayer::setDevice(MTL::Device* device)
{
    return Object::sendMessage<void>(this, _CA_PRIVATE_SEL(setDevice_), device);
}

_CA_INLINE MTL::PixelFormat CA::MetalLayer::pixelFormat() const
{
    return Object::sendMessage<MTL::PixelFormat>(this,
        _CA_PRIVATE_SEL(pixelFormat));
}

_CA_INLINE void CA::MetalLayer::setPixelFormat(MTL::PixelFormat pixelFormat)
{
    return Object::sendMessage<void>(this, _CA_PRIVATE_SEL(setPixelFormat_),
        pixelFormat);
}

_CA_INLINE bool CA::MetalLayer::framebufferOnly() const
{
    return Object::sendMessage<bool>(this, _CA_PRIVATE_SEL(framebufferOnly));
}

_CA_INLINE void CA::MetalLayer::setFramebufferOnly(bool framebufferOnly)
{
    return Object::sendMessage<void>(this, _CA_PRIVATE_SEL(setFramebufferOnly_),
        framebufferOnly);
}

_CA_INLINE CGSize CA::MetalLayer::drawableSize() const
{
    return Object::sendMessage<CGSize>(this, _CA_PRIVATE_SEL(drawableSize));
}

_CA_INLINE void CA::MetalLayer::setDrawableSize(CGSize drawableSize)
{
    return Object::sendMessage<void>(this, _CA_PRIVATE_SEL(setDrawableSize_),
        drawableSize);
}

_CA_INLINE CA::MetalDrawable* CA::MetalLayer::nextDrawable()
{
    return Object::sendMessage<MetalDrawable*>(this,
        _CA_PRIVATE_SEL(nextDrawable));
}

_CA_INLINE NS::UInteger CA::MetalLayer::maximumDrawableCount() const
{
    return Object::sendMessage<NS::UInteger>(this,
        _CA_PRIVATE_SEL(maximumDrawableCount));
}

_CA_INLINE void CA::MetalLayer::setMaximumDrawableCount(NS::UInteger maximumDrawableCount)
{
    return Object::sendMessage<void>(this, _CA_PRIVATE_SEL(setMaximumDrawableCount_),
        maximumDrawableCount);
}

_CA_INLINE bool CA::MetalLayer::displaySyncEnabled() const
{
    return Object::sendMessage<bool>(this, _CA_PRIVATE_SEL(displaySyncEnabled));
}

_CA_INLINE void CA::MetalLayer::setDisplaySyncEnabled(bool displaySyncEnabled)
{
    return Object::sendMessage<void>(this, _CA_PRIVATE_SEL(setDisplaySyncEnabled_),
        displaySyncEnabled);
}

_CA_INLINE CGColorSpaceRef CA::MetalLayer::colorspace() const
{
    return Object::sendMessage<CGColorSpaceRef>(this, _CA_PRIVATE_SEL(colorspace));
}

_CA_INLINE void CA::MetalLayer::setColorspace(CGColorSpaceRef colorspace)
{
    return Object::sendMessage<void>(this, _CA_PRIVATE_SEL(setColorspace_),
        colorspace);
}

_CA_INLINE bool CA::MetalLayer::allowsNextDrawableTimeout() const
{
    return Object::sendMessage<bool>(this, _CA_PRIVATE_SEL(allowsNextDrawableTimeout));
}

_CA_INLINE void CA::MetalLayer::setAllowsNextDrawableTimeout(bool allowsNextDrawableTimeout)
{
    return Object::sendMessage<void>(this, _CA_PRIVATE_SEL(setAllowsNextDrawableTimeout_),
    allowsNextDrawableTimeout);
}

_CA_INLINE MTL::ResidencySet* CA::MetalLayer::residencySet() const
{
    return Object::sendMessage<MTL::ResidencySet*>(this, _CA_PRIVATE_SEL(residencySet) );
}

#pragma once

#pragma once

#pragma once

#pragma once

namespace MTL
{
_MTL_ENUM(NS::UInteger, DataType) {
    DataTypeNone = 0,
    DataTypeStruct = 1,
    DataTypeArray = 2,
    DataTypeFloat = 3,
    DataTypeFloat2 = 4,
    DataTypeFloat3 = 5,
    DataTypeFloat4 = 6,
    DataTypeFloat2x2 = 7,
    DataTypeFloat2x3 = 8,
    DataTypeFloat2x4 = 9,
    DataTypeFloat3x2 = 10,
    DataTypeFloat3x3 = 11,
    DataTypeFloat3x4 = 12,
    DataTypeFloat4x2 = 13,
    DataTypeFloat4x3 = 14,
    DataTypeFloat4x4 = 15,
    DataTypeHalf = 16,
    DataTypeHalf2 = 17,
    DataTypeHalf3 = 18,
    DataTypeHalf4 = 19,
    DataTypeHalf2x2 = 20,
    DataTypeHalf2x3 = 21,
    DataTypeHalf2x4 = 22,
    DataTypeHalf3x2 = 23,
    DataTypeHalf3x3 = 24,
    DataTypeHalf3x4 = 25,
    DataTypeHalf4x2 = 26,
    DataTypeHalf4x3 = 27,
    DataTypeHalf4x4 = 28,
    DataTypeInt = 29,
    DataTypeInt2 = 30,
    DataTypeInt3 = 31,
    DataTypeInt4 = 32,
    DataTypeUInt = 33,
    DataTypeUInt2 = 34,
    DataTypeUInt3 = 35,
    DataTypeUInt4 = 36,
    DataTypeShort = 37,
    DataTypeShort2 = 38,
    DataTypeShort3 = 39,
    DataTypeShort4 = 40,
    DataTypeUShort = 41,
    DataTypeUShort2 = 42,
    DataTypeUShort3 = 43,
    DataTypeUShort4 = 44,
    DataTypeChar = 45,
    DataTypeChar2 = 46,
    DataTypeChar3 = 47,
    DataTypeChar4 = 48,
    DataTypeUChar = 49,
    DataTypeUChar2 = 50,
    DataTypeUChar3 = 51,
    DataTypeUChar4 = 52,
    DataTypeBool = 53,
    DataTypeBool2 = 54,
    DataTypeBool3 = 55,
    DataTypeBool4 = 56,
    DataTypeTexture = 58,
    DataTypeSampler = 59,
    DataTypePointer = 60,
    DataTypeR8Unorm = 62,
    DataTypeR8Snorm = 63,
    DataTypeR16Unorm = 64,
    DataTypeR16Snorm = 65,
    DataTypeRG8Unorm = 66,
    DataTypeRG8Snorm = 67,
    DataTypeRG16Unorm = 68,
    DataTypeRG16Snorm = 69,
    DataTypeRGBA8Unorm = 70,
    DataTypeRGBA8Unorm_sRGB = 71,
    DataTypeRGBA8Snorm = 72,
    DataTypeRGBA16Unorm = 73,
    DataTypeRGBA16Snorm = 74,
    DataTypeRGB10A2Unorm = 75,
    DataTypeRG11B10Float = 76,
    DataTypeRGB9E5Float = 77,
    DataTypeRenderPipeline = 78,
    DataTypeComputePipeline = 79,
    DataTypeIndirectCommandBuffer = 80,
    DataTypeLong = 81,
    DataTypeLong2 = 82,
    DataTypeLong3 = 83,
    DataTypeLong4 = 84,
    DataTypeULong = 85,
    DataTypeULong2 = 86,
    DataTypeULong3 = 87,
    DataTypeULong4 = 88,
    DataTypeVisibleFunctionTable = 115,
    DataTypeIntersectionFunctionTable = 116,
    DataTypePrimitiveAccelerationStructure = 117,
    DataTypeInstanceAccelerationStructure = 118,
    DataTypeBFloat = 121,
    DataTypeBFloat2 = 122,
    DataTypeBFloat3 = 123,
    DataTypeBFloat4 = 124,
    DataTypeDepthStencilState = 139,
    DataTypeTensor = 140,
};

}

#pragma once

namespace MTL
{
class Buffer;
class TensorDescriptor;
class TensorExtents;

_MTL_CONST(NS::ErrorDomain, TensorDomain);

_MTL_ENUM(NS::Integer, TensorDataType) {
    TensorDataTypeNone = 0,
    TensorDataTypeFloat32 = 3,
    TensorDataTypeFloat16 = 16,
    TensorDataTypeBFloat16 = 121,
    TensorDataTypeInt8 = 45,
    TensorDataTypeUInt8 = 49,
    TensorDataTypeInt16 = 37,
    TensorDataTypeUInt16 = 41,
    TensorDataTypeInt32 = 29,
    TensorDataTypeUInt32 = 33,
};

_MTL_ENUM(NS::Integer, TensorError) {
    TensorErrorNone = 0,
    TensorErrorInternalError = 1,
    TensorErrorInvalidDescriptor = 2,
};

_MTL_OPTIONS(NS::UInteger, TensorUsage) {
    TensorUsageCompute = 1,
    TensorUsageRender = 1 << 1,
    TensorUsageMachineLearning = 1 << 2,
};

class TensorExtents : public NS::Referencing<TensorExtents>
{
public:
    static TensorExtents* alloc();

    NS::Integer           extentAtDimensionIndex(NS::UInteger dimensionIndex);

    TensorExtents*        init();
    TensorExtents*        init(NS::UInteger rank, const NS::Integer* values);

    NS::UInteger          rank() const;
};
class TensorDescriptor : public NS::Copying<TensorDescriptor>
{
public:
    static TensorDescriptor* alloc();

    CPUCacheMode             cpuCacheMode() const;

    TensorDataType           dataType() const;

    TensorExtents*           dimensions() const;

    HazardTrackingMode       hazardTrackingMode() const;

    TensorDescriptor*        init();

    ResourceOptions          resourceOptions() const;

    void                     setCpuCacheMode(MTL::CPUCacheMode cpuCacheMode);

    void                     setDataType(MTL::TensorDataType dataType);

    void                     setDimensions(const MTL::TensorExtents* dimensions);

    void                     setHazardTrackingMode(MTL::HazardTrackingMode hazardTrackingMode);

    void                     setResourceOptions(MTL::ResourceOptions resourceOptions);

    void                     setStorageMode(MTL::StorageMode storageMode);

    void                     setStrides(const MTL::TensorExtents* strides);

    void                     setUsage(MTL::TensorUsage usage);

    StorageMode              storageMode() const;

    TensorExtents*           strides() const;

    TensorUsage              usage() const;
};
class Tensor : public NS::Referencing<Tensor, Resource>
{
public:
    Buffer*        buffer() const;
    NS::UInteger   bufferOffset() const;

    TensorDataType dataType() const;

    TensorExtents* dimensions() const;

    void           getBytes(void* bytes, const MTL::TensorExtents* strides, const MTL::TensorExtents* sliceOrigin, const MTL::TensorExtents* sliceDimensions);

    ResourceID     gpuResourceID() const;

    void           replaceSliceOrigin(const MTL::TensorExtents* sliceOrigin, const MTL::TensorExtents* sliceDimensions, const void* bytes, const MTL::TensorExtents* strides);

    TensorExtents* strides() const;

    TensorUsage    usage() const;
};

}

_MTL_PRIVATE_DEF_WEAK_CONST(NS::ErrorDomain, TensorDomain);

_MTL_INLINE MTL::TensorExtents* MTL::TensorExtents::alloc()
{
    return NS::Object::alloc<MTL::TensorExtents>(_MTL_PRIVATE_CLS(MTLTensorExtents));
}

_MTL_INLINE NS::Integer MTL::TensorExtents::extentAtDimensionIndex(NS::UInteger dimensionIndex)
{
    return Object::sendMessage<NS::Integer>(this, _MTL_PRIVATE_SEL(extentAtDimensionIndex_), dimensionIndex);
}

_MTL_INLINE MTL::TensorExtents* MTL::TensorExtents::init()
{
    return NS::Object::init<MTL::TensorExtents>();
}

_MTL_INLINE MTL::TensorExtents* MTL::TensorExtents::init(NS::UInteger rank, const NS::Integer* values)
{
    return Object::sendMessage<MTL::TensorExtents*>(this, _MTL_PRIVATE_SEL(initWithRank_values_), rank, values);
}

_MTL_INLINE NS::UInteger MTL::TensorExtents::rank() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(rank));
}

_MTL_INLINE MTL::TensorDescriptor* MTL::TensorDescriptor::alloc()
{
    return NS::Object::alloc<MTL::TensorDescriptor>(_MTL_PRIVATE_CLS(MTLTensorDescriptor));
}

_MTL_INLINE MTL::CPUCacheMode MTL::TensorDescriptor::cpuCacheMode() const
{
    return Object::sendMessage<MTL::CPUCacheMode>(this, _MTL_PRIVATE_SEL(cpuCacheMode));
}

_MTL_INLINE MTL::TensorDataType MTL::TensorDescriptor::dataType() const
{
    return Object::sendMessage<MTL::TensorDataType>(this, _MTL_PRIVATE_SEL(dataType));
}

_MTL_INLINE MTL::TensorExtents* MTL::TensorDescriptor::dimensions() const
{
    return Object::sendMessage<MTL::TensorExtents*>(this, _MTL_PRIVATE_SEL(dimensions));
}

_MTL_INLINE MTL::HazardTrackingMode MTL::TensorDescriptor::hazardTrackingMode() const
{
    return Object::sendMessage<MTL::HazardTrackingMode>(this, _MTL_PRIVATE_SEL(hazardTrackingMode));
}

_MTL_INLINE MTL::TensorDescriptor* MTL::TensorDescriptor::init()
{
    return NS::Object::init<MTL::TensorDescriptor>();
}

_MTL_INLINE MTL::ResourceOptions MTL::TensorDescriptor::resourceOptions() const
{
    return Object::sendMessage<MTL::ResourceOptions>(this, _MTL_PRIVATE_SEL(resourceOptions));
}

_MTL_INLINE void MTL::TensorDescriptor::setCpuCacheMode(MTL::CPUCacheMode cpuCacheMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setCpuCacheMode_), cpuCacheMode);
}

_MTL_INLINE void MTL::TensorDescriptor::setDataType(MTL::TensorDataType dataType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDataType_), dataType);
}

_MTL_INLINE void MTL::TensorDescriptor::setDimensions(const MTL::TensorExtents* dimensions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDimensions_), dimensions);
}

_MTL_INLINE void MTL::TensorDescriptor::setHazardTrackingMode(MTL::HazardTrackingMode hazardTrackingMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setHazardTrackingMode_), hazardTrackingMode);
}

_MTL_INLINE void MTL::TensorDescriptor::setResourceOptions(MTL::ResourceOptions resourceOptions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setResourceOptions_), resourceOptions);
}

_MTL_INLINE void MTL::TensorDescriptor::setStorageMode(MTL::StorageMode storageMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStorageMode_), storageMode);
}

_MTL_INLINE void MTL::TensorDescriptor::setStrides(const MTL::TensorExtents* strides)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStrides_), strides);
}

_MTL_INLINE void MTL::TensorDescriptor::setUsage(MTL::TensorUsage usage)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setUsage_), usage);
}

_MTL_INLINE MTL::StorageMode MTL::TensorDescriptor::storageMode() const
{
    return Object::sendMessage<MTL::StorageMode>(this, _MTL_PRIVATE_SEL(storageMode));
}

_MTL_INLINE MTL::TensorExtents* MTL::TensorDescriptor::strides() const
{
    return Object::sendMessage<MTL::TensorExtents*>(this, _MTL_PRIVATE_SEL(strides));
}

_MTL_INLINE MTL::TensorUsage MTL::TensorDescriptor::usage() const
{
    return Object::sendMessage<MTL::TensorUsage>(this, _MTL_PRIVATE_SEL(usage));
}

_MTL_INLINE MTL::Buffer* MTL::Tensor::buffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(buffer));
}

_MTL_INLINE NS::UInteger MTL::Tensor::bufferOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(bufferOffset));
}

_MTL_INLINE MTL::TensorDataType MTL::Tensor::dataType() const
{
    return Object::sendMessage<MTL::TensorDataType>(this, _MTL_PRIVATE_SEL(dataType));
}

_MTL_INLINE MTL::TensorExtents* MTL::Tensor::dimensions() const
{
    return Object::sendMessage<MTL::TensorExtents*>(this, _MTL_PRIVATE_SEL(dimensions));
}

_MTL_INLINE void MTL::Tensor::getBytes(void* bytes, const MTL::TensorExtents* strides, const MTL::TensorExtents* sliceOrigin, const MTL::TensorExtents* sliceDimensions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(getBytes_strides_fromSliceOrigin_sliceDimensions_), bytes, strides, sliceOrigin, sliceDimensions);
}

_MTL_INLINE MTL::ResourceID MTL::Tensor::gpuResourceID() const
{
    return Object::sendMessage<MTL::ResourceID>(this, _MTL_PRIVATE_SEL(gpuResourceID));
}

_MTL_INLINE void MTL::Tensor::replaceSliceOrigin(const MTL::TensorExtents* sliceOrigin, const MTL::TensorExtents* sliceDimensions, const void* bytes, const MTL::TensorExtents* strides)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(replaceSliceOrigin_sliceDimensions_withBytes_strides_), sliceOrigin, sliceDimensions, bytes, strides);
}

_MTL_INLINE MTL::TensorExtents* MTL::Tensor::strides() const
{
    return Object::sendMessage<MTL::TensorExtents*>(this, _MTL_PRIVATE_SEL(strides));
}

_MTL_INLINE MTL::TensorUsage MTL::Tensor::usage() const
{
    return Object::sendMessage<MTL::TensorUsage>(this, _MTL_PRIVATE_SEL(usage));
}

namespace MTL
{
class Argument;
class ArrayType;
class PointerType;
class StructMember;
class StructType;
class TensorExtents;
class TensorReferenceType;
class TextureReferenceType;
class Type;
_MTL_ENUM(NS::UInteger, IndexType) {
    IndexTypeUInt16 = 0,
    IndexTypeUInt32 = 1,
};

_MTL_ENUM(NS::Integer, BindingType) {
    BindingTypeBuffer = 0,
    BindingTypeThreadgroupMemory = 1,
    BindingTypeTexture = 2,
    BindingTypeSampler = 3,
    BindingTypeImageblockData = 16,
    BindingTypeImageblock = 17,
    BindingTypeVisibleFunctionTable = 24,
    BindingTypePrimitiveAccelerationStructure = 25,
    BindingTypeInstanceAccelerationStructure = 26,
    BindingTypeIntersectionFunctionTable = 27,
    BindingTypeObjectPayload = 34,
    BindingTypeTensor = 37,
};

_MTL_ENUM(NS::UInteger, ArgumentType) {
    ArgumentTypeBuffer = 0,
    ArgumentTypeThreadgroupMemory = 1,
    ArgumentTypeTexture = 2,
    ArgumentTypeSampler = 3,
    ArgumentTypeImageblockData = 16,
    ArgumentTypeImageblock = 17,
    ArgumentTypeVisibleFunctionTable = 24,
    ArgumentTypePrimitiveAccelerationStructure = 25,
    ArgumentTypeInstanceAccelerationStructure = 26,
    ArgumentTypeIntersectionFunctionTable = 27,
};

_MTL_ENUM(NS::UInteger, BindingAccess) {
    BindingAccessReadOnly = 0,
    BindingAccessReadWrite = 1,
    BindingAccessWriteOnly = 2,
    ArgumentAccessReadOnly = 0,
    ArgumentAccessReadWrite = 1,
    ArgumentAccessWriteOnly = 2,
};

class Type : public NS::Referencing<Type>
{
public:
    static Type* alloc();

    DataType     dataType() const;

    Type*        init();
};
class StructMember : public NS::Referencing<StructMember>
{
public:
    static StructMember*  alloc();

    NS::UInteger          argumentIndex() const;

    ArrayType*            arrayType();

    DataType              dataType() const;

    StructMember*         init();

    NS::String*           name() const;

    NS::UInteger          offset() const;

    PointerType*          pointerType();

    StructType*           structType();

    TensorReferenceType*  tensorReferenceType();

    TextureReferenceType* textureReferenceType();
};
class StructType : public NS::Referencing<StructType, Type>
{
public:
    static StructType* alloc();

    StructType*        init();

    StructMember*      memberByName(const NS::String* name);

    NS::Array*         members() const;
};
class ArrayType : public NS::Referencing<ArrayType, Type>
{
public:
    static ArrayType*     alloc();

    NS::UInteger          argumentIndexStride() const;

    NS::UInteger          arrayLength() const;

    ArrayType*            elementArrayType();

    PointerType*          elementPointerType();

    StructType*           elementStructType();

    TensorReferenceType*  elementTensorReferenceType();

    TextureReferenceType* elementTextureReferenceType();

    DataType              elementType() const;

    ArrayType*            init();

    NS::UInteger          stride() const;
};
class PointerType : public NS::Referencing<PointerType, Type>
{
public:
    BindingAccess       access() const;

    NS::UInteger        alignment() const;

    static PointerType* alloc();

    NS::UInteger        dataSize() const;

    ArrayType*          elementArrayType();

    bool                elementIsArgumentBuffer() const;

    StructType*         elementStructType();

    DataType            elementType() const;

    PointerType*        init();
};
class TextureReferenceType : public NS::Referencing<TextureReferenceType, Type>
{
public:
    BindingAccess                access() const;

    static TextureReferenceType* alloc();

    TextureReferenceType*        init();

    bool                         isDepthTexture() const;

    DataType                     textureDataType() const;

    TextureType                  textureType() const;
};
class TensorReferenceType : public NS::Referencing<TensorReferenceType, Type>
{
public:
    BindingAccess               access() const;

    static TensorReferenceType* alloc();

    TensorExtents*              dimensions() const;

    DataType                    indexType() const;

    TensorReferenceType*        init();

    TensorDataType              tensorDataType() const;
};
class Argument : public NS::Referencing<Argument>
{
public:
    BindingAccess access() const;

    [[deprecated("please use isActive instead")]]
    bool             active() const;

    static Argument* alloc();

    NS::UInteger     arrayLength() const;

    NS::UInteger     bufferAlignment() const;

    NS::UInteger     bufferDataSize() const;

    DataType         bufferDataType() const;

    PointerType*     bufferPointerType() const;

    StructType*      bufferStructType() const;

    NS::UInteger     index() const;

    Argument*        init();

    bool             isActive() const;

    bool             isDepthTexture() const;

    NS::String*      name() const;

    DataType         textureDataType() const;

    TextureType      textureType() const;

    NS::UInteger     threadgroupMemoryAlignment() const;

    NS::UInteger     threadgroupMemoryDataSize() const;

    ArgumentType     type() const;
};
class Binding : public NS::Referencing<Binding>
{
public:
    BindingAccess access() const;

    [[deprecated("please use isArgument instead")]]
    bool         argument() const;

    NS::UInteger index() const;

    bool         isArgument() const;

    bool         isUsed() const;

    NS::String*  name() const;

    BindingType  type() const;

    [[deprecated("please use isUsed instead")]]
    bool used() const;
};
class BufferBinding : public NS::Referencing<BufferBinding, Binding>
{
public:
    NS::UInteger bufferAlignment() const;

    NS::UInteger bufferDataSize() const;

    DataType     bufferDataType() const;

    PointerType* bufferPointerType() const;

    StructType*  bufferStructType() const;
};
class ThreadgroupBinding : public NS::Referencing<ThreadgroupBinding, Binding>
{
public:
    NS::UInteger threadgroupMemoryAlignment() const;

    NS::UInteger threadgroupMemoryDataSize() const;
};
class TextureBinding : public NS::Referencing<TextureBinding, Binding>
{
public:
    NS::UInteger arrayLength() const;

    [[deprecated("please use isDepthTexture instead")]]
    bool        depthTexture() const;
    bool        isDepthTexture() const;

    DataType    textureDataType() const;

    TextureType textureType() const;
};
class ObjectPayloadBinding : public NS::Referencing<ObjectPayloadBinding, Binding>
{
public:
    NS::UInteger objectPayloadAlignment() const;

    NS::UInteger objectPayloadDataSize() const;
};
class TensorBinding : public NS::Referencing<TensorBinding, Binding>
{
public:
    TensorExtents* dimensions() const;

    DataType       indexType() const;

    TensorDataType tensorDataType() const;
};

}
_MTL_INLINE MTL::Type* MTL::Type::alloc()
{
    return NS::Object::alloc<MTL::Type>(_MTL_PRIVATE_CLS(MTLType));
}

_MTL_INLINE MTL::DataType MTL::Type::dataType() const
{
    return Object::sendMessage<MTL::DataType>(this, _MTL_PRIVATE_SEL(dataType));
}

_MTL_INLINE MTL::Type* MTL::Type::init()
{
    return NS::Object::init<MTL::Type>();
}

_MTL_INLINE MTL::StructMember* MTL::StructMember::alloc()
{
    return NS::Object::alloc<MTL::StructMember>(_MTL_PRIVATE_CLS(MTLStructMember));
}

_MTL_INLINE NS::UInteger MTL::StructMember::argumentIndex() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(argumentIndex));
}

_MTL_INLINE MTL::ArrayType* MTL::StructMember::arrayType()
{
    return Object::sendMessage<MTL::ArrayType*>(this, _MTL_PRIVATE_SEL(arrayType));
}

_MTL_INLINE MTL::DataType MTL::StructMember::dataType() const
{
    return Object::sendMessage<MTL::DataType>(this, _MTL_PRIVATE_SEL(dataType));
}

_MTL_INLINE MTL::StructMember* MTL::StructMember::init()
{
    return NS::Object::init<MTL::StructMember>();
}

_MTL_INLINE NS::String* MTL::StructMember::name() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(name));
}

_MTL_INLINE NS::UInteger MTL::StructMember::offset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(offset));
}

_MTL_INLINE MTL::PointerType* MTL::StructMember::pointerType()
{
    return Object::sendMessage<MTL::PointerType*>(this, _MTL_PRIVATE_SEL(pointerType));
}

_MTL_INLINE MTL::StructType* MTL::StructMember::structType()
{
    return Object::sendMessage<MTL::StructType*>(this, _MTL_PRIVATE_SEL(structType));
}

_MTL_INLINE MTL::TensorReferenceType* MTL::StructMember::tensorReferenceType()
{
    return Object::sendMessage<MTL::TensorReferenceType*>(this, _MTL_PRIVATE_SEL(tensorReferenceType));
}

_MTL_INLINE MTL::TextureReferenceType* MTL::StructMember::textureReferenceType()
{
    return Object::sendMessage<MTL::TextureReferenceType*>(this, _MTL_PRIVATE_SEL(textureReferenceType));
}

_MTL_INLINE MTL::StructType* MTL::StructType::alloc()
{
    return NS::Object::alloc<MTL::StructType>(_MTL_PRIVATE_CLS(MTLStructType));
}

_MTL_INLINE MTL::StructType* MTL::StructType::init()
{
    return NS::Object::init<MTL::StructType>();
}

_MTL_INLINE MTL::StructMember* MTL::StructType::memberByName(const NS::String* name)
{
    return Object::sendMessage<MTL::StructMember*>(this, _MTL_PRIVATE_SEL(memberByName_), name);
}

_MTL_INLINE NS::Array* MTL::StructType::members() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(members));
}

_MTL_INLINE MTL::ArrayType* MTL::ArrayType::alloc()
{
    return NS::Object::alloc<MTL::ArrayType>(_MTL_PRIVATE_CLS(MTLArrayType));
}

_MTL_INLINE NS::UInteger MTL::ArrayType::argumentIndexStride() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(argumentIndexStride));
}

_MTL_INLINE NS::UInteger MTL::ArrayType::arrayLength() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(arrayLength));
}

_MTL_INLINE MTL::ArrayType* MTL::ArrayType::elementArrayType()
{
    return Object::sendMessage<MTL::ArrayType*>(this, _MTL_PRIVATE_SEL(elementArrayType));
}

_MTL_INLINE MTL::PointerType* MTL::ArrayType::elementPointerType()
{
    return Object::sendMessage<MTL::PointerType*>(this, _MTL_PRIVATE_SEL(elementPointerType));
}

_MTL_INLINE MTL::StructType* MTL::ArrayType::elementStructType()
{
    return Object::sendMessage<MTL::StructType*>(this, _MTL_PRIVATE_SEL(elementStructType));
}

_MTL_INLINE MTL::TensorReferenceType* MTL::ArrayType::elementTensorReferenceType()
{
    return Object::sendMessage<MTL::TensorReferenceType*>(this, _MTL_PRIVATE_SEL(elementTensorReferenceType));
}

_MTL_INLINE MTL::TextureReferenceType* MTL::ArrayType::elementTextureReferenceType()
{
    return Object::sendMessage<MTL::TextureReferenceType*>(this, _MTL_PRIVATE_SEL(elementTextureReferenceType));
}

_MTL_INLINE MTL::DataType MTL::ArrayType::elementType() const
{
    return Object::sendMessage<MTL::DataType>(this, _MTL_PRIVATE_SEL(elementType));
}

_MTL_INLINE MTL::ArrayType* MTL::ArrayType::init()
{
    return NS::Object::init<MTL::ArrayType>();
}

_MTL_INLINE NS::UInteger MTL::ArrayType::stride() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(stride));
}

_MTL_INLINE MTL::BindingAccess MTL::PointerType::access() const
{
    return Object::sendMessage<MTL::BindingAccess>(this, _MTL_PRIVATE_SEL(access));
}

_MTL_INLINE NS::UInteger MTL::PointerType::alignment() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(alignment));
}

_MTL_INLINE MTL::PointerType* MTL::PointerType::alloc()
{
    return NS::Object::alloc<MTL::PointerType>(_MTL_PRIVATE_CLS(MTLPointerType));
}

_MTL_INLINE NS::UInteger MTL::PointerType::dataSize() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(dataSize));
}

_MTL_INLINE MTL::ArrayType* MTL::PointerType::elementArrayType()
{
    return Object::sendMessage<MTL::ArrayType*>(this, _MTL_PRIVATE_SEL(elementArrayType));
}

_MTL_INLINE bool MTL::PointerType::elementIsArgumentBuffer() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(elementIsArgumentBuffer));
}

_MTL_INLINE MTL::StructType* MTL::PointerType::elementStructType()
{
    return Object::sendMessage<MTL::StructType*>(this, _MTL_PRIVATE_SEL(elementStructType));
}

_MTL_INLINE MTL::DataType MTL::PointerType::elementType() const
{
    return Object::sendMessage<MTL::DataType>(this, _MTL_PRIVATE_SEL(elementType));
}

_MTL_INLINE MTL::PointerType* MTL::PointerType::init()
{
    return NS::Object::init<MTL::PointerType>();
}

_MTL_INLINE MTL::BindingAccess MTL::TextureReferenceType::access() const
{
    return Object::sendMessage<MTL::BindingAccess>(this, _MTL_PRIVATE_SEL(access));
}

_MTL_INLINE MTL::TextureReferenceType* MTL::TextureReferenceType::alloc()
{
    return NS::Object::alloc<MTL::TextureReferenceType>(_MTL_PRIVATE_CLS(MTLTextureReferenceType));
}

_MTL_INLINE MTL::TextureReferenceType* MTL::TextureReferenceType::init()
{
    return NS::Object::init<MTL::TextureReferenceType>();
}

_MTL_INLINE bool MTL::TextureReferenceType::isDepthTexture() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isDepthTexture));
}

_MTL_INLINE MTL::DataType MTL::TextureReferenceType::textureDataType() const
{
    return Object::sendMessage<MTL::DataType>(this, _MTL_PRIVATE_SEL(textureDataType));
}

_MTL_INLINE MTL::TextureType MTL::TextureReferenceType::textureType() const
{
    return Object::sendMessage<MTL::TextureType>(this, _MTL_PRIVATE_SEL(textureType));
}

_MTL_INLINE MTL::BindingAccess MTL::TensorReferenceType::access() const
{
    return Object::sendMessage<MTL::BindingAccess>(this, _MTL_PRIVATE_SEL(access));
}

_MTL_INLINE MTL::TensorReferenceType* MTL::TensorReferenceType::alloc()
{
    return NS::Object::alloc<MTL::TensorReferenceType>(_MTL_PRIVATE_CLS(MTLTensorReferenceType));
}

_MTL_INLINE MTL::TensorExtents* MTL::TensorReferenceType::dimensions() const
{
    return Object::sendMessage<MTL::TensorExtents*>(this, _MTL_PRIVATE_SEL(dimensions));
}

_MTL_INLINE MTL::DataType MTL::TensorReferenceType::indexType() const
{
    return Object::sendMessage<MTL::DataType>(this, _MTL_PRIVATE_SEL(indexType));
}

_MTL_INLINE MTL::TensorReferenceType* MTL::TensorReferenceType::init()
{
    return NS::Object::init<MTL::TensorReferenceType>();
}

_MTL_INLINE MTL::TensorDataType MTL::TensorReferenceType::tensorDataType() const
{
    return Object::sendMessage<MTL::TensorDataType>(this, _MTL_PRIVATE_SEL(tensorDataType));
}

_MTL_INLINE MTL::BindingAccess MTL::Argument::access() const
{
    return Object::sendMessage<MTL::BindingAccess>(this, _MTL_PRIVATE_SEL(access));
}

_MTL_INLINE bool MTL::Argument::active() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isActive));
}

_MTL_INLINE MTL::Argument* MTL::Argument::alloc()
{
    return NS::Object::alloc<MTL::Argument>(_MTL_PRIVATE_CLS(MTLArgument));
}

_MTL_INLINE NS::UInteger MTL::Argument::arrayLength() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(arrayLength));
}

_MTL_INLINE NS::UInteger MTL::Argument::bufferAlignment() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(bufferAlignment));
}

_MTL_INLINE NS::UInteger MTL::Argument::bufferDataSize() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(bufferDataSize));
}

_MTL_INLINE MTL::DataType MTL::Argument::bufferDataType() const
{
    return Object::sendMessage<MTL::DataType>(this, _MTL_PRIVATE_SEL(bufferDataType));
}

_MTL_INLINE MTL::PointerType* MTL::Argument::bufferPointerType() const
{
    return Object::sendMessage<MTL::PointerType*>(this, _MTL_PRIVATE_SEL(bufferPointerType));
}

_MTL_INLINE MTL::StructType* MTL::Argument::bufferStructType() const
{
    return Object::sendMessage<MTL::StructType*>(this, _MTL_PRIVATE_SEL(bufferStructType));
}

_MTL_INLINE NS::UInteger MTL::Argument::index() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(index));
}

_MTL_INLINE MTL::Argument* MTL::Argument::init()
{
    return NS::Object::init<MTL::Argument>();
}

_MTL_INLINE bool MTL::Argument::isActive() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isActive));
}

_MTL_INLINE bool MTL::Argument::isDepthTexture() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isDepthTexture));
}

_MTL_INLINE NS::String* MTL::Argument::name() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(name));
}

_MTL_INLINE MTL::DataType MTL::Argument::textureDataType() const
{
    return Object::sendMessage<MTL::DataType>(this, _MTL_PRIVATE_SEL(textureDataType));
}

_MTL_INLINE MTL::TextureType MTL::Argument::textureType() const
{
    return Object::sendMessage<MTL::TextureType>(this, _MTL_PRIVATE_SEL(textureType));
}

_MTL_INLINE NS::UInteger MTL::Argument::threadgroupMemoryAlignment() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(threadgroupMemoryAlignment));
}

_MTL_INLINE NS::UInteger MTL::Argument::threadgroupMemoryDataSize() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(threadgroupMemoryDataSize));
}

_MTL_INLINE MTL::ArgumentType MTL::Argument::type() const
{
    return Object::sendMessage<MTL::ArgumentType>(this, _MTL_PRIVATE_SEL(type));
}

_MTL_INLINE MTL::BindingAccess MTL::Binding::access() const
{
    return Object::sendMessage<MTL::BindingAccess>(this, _MTL_PRIVATE_SEL(access));
}

_MTL_INLINE bool MTL::Binding::argument() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isArgument));
}

_MTL_INLINE NS::UInteger MTL::Binding::index() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(index));
}

_MTL_INLINE bool MTL::Binding::isArgument() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isArgument));
}

_MTL_INLINE bool MTL::Binding::isUsed() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isUsed));
}

_MTL_INLINE NS::String* MTL::Binding::name() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(name));
}

_MTL_INLINE MTL::BindingType MTL::Binding::type() const
{
    return Object::sendMessage<MTL::BindingType>(this, _MTL_PRIVATE_SEL(type));
}

_MTL_INLINE bool MTL::Binding::used() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isUsed));
}

_MTL_INLINE NS::UInteger MTL::BufferBinding::bufferAlignment() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(bufferAlignment));
}

_MTL_INLINE NS::UInteger MTL::BufferBinding::bufferDataSize() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(bufferDataSize));
}

_MTL_INLINE MTL::DataType MTL::BufferBinding::bufferDataType() const
{
    return Object::sendMessage<MTL::DataType>(this, _MTL_PRIVATE_SEL(bufferDataType));
}

_MTL_INLINE MTL::PointerType* MTL::BufferBinding::bufferPointerType() const
{
    return Object::sendMessage<MTL::PointerType*>(this, _MTL_PRIVATE_SEL(bufferPointerType));
}

_MTL_INLINE MTL::StructType* MTL::BufferBinding::bufferStructType() const
{
    return Object::sendMessage<MTL::StructType*>(this, _MTL_PRIVATE_SEL(bufferStructType));
}

_MTL_INLINE NS::UInteger MTL::ThreadgroupBinding::threadgroupMemoryAlignment() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(threadgroupMemoryAlignment));
}

_MTL_INLINE NS::UInteger MTL::ThreadgroupBinding::threadgroupMemoryDataSize() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(threadgroupMemoryDataSize));
}

_MTL_INLINE NS::UInteger MTL::TextureBinding::arrayLength() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(arrayLength));
}

_MTL_INLINE bool MTL::TextureBinding::depthTexture() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isDepthTexture));
}

_MTL_INLINE bool MTL::TextureBinding::isDepthTexture() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isDepthTexture));
}

_MTL_INLINE MTL::DataType MTL::TextureBinding::textureDataType() const
{
    return Object::sendMessage<MTL::DataType>(this, _MTL_PRIVATE_SEL(textureDataType));
}

_MTL_INLINE MTL::TextureType MTL::TextureBinding::textureType() const
{
    return Object::sendMessage<MTL::TextureType>(this, _MTL_PRIVATE_SEL(textureType));
}

_MTL_INLINE NS::UInteger MTL::ObjectPayloadBinding::objectPayloadAlignment() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(objectPayloadAlignment));
}

_MTL_INLINE NS::UInteger MTL::ObjectPayloadBinding::objectPayloadDataSize() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(objectPayloadDataSize));
}

_MTL_INLINE MTL::TensorExtents* MTL::TensorBinding::dimensions() const
{
    return Object::sendMessage<MTL::TensorExtents*>(this, _MTL_PRIVATE_SEL(dimensions));
}

_MTL_INLINE MTL::DataType MTL::TensorBinding::indexType() const
{
    return Object::sendMessage<MTL::DataType>(this, _MTL_PRIVATE_SEL(indexType));
}

_MTL_INLINE MTL::TensorDataType MTL::TensorBinding::tensorDataType() const
{
    return Object::sendMessage<MTL::TensorDataType>(this, _MTL_PRIVATE_SEL(tensorDataType));
}

namespace MTL
{
class AttributeDescriptor;
class AttributeDescriptorArray;
class BufferLayoutDescriptor;
class BufferLayoutDescriptorArray;
class StageInputOutputDescriptor;
_MTL_ENUM(NS::UInteger, AttributeFormat) {
    AttributeFormatInvalid = 0,
    AttributeFormatUChar2 = 1,
    AttributeFormatUChar3 = 2,
    AttributeFormatUChar4 = 3,
    AttributeFormatChar2 = 4,
    AttributeFormatChar3 = 5,
    AttributeFormatChar4 = 6,
    AttributeFormatUChar2Normalized = 7,
    AttributeFormatUChar3Normalized = 8,
    AttributeFormatUChar4Normalized = 9,
    AttributeFormatChar2Normalized = 10,
    AttributeFormatChar3Normalized = 11,
    AttributeFormatChar4Normalized = 12,
    AttributeFormatUShort2 = 13,
    AttributeFormatUShort3 = 14,
    AttributeFormatUShort4 = 15,
    AttributeFormatShort2 = 16,
    AttributeFormatShort3 = 17,
    AttributeFormatShort4 = 18,
    AttributeFormatUShort2Normalized = 19,
    AttributeFormatUShort3Normalized = 20,
    AttributeFormatUShort4Normalized = 21,
    AttributeFormatShort2Normalized = 22,
    AttributeFormatShort3Normalized = 23,
    AttributeFormatShort4Normalized = 24,
    AttributeFormatHalf2 = 25,
    AttributeFormatHalf3 = 26,
    AttributeFormatHalf4 = 27,
    AttributeFormatFloat = 28,
    AttributeFormatFloat2 = 29,
    AttributeFormatFloat3 = 30,
    AttributeFormatFloat4 = 31,
    AttributeFormatInt = 32,
    AttributeFormatInt2 = 33,
    AttributeFormatInt3 = 34,
    AttributeFormatInt4 = 35,
    AttributeFormatUInt = 36,
    AttributeFormatUInt2 = 37,
    AttributeFormatUInt3 = 38,
    AttributeFormatUInt4 = 39,
    AttributeFormatInt1010102Normalized = 40,
    AttributeFormatUInt1010102Normalized = 41,
    AttributeFormatUChar4Normalized_BGRA = 42,
    AttributeFormatUChar = 45,
    AttributeFormatChar = 46,
    AttributeFormatUCharNormalized = 47,
    AttributeFormatCharNormalized = 48,
    AttributeFormatUShort = 49,
    AttributeFormatShort = 50,
    AttributeFormatUShortNormalized = 51,
    AttributeFormatShortNormalized = 52,
    AttributeFormatHalf = 53,
    AttributeFormatFloatRG11B10 = 54,
    AttributeFormatFloatRGB9E5 = 55,
};

_MTL_ENUM(NS::UInteger, StepFunction) {
    StepFunctionConstant = 0,
    StepFunctionPerVertex = 1,
    StepFunctionPerInstance = 2,
    StepFunctionPerPatch = 3,
    StepFunctionPerPatchControlPoint = 4,
    StepFunctionThreadPositionInGridX = 5,
    StepFunctionThreadPositionInGridY = 6,
    StepFunctionThreadPositionInGridXIndexed = 7,
    StepFunctionThreadPositionInGridYIndexed = 8,
};

class BufferLayoutDescriptor : public NS::Copying<BufferLayoutDescriptor>
{
public:
    static BufferLayoutDescriptor* alloc();

    BufferLayoutDescriptor*        init();

    void                           setStepFunction(MTL::StepFunction stepFunction);

    void                           setStepRate(NS::UInteger stepRate);

    void                           setStride(NS::UInteger stride);

    StepFunction                   stepFunction() const;

    NS::UInteger                   stepRate() const;

    NS::UInteger                   stride() const;
};
class BufferLayoutDescriptorArray : public NS::Referencing<BufferLayoutDescriptorArray>
{
public:
    static BufferLayoutDescriptorArray* alloc();

    BufferLayoutDescriptorArray*        init();

    BufferLayoutDescriptor*             object(NS::UInteger index);
    void                                setObject(const MTL::BufferLayoutDescriptor* bufferDesc, NS::UInteger index);
};
class AttributeDescriptor : public NS::Copying<AttributeDescriptor>
{
public:
    static AttributeDescriptor* alloc();

    NS::UInteger                bufferIndex() const;

    AttributeFormat             format() const;

    AttributeDescriptor*        init();

    NS::UInteger                offset() const;

    void                        setBufferIndex(NS::UInteger bufferIndex);

    void                        setFormat(MTL::AttributeFormat format);

    void                        setOffset(NS::UInteger offset);
};
class AttributeDescriptorArray : public NS::Referencing<AttributeDescriptorArray>
{
public:
    static AttributeDescriptorArray* alloc();

    AttributeDescriptorArray*        init();

    AttributeDescriptor*             object(NS::UInteger index);
    void                             setObject(const MTL::AttributeDescriptor* attributeDesc, NS::UInteger index);
};
class StageInputOutputDescriptor : public NS::Copying<StageInputOutputDescriptor>
{
public:
    static StageInputOutputDescriptor* alloc();

    AttributeDescriptorArray*          attributes() const;

    NS::UInteger                       indexBufferIndex() const;

    IndexType                          indexType() const;

    StageInputOutputDescriptor*        init();

    BufferLayoutDescriptorArray*       layouts() const;

    void                               reset();

    void                               setIndexBufferIndex(NS::UInteger indexBufferIndex);

    void                               setIndexType(MTL::IndexType indexType);

    static StageInputOutputDescriptor* stageInputOutputDescriptor();
};

}
_MTL_INLINE MTL::BufferLayoutDescriptor* MTL::BufferLayoutDescriptor::alloc()
{
    return NS::Object::alloc<MTL::BufferLayoutDescriptor>(_MTL_PRIVATE_CLS(MTLBufferLayoutDescriptor));
}

_MTL_INLINE MTL::BufferLayoutDescriptor* MTL::BufferLayoutDescriptor::init()
{
    return NS::Object::init<MTL::BufferLayoutDescriptor>();
}

_MTL_INLINE void MTL::BufferLayoutDescriptor::setStepFunction(MTL::StepFunction stepFunction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStepFunction_), stepFunction);
}

_MTL_INLINE void MTL::BufferLayoutDescriptor::setStepRate(NS::UInteger stepRate)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStepRate_), stepRate);
}

_MTL_INLINE void MTL::BufferLayoutDescriptor::setStride(NS::UInteger stride)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStride_), stride);
}

_MTL_INLINE MTL::StepFunction MTL::BufferLayoutDescriptor::stepFunction() const
{
    return Object::sendMessage<MTL::StepFunction>(this, _MTL_PRIVATE_SEL(stepFunction));
}

_MTL_INLINE NS::UInteger MTL::BufferLayoutDescriptor::stepRate() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(stepRate));
}

_MTL_INLINE NS::UInteger MTL::BufferLayoutDescriptor::stride() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(stride));
}

_MTL_INLINE MTL::BufferLayoutDescriptorArray* MTL::BufferLayoutDescriptorArray::alloc()
{
    return NS::Object::alloc<MTL::BufferLayoutDescriptorArray>(_MTL_PRIVATE_CLS(MTLBufferLayoutDescriptorArray));
}

_MTL_INLINE MTL::BufferLayoutDescriptorArray* MTL::BufferLayoutDescriptorArray::init()
{
    return NS::Object::init<MTL::BufferLayoutDescriptorArray>();
}

_MTL_INLINE MTL::BufferLayoutDescriptor* MTL::BufferLayoutDescriptorArray::object(NS::UInteger index)
{
    return Object::sendMessage<MTL::BufferLayoutDescriptor*>(this, _MTL_PRIVATE_SEL(objectAtIndexedSubscript_), index);
}

_MTL_INLINE void MTL::BufferLayoutDescriptorArray::setObject(const MTL::BufferLayoutDescriptor* bufferDesc, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObject_atIndexedSubscript_), bufferDesc, index);
}

_MTL_INLINE MTL::AttributeDescriptor* MTL::AttributeDescriptor::alloc()
{
    return NS::Object::alloc<MTL::AttributeDescriptor>(_MTL_PRIVATE_CLS(MTLAttributeDescriptor));
}

_MTL_INLINE NS::UInteger MTL::AttributeDescriptor::bufferIndex() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(bufferIndex));
}

_MTL_INLINE MTL::AttributeFormat MTL::AttributeDescriptor::format() const
{
    return Object::sendMessage<MTL::AttributeFormat>(this, _MTL_PRIVATE_SEL(format));
}

_MTL_INLINE MTL::AttributeDescriptor* MTL::AttributeDescriptor::init()
{
    return NS::Object::init<MTL::AttributeDescriptor>();
}

_MTL_INLINE NS::UInteger MTL::AttributeDescriptor::offset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(offset));
}

_MTL_INLINE void MTL::AttributeDescriptor::setBufferIndex(NS::UInteger bufferIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBufferIndex_), bufferIndex);
}

_MTL_INLINE void MTL::AttributeDescriptor::setFormat(MTL::AttributeFormat format)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFormat_), format);
}

_MTL_INLINE void MTL::AttributeDescriptor::setOffset(NS::UInteger offset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setOffset_), offset);
}

_MTL_INLINE MTL::AttributeDescriptorArray* MTL::AttributeDescriptorArray::alloc()
{
    return NS::Object::alloc<MTL::AttributeDescriptorArray>(_MTL_PRIVATE_CLS(MTLAttributeDescriptorArray));
}

_MTL_INLINE MTL::AttributeDescriptorArray* MTL::AttributeDescriptorArray::init()
{
    return NS::Object::init<MTL::AttributeDescriptorArray>();
}

_MTL_INLINE MTL::AttributeDescriptor* MTL::AttributeDescriptorArray::object(NS::UInteger index)
{
    return Object::sendMessage<MTL::AttributeDescriptor*>(this, _MTL_PRIVATE_SEL(objectAtIndexedSubscript_), index);
}

_MTL_INLINE void MTL::AttributeDescriptorArray::setObject(const MTL::AttributeDescriptor* attributeDesc, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObject_atIndexedSubscript_), attributeDesc, index);
}

_MTL_INLINE MTL::StageInputOutputDescriptor* MTL::StageInputOutputDescriptor::alloc()
{
    return NS::Object::alloc<MTL::StageInputOutputDescriptor>(_MTL_PRIVATE_CLS(MTLStageInputOutputDescriptor));
}

_MTL_INLINE MTL::AttributeDescriptorArray* MTL::StageInputOutputDescriptor::attributes() const
{
    return Object::sendMessage<MTL::AttributeDescriptorArray*>(this, _MTL_PRIVATE_SEL(attributes));
}

_MTL_INLINE NS::UInteger MTL::StageInputOutputDescriptor::indexBufferIndex() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(indexBufferIndex));
}

_MTL_INLINE MTL::IndexType MTL::StageInputOutputDescriptor::indexType() const
{
    return Object::sendMessage<MTL::IndexType>(this, _MTL_PRIVATE_SEL(indexType));
}

_MTL_INLINE MTL::StageInputOutputDescriptor* MTL::StageInputOutputDescriptor::init()
{
    return NS::Object::init<MTL::StageInputOutputDescriptor>();
}

_MTL_INLINE MTL::BufferLayoutDescriptorArray* MTL::StageInputOutputDescriptor::layouts() const
{
    return Object::sendMessage<MTL::BufferLayoutDescriptorArray*>(this, _MTL_PRIVATE_SEL(layouts));
}

_MTL_INLINE void MTL::StageInputOutputDescriptor::reset()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(reset));
}

_MTL_INLINE void MTL::StageInputOutputDescriptor::setIndexBufferIndex(NS::UInteger indexBufferIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIndexBufferIndex_), indexBufferIndex);
}

_MTL_INLINE void MTL::StageInputOutputDescriptor::setIndexType(MTL::IndexType indexType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIndexType_), indexType);
}

_MTL_INLINE MTL::StageInputOutputDescriptor* MTL::StageInputOutputDescriptor::stageInputOutputDescriptor()
{
    return Object::sendMessage<MTL::StageInputOutputDescriptor*>(_MTL_PRIVATE_CLS(MTLStageInputOutputDescriptor), _MTL_PRIVATE_SEL(stageInputOutputDescriptor));
}

#include <cstdint>

namespace MTL
{

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wnested-anon-types"
struct PackedFloat3
{
    PackedFloat3();
    PackedFloat3(float x, float y, float z);

    float& operator[](int idx);
    float  operator[](int idx) const;

    union
    {
        struct
        {
            float x;
            float y;
            float z;
        };

        float elements[3];
    };
} _MTL_PACKED;
#pragma clang diagnostic pop

struct PackedFloat4x3
{
    PackedFloat4x3();
    PackedFloat4x3(const PackedFloat3& col0, const PackedFloat3& col1, const PackedFloat3& col2, const PackedFloat3& col3);

    PackedFloat3&       operator[](int idx);
    const PackedFloat3& operator[](int idx) const;

    PackedFloat3        columns[4];
} _MTL_PACKED;

struct AxisAlignedBoundingBox
{
    AxisAlignedBoundingBox();
    AxisAlignedBoundingBox(PackedFloat3 p);
    AxisAlignedBoundingBox(PackedFloat3 min, PackedFloat3 max);

    PackedFloat3 min;
    PackedFloat3 max;
} _MTL_PACKED;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wnested-anon-types"
struct PackedFloatQuaternion
{
    PackedFloatQuaternion();
    PackedFloatQuaternion(float x, float y, float z, float w);

    float&       operator[](int idx);
    const float& operator[](int idx) const;

    union 
    {
        struct
        {
            float x;
            float y;
            float z;
            float w;
        };

        float elements[4];
    };
    
} _MTL_PACKED;
#pragma clang diagnostic pop

struct ComponentTransform
{
    PackedFloat3          scale;
    PackedFloat3          shear;
    PackedFloat3          pivot;
    PackedFloatQuaternion rotation;
    PackedFloat3          translation;
} _MTL_PACKED;

}

namespace MTL4
{

struct BufferRange
{
    BufferRange() = default;
    BufferRange(uint64_t bufferAddress);
    BufferRange(uint64_t bufferAddress, uint64_t length);

    static MTL4::BufferRange Make(uint64_t bufferAddress, uint64_t length);

    uint64_t          bufferAddress;
    uint64_t          length;
} _MTL_PACKED;

}

_MTL_INLINE MTL::PackedFloat3::PackedFloat3()
    : x(0.0f)
    , y(0.0f)
    , z(0.0f)
{
}

_MTL_INLINE MTL::PackedFloat3::PackedFloat3(float _x, float _y, float _z)
    : x(_x)
    , y(_y)
    , z(_z)
{
}

_MTL_INLINE float& MTL::PackedFloat3::operator[](int idx)
{
    return elements[idx];
}

_MTL_INLINE float MTL::PackedFloat3::operator[](int idx) const
{
    return elements[idx];
}

_MTL_INLINE MTL::PackedFloat4x3::PackedFloat4x3()
{
    columns[0] = PackedFloat3(0.0f, 0.0f, 0.0f);
    columns[1] = PackedFloat3(0.0f, 0.0f, 0.0f);
    columns[2] = PackedFloat3(0.0f, 0.0f, 0.0f);
    columns[3] = PackedFloat3(0.0f, 0.0f, 0.0f);
}

_MTL_INLINE MTL::PackedFloat4x3::PackedFloat4x3(const PackedFloat3& col0, const PackedFloat3& col1, const PackedFloat3& col2, const PackedFloat3& col3)
{
    columns[0] = col0;
    columns[1] = col1;
    columns[2] = col2;
    columns[3] = col3;
}

_MTL_INLINE MTL::PackedFloat3& MTL::PackedFloat4x3::operator[](int idx)
{
    return columns[idx];
}

_MTL_INLINE const MTL::PackedFloat3& MTL::PackedFloat4x3::operator[](int idx) const
{
    return columns[idx];
}

#if __apple_build_version__ > 16000026
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wnan-infinity-disabled"
#endif // __apple_build_version__ > 16000026
_MTL_INLINE MTL::AxisAlignedBoundingBox::AxisAlignedBoundingBox()
    : min(INFINITY, INFINITY, INFINITY)
    , max(-INFINITY, -INFINITY, -INFINITY)
{
}
#if __apple_build_version__ > 16000026
#pragma clang diagnostic pop
#endif // if __apple_build_version__ > 16000026

_MTL_INLINE MTL::AxisAlignedBoundingBox::AxisAlignedBoundingBox(PackedFloat3 p)
    : min(p)
    , max(p)
{
}

_MTL_INLINE MTL::AxisAlignedBoundingBox::AxisAlignedBoundingBox(PackedFloat3 _min, PackedFloat3 _max)
    : min(_min)
    , max(_max)
{
}

_MTL_INLINE MTL::PackedFloatQuaternion::PackedFloatQuaternion()
    : x(0.0f)
    , y(0.0f)
    , z(0.0f)
    , w(0.0f)
{
}

_MTL_INLINE MTL::PackedFloatQuaternion::PackedFloatQuaternion(float x, float y, float z, float w)
    : x(x)
    , y(y)
    , z(z)
    , w(w)
{
}

_MTL_INLINE float& MTL::PackedFloatQuaternion::operator[](int idx)
{
    return elements[idx];
}

_MTL_INLINE const float& MTL::PackedFloatQuaternion::operator[](int idx) const
{
    return elements[idx];
}

_MTL_INLINE MTL4::BufferRange::BufferRange(uint64_t bufferAddress)
: bufferAddress(bufferAddress)
, length(-1)
{
}

_MTL_INLINE MTL4::BufferRange::BufferRange(uint64_t bufferAddress, uint64_t length)
: bufferAddress(bufferAddress)
, length(length)
{
}

_MTL_INLINE MTL4::BufferRange MTL4::BufferRange::Make(uint64_t bufferAddress, uint64_t length)
{
    return MTL4::BufferRange(bufferAddress, length);
}

#include <cstdint>

namespace MTL
{
class AccelerationStructureBoundingBoxGeometryDescriptor;
class AccelerationStructureCurveGeometryDescriptor;
class AccelerationStructureDescriptor;
class AccelerationStructureGeometryDescriptor;
class AccelerationStructureMotionBoundingBoxGeometryDescriptor;
class AccelerationStructureMotionCurveGeometryDescriptor;
class AccelerationStructureMotionTriangleGeometryDescriptor;
class AccelerationStructureTriangleGeometryDescriptor;
class Buffer;
class IndirectInstanceAccelerationStructureDescriptor;
class InstanceAccelerationStructureDescriptor;
class MotionKeyframeData;
class PrimitiveAccelerationStructureDescriptor;
}

namespace MTL
{
_MTL_ENUM(NS::Integer, MatrixLayout) {
    MatrixLayoutColumnMajor = 0,
    MatrixLayoutRowMajor = 1,
};

_MTL_ENUM(uint32_t, MotionBorderMode) {
    MotionBorderModeClamp = 0,
    MotionBorderModeVanish = 1,
};

_MTL_ENUM(NS::Integer, CurveType) {
    CurveTypeRound = 0,
    CurveTypeFlat = 1,
};

_MTL_ENUM(NS::Integer, CurveBasis) {
    CurveBasisBSpline = 0,
    CurveBasisCatmullRom = 1,
    CurveBasisLinear = 2,
    CurveBasisBezier = 3,
};

_MTL_ENUM(NS::Integer, CurveEndCaps) {
    CurveEndCapsNone = 0,
    CurveEndCapsDisk = 1,
    CurveEndCapsSphere = 2,
};

_MTL_ENUM(NS::UInteger, AccelerationStructureInstanceDescriptorType) {
    AccelerationStructureInstanceDescriptorTypeDefault = 0,
    AccelerationStructureInstanceDescriptorTypeUserID = 1,
    AccelerationStructureInstanceDescriptorTypeMotion = 2,
    AccelerationStructureInstanceDescriptorTypeIndirect = 3,
    AccelerationStructureInstanceDescriptorTypeIndirectMotion = 4,
};

_MTL_ENUM(NS::Integer, TransformType) {
    TransformTypePackedFloat4x3 = 0,
    TransformTypeComponent = 1,
};

_MTL_OPTIONS(NS::UInteger, AccelerationStructureRefitOptions) {
    AccelerationStructureRefitOptionVertexData = 1,
    AccelerationStructureRefitOptionPerPrimitiveData = 1 << 1,
};

_MTL_OPTIONS(NS::UInteger, AccelerationStructureUsage) {
    AccelerationStructureUsageNone = 0,
    AccelerationStructureUsageRefit = 1,
    AccelerationStructureUsagePreferFastBuild = 1 << 1,
    AccelerationStructureUsageExtendedLimits = 1 << 2,
    AccelerationStructureUsagePreferFastIntersection = 1 << 4,
    AccelerationStructureUsageMinimizeMemory = 1 << 5,
};

_MTL_OPTIONS(uint32_t, AccelerationStructureInstanceOptions) {
    AccelerationStructureInstanceOptionNone = 0,
    AccelerationStructureInstanceOptionDisableTriangleCulling = 1,
    AccelerationStructureInstanceOptionTriangleFrontFacingWindingCounterClockwise = 1 << 1,
    AccelerationStructureInstanceOptionOpaque = 1 << 2,
    AccelerationStructureInstanceOptionNonOpaque = 1 << 3,
};

struct AccelerationStructureInstanceDescriptor
{
    MTL::PackedFloat4x3                       transformationMatrix;
    MTL::AccelerationStructureInstanceOptions options;
    uint32_t                                  mask;
    uint32_t                                  intersectionFunctionTableOffset;
    uint32_t                                  accelerationStructureIndex;
} _MTL_PACKED;

struct AccelerationStructureUserIDInstanceDescriptor
{
    MTL::PackedFloat4x3                       transformationMatrix;
    MTL::AccelerationStructureInstanceOptions options;
    uint32_t                                  mask;
    uint32_t                                  intersectionFunctionTableOffset;
    uint32_t                                  accelerationStructureIndex;
    uint32_t                                  userID;
} _MTL_PACKED;

struct AccelerationStructureMotionInstanceDescriptor
{
    MTL::AccelerationStructureInstanceOptions options;
    uint32_t                                  mask;
    uint32_t                                  intersectionFunctionTableOffset;
    uint32_t                                  accelerationStructureIndex;
    uint32_t                                  userID;
    uint32_t                                  motionTransformsStartIndex;
    uint32_t                                  motionTransformsCount;
    MTL::MotionBorderMode                     motionStartBorderMode;
    MTL::MotionBorderMode                     motionEndBorderMode;
    float                                     motionStartTime;
    float                                     motionEndTime;
} _MTL_PACKED;

struct IndirectAccelerationStructureInstanceDescriptor
{
    MTL::PackedFloat4x3                       transformationMatrix;
    MTL::AccelerationStructureInstanceOptions options;
    uint32_t                                  mask;
    uint32_t                                  intersectionFunctionTableOffset;
    uint32_t                                  userID;
    MTL::ResourceID                           accelerationStructureID;
} _MTL_PACKED;

struct IndirectAccelerationStructureMotionInstanceDescriptor
{
    MTL::AccelerationStructureInstanceOptions options;
    uint32_t                                  mask;
    uint32_t                                  intersectionFunctionTableOffset;
    uint32_t                                  userID;
    MTL::ResourceID                           accelerationStructureID;
    uint32_t                                  motionTransformsStartIndex;
    uint32_t                                  motionTransformsCount;
    MTL::MotionBorderMode                     motionStartBorderMode;
    MTL::MotionBorderMode                     motionEndBorderMode;
    float                                     motionStartTime;
    float                                     motionEndTime;
} _MTL_PACKED;

class AccelerationStructureDescriptor : public NS::Copying<AccelerationStructureDescriptor>
{
public:
    static AccelerationStructureDescriptor* alloc();

    AccelerationStructureDescriptor*        init();

    void                                    setUsage(MTL::AccelerationStructureUsage usage);
    AccelerationStructureUsage              usage() const;
};
class AccelerationStructureGeometryDescriptor : public NS::Copying<AccelerationStructureGeometryDescriptor>
{
public:
    static AccelerationStructureGeometryDescriptor* alloc();

    bool                                            allowDuplicateIntersectionFunctionInvocation() const;

    AccelerationStructureGeometryDescriptor*        init();

    NS::UInteger                                    intersectionFunctionTableOffset() const;

    NS::String*                                     label() const;

    bool                                            opaque() const;

    Buffer*                                         primitiveDataBuffer() const;
    NS::UInteger                                    primitiveDataBufferOffset() const;

    NS::UInteger                                    primitiveDataElementSize() const;

    NS::UInteger                                    primitiveDataStride() const;

    void                                            setAllowDuplicateIntersectionFunctionInvocation(bool allowDuplicateIntersectionFunctionInvocation);

    void                                            setIntersectionFunctionTableOffset(NS::UInteger intersectionFunctionTableOffset);

    void                                            setLabel(const NS::String* label);

    void                                            setOpaque(bool opaque);

    void                                            setPrimitiveDataBuffer(const MTL::Buffer* primitiveDataBuffer);
    void                                            setPrimitiveDataBufferOffset(NS::UInteger primitiveDataBufferOffset);

    void                                            setPrimitiveDataElementSize(NS::UInteger primitiveDataElementSize);

    void                                            setPrimitiveDataStride(NS::UInteger primitiveDataStride);
};
class PrimitiveAccelerationStructureDescriptor : public NS::Copying<PrimitiveAccelerationStructureDescriptor, AccelerationStructureDescriptor>
{
public:
    static PrimitiveAccelerationStructureDescriptor* alloc();

    static PrimitiveAccelerationStructureDescriptor* descriptor();
    NS::Array*                                       geometryDescriptors() const;

    PrimitiveAccelerationStructureDescriptor*        init();

    MotionBorderMode                                 motionEndBorderMode() const;

    float                                            motionEndTime() const;

    NS::UInteger                                     motionKeyframeCount() const;

    MotionBorderMode                                 motionStartBorderMode() const;

    float                                            motionStartTime() const;

    void                                             setGeometryDescriptors(const NS::Array* geometryDescriptors);

    void                                             setMotionEndBorderMode(MTL::MotionBorderMode motionEndBorderMode);

    void                                             setMotionEndTime(float motionEndTime);

    void                                             setMotionKeyframeCount(NS::UInteger motionKeyframeCount);

    void                                             setMotionStartBorderMode(MTL::MotionBorderMode motionStartBorderMode);

    void                                             setMotionStartTime(float motionStartTime);
};
class AccelerationStructureTriangleGeometryDescriptor : public NS::Copying<AccelerationStructureTriangleGeometryDescriptor, AccelerationStructureGeometryDescriptor>
{
public:
    static AccelerationStructureTriangleGeometryDescriptor* alloc();

    static AccelerationStructureTriangleGeometryDescriptor* descriptor();

    Buffer*                                                 indexBuffer() const;
    NS::UInteger                                            indexBufferOffset() const;

    IndexType                                               indexType() const;

    AccelerationStructureTriangleGeometryDescriptor*        init();

    void                                                    setIndexBuffer(const MTL::Buffer* indexBuffer);
    void                                                    setIndexBufferOffset(NS::UInteger indexBufferOffset);

    void                                                    setIndexType(MTL::IndexType indexType);

    void                                                    setTransformationMatrixBuffer(const MTL::Buffer* transformationMatrixBuffer);
    void                                                    setTransformationMatrixBufferOffset(NS::UInteger transformationMatrixBufferOffset);

    void                                                    setTransformationMatrixLayout(MTL::MatrixLayout transformationMatrixLayout);

    void                                                    setTriangleCount(NS::UInteger triangleCount);

    void                                                    setVertexBuffer(const MTL::Buffer* vertexBuffer);
    void                                                    setVertexBufferOffset(NS::UInteger vertexBufferOffset);

    void                                                    setVertexFormat(MTL::AttributeFormat vertexFormat);

    void                                                    setVertexStride(NS::UInteger vertexStride);

    Buffer*                                                 transformationMatrixBuffer() const;
    NS::UInteger                                            transformationMatrixBufferOffset() const;

    MatrixLayout                                            transformationMatrixLayout() const;

    NS::UInteger                                            triangleCount() const;

    Buffer*                                                 vertexBuffer() const;
    NS::UInteger                                            vertexBufferOffset() const;

    AttributeFormat                                         vertexFormat() const;

    NS::UInteger                                            vertexStride() const;
};
class AccelerationStructureBoundingBoxGeometryDescriptor : public NS::Copying<AccelerationStructureBoundingBoxGeometryDescriptor, AccelerationStructureGeometryDescriptor>
{
public:
    static AccelerationStructureBoundingBoxGeometryDescriptor* alloc();

    Buffer*                                                    boundingBoxBuffer() const;
    NS::UInteger                                               boundingBoxBufferOffset() const;

    NS::UInteger                                               boundingBoxCount() const;

    NS::UInteger                                               boundingBoxStride() const;

    static AccelerationStructureBoundingBoxGeometryDescriptor* descriptor();

    AccelerationStructureBoundingBoxGeometryDescriptor*        init();

    void                                                       setBoundingBoxBuffer(const MTL::Buffer* boundingBoxBuffer);
    void                                                       setBoundingBoxBufferOffset(NS::UInteger boundingBoxBufferOffset);

    void                                                       setBoundingBoxCount(NS::UInteger boundingBoxCount);

    void                                                       setBoundingBoxStride(NS::UInteger boundingBoxStride);
};
class MotionKeyframeData : public NS::Referencing<MotionKeyframeData>
{
public:
    static MotionKeyframeData* alloc();

    Buffer*                    buffer() const;

    static MotionKeyframeData* data();

    MotionKeyframeData*        init();

    NS::UInteger               offset() const;

    void                       setBuffer(const MTL::Buffer* buffer);

    void                       setOffset(NS::UInteger offset);
};
class AccelerationStructureMotionTriangleGeometryDescriptor : public NS::Copying<AccelerationStructureMotionTriangleGeometryDescriptor, AccelerationStructureGeometryDescriptor>
{
public:
    static AccelerationStructureMotionTriangleGeometryDescriptor* alloc();

    static AccelerationStructureMotionTriangleGeometryDescriptor* descriptor();

    Buffer*                                                       indexBuffer() const;
    NS::UInteger                                                  indexBufferOffset() const;

    IndexType                                                     indexType() const;

    AccelerationStructureMotionTriangleGeometryDescriptor*        init();

    void                                                          setIndexBuffer(const MTL::Buffer* indexBuffer);
    void                                                          setIndexBufferOffset(NS::UInteger indexBufferOffset);

    void                                                          setIndexType(MTL::IndexType indexType);

    void                                                          setTransformationMatrixBuffer(const MTL::Buffer* transformationMatrixBuffer);
    void                                                          setTransformationMatrixBufferOffset(NS::UInteger transformationMatrixBufferOffset);

    void                                                          setTransformationMatrixLayout(MTL::MatrixLayout transformationMatrixLayout);

    void                                                          setTriangleCount(NS::UInteger triangleCount);

    void                                                          setVertexBuffers(const NS::Array* vertexBuffers);

    void                                                          setVertexFormat(MTL::AttributeFormat vertexFormat);

    void                                                          setVertexStride(NS::UInteger vertexStride);

    Buffer*                                                       transformationMatrixBuffer() const;
    NS::UInteger                                                  transformationMatrixBufferOffset() const;

    MatrixLayout                                                  transformationMatrixLayout() const;

    NS::UInteger                                                  triangleCount() const;

    NS::Array*                                                    vertexBuffers() const;

    AttributeFormat                                               vertexFormat() const;

    NS::UInteger                                                  vertexStride() const;
};
class AccelerationStructureMotionBoundingBoxGeometryDescriptor : public NS::Copying<AccelerationStructureMotionBoundingBoxGeometryDescriptor, AccelerationStructureGeometryDescriptor>
{
public:
    static AccelerationStructureMotionBoundingBoxGeometryDescriptor* alloc();

    NS::Array*                                                       boundingBoxBuffers() const;

    NS::UInteger                                                     boundingBoxCount() const;

    NS::UInteger                                                     boundingBoxStride() const;

    static AccelerationStructureMotionBoundingBoxGeometryDescriptor* descriptor();

    AccelerationStructureMotionBoundingBoxGeometryDescriptor*        init();

    void                                                             setBoundingBoxBuffers(const NS::Array* boundingBoxBuffers);

    void                                                             setBoundingBoxCount(NS::UInteger boundingBoxCount);

    void                                                             setBoundingBoxStride(NS::UInteger boundingBoxStride);
};
class AccelerationStructureCurveGeometryDescriptor : public NS::Copying<AccelerationStructureCurveGeometryDescriptor, AccelerationStructureGeometryDescriptor>
{
public:
    static AccelerationStructureCurveGeometryDescriptor* alloc();

    Buffer*                                              controlPointBuffer() const;
    NS::UInteger                                         controlPointBufferOffset() const;

    NS::UInteger                                         controlPointCount() const;

    AttributeFormat                                      controlPointFormat() const;

    NS::UInteger                                         controlPointStride() const;

    CurveBasis                                           curveBasis() const;

    CurveEndCaps                                         curveEndCaps() const;

    CurveType                                            curveType() const;

    static AccelerationStructureCurveGeometryDescriptor* descriptor();

    Buffer*                                              indexBuffer() const;
    NS::UInteger                                         indexBufferOffset() const;

    IndexType                                            indexType() const;

    AccelerationStructureCurveGeometryDescriptor*        init();

    Buffer*                                              radiusBuffer() const;
    NS::UInteger                                         radiusBufferOffset() const;

    AttributeFormat                                      radiusFormat() const;

    NS::UInteger                                         radiusStride() const;

    NS::UInteger                                         segmentControlPointCount() const;

    NS::UInteger                                         segmentCount() const;

    void                                                 setControlPointBuffer(const MTL::Buffer* controlPointBuffer);
    void                                                 setControlPointBufferOffset(NS::UInteger controlPointBufferOffset);

    void                                                 setControlPointCount(NS::UInteger controlPointCount);

    void                                                 setControlPointFormat(MTL::AttributeFormat controlPointFormat);

    void                                                 setControlPointStride(NS::UInteger controlPointStride);

    void                                                 setCurveBasis(MTL::CurveBasis curveBasis);

    void                                                 setCurveEndCaps(MTL::CurveEndCaps curveEndCaps);

    void                                                 setCurveType(MTL::CurveType curveType);

    void                                                 setIndexBuffer(const MTL::Buffer* indexBuffer);
    void                                                 setIndexBufferOffset(NS::UInteger indexBufferOffset);

    void                                                 setIndexType(MTL::IndexType indexType);

    void                                                 setRadiusBuffer(const MTL::Buffer* radiusBuffer);
    void                                                 setRadiusBufferOffset(NS::UInteger radiusBufferOffset);

    void                                                 setRadiusFormat(MTL::AttributeFormat radiusFormat);

    void                                                 setRadiusStride(NS::UInteger radiusStride);

    void                                                 setSegmentControlPointCount(NS::UInteger segmentControlPointCount);

    void                                                 setSegmentCount(NS::UInteger segmentCount);
};
class AccelerationStructureMotionCurveGeometryDescriptor : public NS::Copying<AccelerationStructureMotionCurveGeometryDescriptor, AccelerationStructureGeometryDescriptor>
{
public:
    static AccelerationStructureMotionCurveGeometryDescriptor* alloc();

    NS::Array*                                                 controlPointBuffers() const;

    NS::UInteger                                               controlPointCount() const;

    AttributeFormat                                            controlPointFormat() const;

    NS::UInteger                                               controlPointStride() const;

    CurveBasis                                                 curveBasis() const;

    CurveEndCaps                                               curveEndCaps() const;

    CurveType                                                  curveType() const;

    static AccelerationStructureMotionCurveGeometryDescriptor* descriptor();

    Buffer*                                                    indexBuffer() const;
    NS::UInteger                                               indexBufferOffset() const;

    IndexType                                                  indexType() const;

    AccelerationStructureMotionCurveGeometryDescriptor*        init();

    NS::Array*                                                 radiusBuffers() const;

    AttributeFormat                                            radiusFormat() const;

    NS::UInteger                                               radiusStride() const;

    NS::UInteger                                               segmentControlPointCount() const;

    NS::UInteger                                               segmentCount() const;

    void                                                       setControlPointBuffers(const NS::Array* controlPointBuffers);

    void                                                       setControlPointCount(NS::UInteger controlPointCount);

    void                                                       setControlPointFormat(MTL::AttributeFormat controlPointFormat);

    void                                                       setControlPointStride(NS::UInteger controlPointStride);

    void                                                       setCurveBasis(MTL::CurveBasis curveBasis);

    void                                                       setCurveEndCaps(MTL::CurveEndCaps curveEndCaps);

    void                                                       setCurveType(MTL::CurveType curveType);

    void                                                       setIndexBuffer(const MTL::Buffer* indexBuffer);
    void                                                       setIndexBufferOffset(NS::UInteger indexBufferOffset);

    void                                                       setIndexType(MTL::IndexType indexType);

    void                                                       setRadiusBuffers(const NS::Array* radiusBuffers);

    void                                                       setRadiusFormat(MTL::AttributeFormat radiusFormat);

    void                                                       setRadiusStride(NS::UInteger radiusStride);

    void                                                       setSegmentControlPointCount(NS::UInteger segmentControlPointCount);

    void                                                       setSegmentCount(NS::UInteger segmentCount);
};
class InstanceAccelerationStructureDescriptor : public NS::Copying<InstanceAccelerationStructureDescriptor, AccelerationStructureDescriptor>
{
public:
    static InstanceAccelerationStructureDescriptor* alloc();

    static InstanceAccelerationStructureDescriptor* descriptor();

    InstanceAccelerationStructureDescriptor*        init();

    NS::UInteger                                    instanceCount() const;

    Buffer*                                         instanceDescriptorBuffer() const;
    NS::UInteger                                    instanceDescriptorBufferOffset() const;

    NS::UInteger                                    instanceDescriptorStride() const;

    AccelerationStructureInstanceDescriptorType     instanceDescriptorType() const;

    MatrixLayout                                    instanceTransformationMatrixLayout() const;

    NS::Array*                                      instancedAccelerationStructures() const;

    Buffer*                                         motionTransformBuffer() const;
    NS::UInteger                                    motionTransformBufferOffset() const;

    NS::UInteger                                    motionTransformCount() const;

    NS::UInteger                                    motionTransformStride() const;

    TransformType                                   motionTransformType() const;

    void                                            setInstanceCount(NS::UInteger instanceCount);

    void                                            setInstanceDescriptorBuffer(const MTL::Buffer* instanceDescriptorBuffer);
    void                                            setInstanceDescriptorBufferOffset(NS::UInteger instanceDescriptorBufferOffset);

    void                                            setInstanceDescriptorStride(NS::UInteger instanceDescriptorStride);

    void                                            setInstanceDescriptorType(MTL::AccelerationStructureInstanceDescriptorType instanceDescriptorType);

    void                                            setInstanceTransformationMatrixLayout(MTL::MatrixLayout instanceTransformationMatrixLayout);

    void                                            setInstancedAccelerationStructures(const NS::Array* instancedAccelerationStructures);

    void                                            setMotionTransformBuffer(const MTL::Buffer* motionTransformBuffer);
    void                                            setMotionTransformBufferOffset(NS::UInteger motionTransformBufferOffset);

    void                                            setMotionTransformCount(NS::UInteger motionTransformCount);

    void                                            setMotionTransformStride(NS::UInteger motionTransformStride);

    void                                            setMotionTransformType(MTL::TransformType motionTransformType);
};
class IndirectInstanceAccelerationStructureDescriptor : public NS::Copying<IndirectInstanceAccelerationStructureDescriptor, AccelerationStructureDescriptor>
{
public:
    static IndirectInstanceAccelerationStructureDescriptor* alloc();

    static IndirectInstanceAccelerationStructureDescriptor* descriptor();

    IndirectInstanceAccelerationStructureDescriptor*        init();

    Buffer*                                                 instanceCountBuffer() const;
    NS::UInteger                                            instanceCountBufferOffset() const;

    Buffer*                                                 instanceDescriptorBuffer() const;
    NS::UInteger                                            instanceDescriptorBufferOffset() const;

    NS::UInteger                                            instanceDescriptorStride() const;

    AccelerationStructureInstanceDescriptorType             instanceDescriptorType() const;

    MatrixLayout                                            instanceTransformationMatrixLayout() const;

    NS::UInteger                                            maxInstanceCount() const;

    NS::UInteger                                            maxMotionTransformCount() const;

    Buffer*                                                 motionTransformBuffer() const;
    NS::UInteger                                            motionTransformBufferOffset() const;

    Buffer*                                                 motionTransformCountBuffer() const;
    NS::UInteger                                            motionTransformCountBufferOffset() const;

    NS::UInteger                                            motionTransformStride() const;

    TransformType                                           motionTransformType() const;

    void                                                    setInstanceCountBuffer(const MTL::Buffer* instanceCountBuffer);
    void                                                    setInstanceCountBufferOffset(NS::UInteger instanceCountBufferOffset);

    void                                                    setInstanceDescriptorBuffer(const MTL::Buffer* instanceDescriptorBuffer);
    void                                                    setInstanceDescriptorBufferOffset(NS::UInteger instanceDescriptorBufferOffset);

    void                                                    setInstanceDescriptorStride(NS::UInteger instanceDescriptorStride);

    void                                                    setInstanceDescriptorType(MTL::AccelerationStructureInstanceDescriptorType instanceDescriptorType);

    void                                                    setInstanceTransformationMatrixLayout(MTL::MatrixLayout instanceTransformationMatrixLayout);

    void                                                    setMaxInstanceCount(NS::UInteger maxInstanceCount);

    void                                                    setMaxMotionTransformCount(NS::UInteger maxMotionTransformCount);

    void                                                    setMotionTransformBuffer(const MTL::Buffer* motionTransformBuffer);
    void                                                    setMotionTransformBufferOffset(NS::UInteger motionTransformBufferOffset);

    void                                                    setMotionTransformCountBuffer(const MTL::Buffer* motionTransformCountBuffer);
    void                                                    setMotionTransformCountBufferOffset(NS::UInteger motionTransformCountBufferOffset);

    void                                                    setMotionTransformStride(NS::UInteger motionTransformStride);

    void                                                    setMotionTransformType(MTL::TransformType motionTransformType);
};
class AccelerationStructure : public NS::Referencing<AccelerationStructure, Resource>
{
public:
    ResourceID   gpuResourceID() const;

    NS::UInteger size() const;
};

}

_MTL_INLINE MTL::AccelerationStructureDescriptor* MTL::AccelerationStructureDescriptor::alloc()
{
    return NS::Object::alloc<MTL::AccelerationStructureDescriptor>(_MTL_PRIVATE_CLS(MTLAccelerationStructureDescriptor));
}

_MTL_INLINE MTL::AccelerationStructureDescriptor* MTL::AccelerationStructureDescriptor::init()
{
    return NS::Object::init<MTL::AccelerationStructureDescriptor>();
}

_MTL_INLINE void MTL::AccelerationStructureDescriptor::setUsage(MTL::AccelerationStructureUsage usage)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setUsage_), usage);
}

_MTL_INLINE MTL::AccelerationStructureUsage MTL::AccelerationStructureDescriptor::usage() const
{
    return Object::sendMessage<MTL::AccelerationStructureUsage>(this, _MTL_PRIVATE_SEL(usage));
}

_MTL_INLINE MTL::AccelerationStructureGeometryDescriptor* MTL::AccelerationStructureGeometryDescriptor::alloc()
{
    return NS::Object::alloc<MTL::AccelerationStructureGeometryDescriptor>(_MTL_PRIVATE_CLS(MTLAccelerationStructureGeometryDescriptor));
}

_MTL_INLINE bool MTL::AccelerationStructureGeometryDescriptor::allowDuplicateIntersectionFunctionInvocation() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(allowDuplicateIntersectionFunctionInvocation));
}

_MTL_INLINE MTL::AccelerationStructureGeometryDescriptor* MTL::AccelerationStructureGeometryDescriptor::init()
{
    return NS::Object::init<MTL::AccelerationStructureGeometryDescriptor>();
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureGeometryDescriptor::intersectionFunctionTableOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(intersectionFunctionTableOffset));
}

_MTL_INLINE NS::String* MTL::AccelerationStructureGeometryDescriptor::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE bool MTL::AccelerationStructureGeometryDescriptor::opaque() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(opaque));
}

_MTL_INLINE MTL::Buffer* MTL::AccelerationStructureGeometryDescriptor::primitiveDataBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(primitiveDataBuffer));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureGeometryDescriptor::primitiveDataBufferOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(primitiveDataBufferOffset));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureGeometryDescriptor::primitiveDataElementSize() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(primitiveDataElementSize));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureGeometryDescriptor::primitiveDataStride() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(primitiveDataStride));
}

_MTL_INLINE void MTL::AccelerationStructureGeometryDescriptor::setAllowDuplicateIntersectionFunctionInvocation(bool allowDuplicateIntersectionFunctionInvocation)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setAllowDuplicateIntersectionFunctionInvocation_), allowDuplicateIntersectionFunctionInvocation);
}

_MTL_INLINE void MTL::AccelerationStructureGeometryDescriptor::setIntersectionFunctionTableOffset(NS::UInteger intersectionFunctionTableOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIntersectionFunctionTableOffset_), intersectionFunctionTableOffset);
}

_MTL_INLINE void MTL::AccelerationStructureGeometryDescriptor::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE void MTL::AccelerationStructureGeometryDescriptor::setOpaque(bool opaque)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setOpaque_), opaque);
}

_MTL_INLINE void MTL::AccelerationStructureGeometryDescriptor::setPrimitiveDataBuffer(const MTL::Buffer* primitiveDataBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPrimitiveDataBuffer_), primitiveDataBuffer);
}

_MTL_INLINE void MTL::AccelerationStructureGeometryDescriptor::setPrimitiveDataBufferOffset(NS::UInteger primitiveDataBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPrimitiveDataBufferOffset_), primitiveDataBufferOffset);
}

_MTL_INLINE void MTL::AccelerationStructureGeometryDescriptor::setPrimitiveDataElementSize(NS::UInteger primitiveDataElementSize)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPrimitiveDataElementSize_), primitiveDataElementSize);
}

_MTL_INLINE void MTL::AccelerationStructureGeometryDescriptor::setPrimitiveDataStride(NS::UInteger primitiveDataStride)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPrimitiveDataStride_), primitiveDataStride);
}

_MTL_INLINE MTL::PrimitiveAccelerationStructureDescriptor* MTL::PrimitiveAccelerationStructureDescriptor::alloc()
{
    return NS::Object::alloc<MTL::PrimitiveAccelerationStructureDescriptor>(_MTL_PRIVATE_CLS(MTLPrimitiveAccelerationStructureDescriptor));
}

_MTL_INLINE MTL::PrimitiveAccelerationStructureDescriptor* MTL::PrimitiveAccelerationStructureDescriptor::descriptor()
{
    return Object::sendMessage<MTL::PrimitiveAccelerationStructureDescriptor*>(_MTL_PRIVATE_CLS(MTLPrimitiveAccelerationStructureDescriptor), _MTL_PRIVATE_SEL(descriptor));
}

_MTL_INLINE NS::Array* MTL::PrimitiveAccelerationStructureDescriptor::geometryDescriptors() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(geometryDescriptors));
}

_MTL_INLINE MTL::PrimitiveAccelerationStructureDescriptor* MTL::PrimitiveAccelerationStructureDescriptor::init()
{
    return NS::Object::init<MTL::PrimitiveAccelerationStructureDescriptor>();
}

_MTL_INLINE MTL::MotionBorderMode MTL::PrimitiveAccelerationStructureDescriptor::motionEndBorderMode() const
{
    return Object::sendMessage<MTL::MotionBorderMode>(this, _MTL_PRIVATE_SEL(motionEndBorderMode));
}

_MTL_INLINE float MTL::PrimitiveAccelerationStructureDescriptor::motionEndTime() const
{
    return Object::sendMessage<float>(this, _MTL_PRIVATE_SEL(motionEndTime));
}

_MTL_INLINE NS::UInteger MTL::PrimitiveAccelerationStructureDescriptor::motionKeyframeCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(motionKeyframeCount));
}

_MTL_INLINE MTL::MotionBorderMode MTL::PrimitiveAccelerationStructureDescriptor::motionStartBorderMode() const
{
    return Object::sendMessage<MTL::MotionBorderMode>(this, _MTL_PRIVATE_SEL(motionStartBorderMode));
}

_MTL_INLINE float MTL::PrimitiveAccelerationStructureDescriptor::motionStartTime() const
{
    return Object::sendMessage<float>(this, _MTL_PRIVATE_SEL(motionStartTime));
}

_MTL_INLINE void MTL::PrimitiveAccelerationStructureDescriptor::setGeometryDescriptors(const NS::Array* geometryDescriptors)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setGeometryDescriptors_), geometryDescriptors);
}

_MTL_INLINE void MTL::PrimitiveAccelerationStructureDescriptor::setMotionEndBorderMode(MTL::MotionBorderMode motionEndBorderMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMotionEndBorderMode_), motionEndBorderMode);
}

_MTL_INLINE void MTL::PrimitiveAccelerationStructureDescriptor::setMotionEndTime(float motionEndTime)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMotionEndTime_), motionEndTime);
}

_MTL_INLINE void MTL::PrimitiveAccelerationStructureDescriptor::setMotionKeyframeCount(NS::UInteger motionKeyframeCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMotionKeyframeCount_), motionKeyframeCount);
}

_MTL_INLINE void MTL::PrimitiveAccelerationStructureDescriptor::setMotionStartBorderMode(MTL::MotionBorderMode motionStartBorderMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMotionStartBorderMode_), motionStartBorderMode);
}

_MTL_INLINE void MTL::PrimitiveAccelerationStructureDescriptor::setMotionStartTime(float motionStartTime)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMotionStartTime_), motionStartTime);
}

_MTL_INLINE MTL::AccelerationStructureTriangleGeometryDescriptor* MTL::AccelerationStructureTriangleGeometryDescriptor::alloc()
{
    return NS::Object::alloc<MTL::AccelerationStructureTriangleGeometryDescriptor>(_MTL_PRIVATE_CLS(MTLAccelerationStructureTriangleGeometryDescriptor));
}

_MTL_INLINE MTL::AccelerationStructureTriangleGeometryDescriptor* MTL::AccelerationStructureTriangleGeometryDescriptor::descriptor()
{
    return Object::sendMessage<MTL::AccelerationStructureTriangleGeometryDescriptor*>(_MTL_PRIVATE_CLS(MTLAccelerationStructureTriangleGeometryDescriptor), _MTL_PRIVATE_SEL(descriptor));
}

_MTL_INLINE MTL::Buffer* MTL::AccelerationStructureTriangleGeometryDescriptor::indexBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(indexBuffer));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureTriangleGeometryDescriptor::indexBufferOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(indexBufferOffset));
}

_MTL_INLINE MTL::IndexType MTL::AccelerationStructureTriangleGeometryDescriptor::indexType() const
{
    return Object::sendMessage<MTL::IndexType>(this, _MTL_PRIVATE_SEL(indexType));
}

_MTL_INLINE MTL::AccelerationStructureTriangleGeometryDescriptor* MTL::AccelerationStructureTriangleGeometryDescriptor::init()
{
    return NS::Object::init<MTL::AccelerationStructureTriangleGeometryDescriptor>();
}

_MTL_INLINE void MTL::AccelerationStructureTriangleGeometryDescriptor::setIndexBuffer(const MTL::Buffer* indexBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIndexBuffer_), indexBuffer);
}

_MTL_INLINE void MTL::AccelerationStructureTriangleGeometryDescriptor::setIndexBufferOffset(NS::UInteger indexBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIndexBufferOffset_), indexBufferOffset);
}

_MTL_INLINE void MTL::AccelerationStructureTriangleGeometryDescriptor::setIndexType(MTL::IndexType indexType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIndexType_), indexType);
}

_MTL_INLINE void MTL::AccelerationStructureTriangleGeometryDescriptor::setTransformationMatrixBuffer(const MTL::Buffer* transformationMatrixBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTransformationMatrixBuffer_), transformationMatrixBuffer);
}

_MTL_INLINE void MTL::AccelerationStructureTriangleGeometryDescriptor::setTransformationMatrixBufferOffset(NS::UInteger transformationMatrixBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTransformationMatrixBufferOffset_), transformationMatrixBufferOffset);
}

_MTL_INLINE void MTL::AccelerationStructureTriangleGeometryDescriptor::setTransformationMatrixLayout(MTL::MatrixLayout transformationMatrixLayout)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTransformationMatrixLayout_), transformationMatrixLayout);
}

_MTL_INLINE void MTL::AccelerationStructureTriangleGeometryDescriptor::setTriangleCount(NS::UInteger triangleCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTriangleCount_), triangleCount);
}

_MTL_INLINE void MTL::AccelerationStructureTriangleGeometryDescriptor::setVertexBuffer(const MTL::Buffer* vertexBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexBuffer_), vertexBuffer);
}

_MTL_INLINE void MTL::AccelerationStructureTriangleGeometryDescriptor::setVertexBufferOffset(NS::UInteger vertexBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexBufferOffset_), vertexBufferOffset);
}

_MTL_INLINE void MTL::AccelerationStructureTriangleGeometryDescriptor::setVertexFormat(MTL::AttributeFormat vertexFormat)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexFormat_), vertexFormat);
}

_MTL_INLINE void MTL::AccelerationStructureTriangleGeometryDescriptor::setVertexStride(NS::UInteger vertexStride)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexStride_), vertexStride);
}

_MTL_INLINE MTL::Buffer* MTL::AccelerationStructureTriangleGeometryDescriptor::transformationMatrixBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(transformationMatrixBuffer));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureTriangleGeometryDescriptor::transformationMatrixBufferOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(transformationMatrixBufferOffset));
}

_MTL_INLINE MTL::MatrixLayout MTL::AccelerationStructureTriangleGeometryDescriptor::transformationMatrixLayout() const
{
    return Object::sendMessage<MTL::MatrixLayout>(this, _MTL_PRIVATE_SEL(transformationMatrixLayout));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureTriangleGeometryDescriptor::triangleCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(triangleCount));
}

_MTL_INLINE MTL::Buffer* MTL::AccelerationStructureTriangleGeometryDescriptor::vertexBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(vertexBuffer));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureTriangleGeometryDescriptor::vertexBufferOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(vertexBufferOffset));
}

_MTL_INLINE MTL::AttributeFormat MTL::AccelerationStructureTriangleGeometryDescriptor::vertexFormat() const
{
    return Object::sendMessage<MTL::AttributeFormat>(this, _MTL_PRIVATE_SEL(vertexFormat));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureTriangleGeometryDescriptor::vertexStride() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(vertexStride));
}

_MTL_INLINE MTL::AccelerationStructureBoundingBoxGeometryDescriptor* MTL::AccelerationStructureBoundingBoxGeometryDescriptor::alloc()
{
    return NS::Object::alloc<MTL::AccelerationStructureBoundingBoxGeometryDescriptor>(_MTL_PRIVATE_CLS(MTLAccelerationStructureBoundingBoxGeometryDescriptor));
}

_MTL_INLINE MTL::Buffer* MTL::AccelerationStructureBoundingBoxGeometryDescriptor::boundingBoxBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(boundingBoxBuffer));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureBoundingBoxGeometryDescriptor::boundingBoxBufferOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(boundingBoxBufferOffset));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureBoundingBoxGeometryDescriptor::boundingBoxCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(boundingBoxCount));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureBoundingBoxGeometryDescriptor::boundingBoxStride() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(boundingBoxStride));
}

_MTL_INLINE MTL::AccelerationStructureBoundingBoxGeometryDescriptor* MTL::AccelerationStructureBoundingBoxGeometryDescriptor::descriptor()
{
    return Object::sendMessage<MTL::AccelerationStructureBoundingBoxGeometryDescriptor*>(_MTL_PRIVATE_CLS(MTLAccelerationStructureBoundingBoxGeometryDescriptor), _MTL_PRIVATE_SEL(descriptor));
}

_MTL_INLINE MTL::AccelerationStructureBoundingBoxGeometryDescriptor* MTL::AccelerationStructureBoundingBoxGeometryDescriptor::init()
{
    return NS::Object::init<MTL::AccelerationStructureBoundingBoxGeometryDescriptor>();
}

_MTL_INLINE void MTL::AccelerationStructureBoundingBoxGeometryDescriptor::setBoundingBoxBuffer(const MTL::Buffer* boundingBoxBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBoundingBoxBuffer_), boundingBoxBuffer);
}

_MTL_INLINE void MTL::AccelerationStructureBoundingBoxGeometryDescriptor::setBoundingBoxBufferOffset(NS::UInteger boundingBoxBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBoundingBoxBufferOffset_), boundingBoxBufferOffset);
}

_MTL_INLINE void MTL::AccelerationStructureBoundingBoxGeometryDescriptor::setBoundingBoxCount(NS::UInteger boundingBoxCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBoundingBoxCount_), boundingBoxCount);
}

_MTL_INLINE void MTL::AccelerationStructureBoundingBoxGeometryDescriptor::setBoundingBoxStride(NS::UInteger boundingBoxStride)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBoundingBoxStride_), boundingBoxStride);
}

_MTL_INLINE MTL::MotionKeyframeData* MTL::MotionKeyframeData::alloc()
{
    return NS::Object::alloc<MTL::MotionKeyframeData>(_MTL_PRIVATE_CLS(MTLMotionKeyframeData));
}

_MTL_INLINE MTL::Buffer* MTL::MotionKeyframeData::buffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(buffer));
}

_MTL_INLINE MTL::MotionKeyframeData* MTL::MotionKeyframeData::data()
{
    return Object::sendMessage<MTL::MotionKeyframeData*>(_MTL_PRIVATE_CLS(MTLMotionKeyframeData), _MTL_PRIVATE_SEL(data));
}

_MTL_INLINE MTL::MotionKeyframeData* MTL::MotionKeyframeData::init()
{
    return NS::Object::init<MTL::MotionKeyframeData>();
}

_MTL_INLINE NS::UInteger MTL::MotionKeyframeData::offset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(offset));
}

_MTL_INLINE void MTL::MotionKeyframeData::setBuffer(const MTL::Buffer* buffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBuffer_), buffer);
}

_MTL_INLINE void MTL::MotionKeyframeData::setOffset(NS::UInteger offset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setOffset_), offset);
}

_MTL_INLINE MTL::AccelerationStructureMotionTriangleGeometryDescriptor* MTL::AccelerationStructureMotionTriangleGeometryDescriptor::alloc()
{
    return NS::Object::alloc<MTL::AccelerationStructureMotionTriangleGeometryDescriptor>(_MTL_PRIVATE_CLS(MTLAccelerationStructureMotionTriangleGeometryDescriptor));
}

_MTL_INLINE MTL::AccelerationStructureMotionTriangleGeometryDescriptor* MTL::AccelerationStructureMotionTriangleGeometryDescriptor::descriptor()
{
    return Object::sendMessage<MTL::AccelerationStructureMotionTriangleGeometryDescriptor*>(_MTL_PRIVATE_CLS(MTLAccelerationStructureMotionTriangleGeometryDescriptor), _MTL_PRIVATE_SEL(descriptor));
}

_MTL_INLINE MTL::Buffer* MTL::AccelerationStructureMotionTriangleGeometryDescriptor::indexBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(indexBuffer));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureMotionTriangleGeometryDescriptor::indexBufferOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(indexBufferOffset));
}

_MTL_INLINE MTL::IndexType MTL::AccelerationStructureMotionTriangleGeometryDescriptor::indexType() const
{
    return Object::sendMessage<MTL::IndexType>(this, _MTL_PRIVATE_SEL(indexType));
}

_MTL_INLINE MTL::AccelerationStructureMotionTriangleGeometryDescriptor* MTL::AccelerationStructureMotionTriangleGeometryDescriptor::init()
{
    return NS::Object::init<MTL::AccelerationStructureMotionTriangleGeometryDescriptor>();
}

_MTL_INLINE void MTL::AccelerationStructureMotionTriangleGeometryDescriptor::setIndexBuffer(const MTL::Buffer* indexBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIndexBuffer_), indexBuffer);
}

_MTL_INLINE void MTL::AccelerationStructureMotionTriangleGeometryDescriptor::setIndexBufferOffset(NS::UInteger indexBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIndexBufferOffset_), indexBufferOffset);
}

_MTL_INLINE void MTL::AccelerationStructureMotionTriangleGeometryDescriptor::setIndexType(MTL::IndexType indexType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIndexType_), indexType);
}

_MTL_INLINE void MTL::AccelerationStructureMotionTriangleGeometryDescriptor::setTransformationMatrixBuffer(const MTL::Buffer* transformationMatrixBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTransformationMatrixBuffer_), transformationMatrixBuffer);
}

_MTL_INLINE void MTL::AccelerationStructureMotionTriangleGeometryDescriptor::setTransformationMatrixBufferOffset(NS::UInteger transformationMatrixBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTransformationMatrixBufferOffset_), transformationMatrixBufferOffset);
}

_MTL_INLINE void MTL::AccelerationStructureMotionTriangleGeometryDescriptor::setTransformationMatrixLayout(MTL::MatrixLayout transformationMatrixLayout)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTransformationMatrixLayout_), transformationMatrixLayout);
}

_MTL_INLINE void MTL::AccelerationStructureMotionTriangleGeometryDescriptor::setTriangleCount(NS::UInteger triangleCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTriangleCount_), triangleCount);
}

_MTL_INLINE void MTL::AccelerationStructureMotionTriangleGeometryDescriptor::setVertexBuffers(const NS::Array* vertexBuffers)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexBuffers_), vertexBuffers);
}

_MTL_INLINE void MTL::AccelerationStructureMotionTriangleGeometryDescriptor::setVertexFormat(MTL::AttributeFormat vertexFormat)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexFormat_), vertexFormat);
}

_MTL_INLINE void MTL::AccelerationStructureMotionTriangleGeometryDescriptor::setVertexStride(NS::UInteger vertexStride)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexStride_), vertexStride);
}

_MTL_INLINE MTL::Buffer* MTL::AccelerationStructureMotionTriangleGeometryDescriptor::transformationMatrixBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(transformationMatrixBuffer));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureMotionTriangleGeometryDescriptor::transformationMatrixBufferOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(transformationMatrixBufferOffset));
}

_MTL_INLINE MTL::MatrixLayout MTL::AccelerationStructureMotionTriangleGeometryDescriptor::transformationMatrixLayout() const
{
    return Object::sendMessage<MTL::MatrixLayout>(this, _MTL_PRIVATE_SEL(transformationMatrixLayout));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureMotionTriangleGeometryDescriptor::triangleCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(triangleCount));
}

_MTL_INLINE NS::Array* MTL::AccelerationStructureMotionTriangleGeometryDescriptor::vertexBuffers() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(vertexBuffers));
}

_MTL_INLINE MTL::AttributeFormat MTL::AccelerationStructureMotionTriangleGeometryDescriptor::vertexFormat() const
{
    return Object::sendMessage<MTL::AttributeFormat>(this, _MTL_PRIVATE_SEL(vertexFormat));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureMotionTriangleGeometryDescriptor::vertexStride() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(vertexStride));
}

_MTL_INLINE MTL::AccelerationStructureMotionBoundingBoxGeometryDescriptor* MTL::AccelerationStructureMotionBoundingBoxGeometryDescriptor::alloc()
{
    return NS::Object::alloc<MTL::AccelerationStructureMotionBoundingBoxGeometryDescriptor>(_MTL_PRIVATE_CLS(MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor));
}

_MTL_INLINE NS::Array* MTL::AccelerationStructureMotionBoundingBoxGeometryDescriptor::boundingBoxBuffers() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(boundingBoxBuffers));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureMotionBoundingBoxGeometryDescriptor::boundingBoxCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(boundingBoxCount));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureMotionBoundingBoxGeometryDescriptor::boundingBoxStride() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(boundingBoxStride));
}

_MTL_INLINE MTL::AccelerationStructureMotionBoundingBoxGeometryDescriptor* MTL::AccelerationStructureMotionBoundingBoxGeometryDescriptor::descriptor()
{
    return Object::sendMessage<MTL::AccelerationStructureMotionBoundingBoxGeometryDescriptor*>(_MTL_PRIVATE_CLS(MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor), _MTL_PRIVATE_SEL(descriptor));
}

_MTL_INLINE MTL::AccelerationStructureMotionBoundingBoxGeometryDescriptor* MTL::AccelerationStructureMotionBoundingBoxGeometryDescriptor::init()
{
    return NS::Object::init<MTL::AccelerationStructureMotionBoundingBoxGeometryDescriptor>();
}

_MTL_INLINE void MTL::AccelerationStructureMotionBoundingBoxGeometryDescriptor::setBoundingBoxBuffers(const NS::Array* boundingBoxBuffers)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBoundingBoxBuffers_), boundingBoxBuffers);
}

_MTL_INLINE void MTL::AccelerationStructureMotionBoundingBoxGeometryDescriptor::setBoundingBoxCount(NS::UInteger boundingBoxCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBoundingBoxCount_), boundingBoxCount);
}

_MTL_INLINE void MTL::AccelerationStructureMotionBoundingBoxGeometryDescriptor::setBoundingBoxStride(NS::UInteger boundingBoxStride)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBoundingBoxStride_), boundingBoxStride);
}

_MTL_INLINE MTL::AccelerationStructureCurveGeometryDescriptor* MTL::AccelerationStructureCurveGeometryDescriptor::alloc()
{
    return NS::Object::alloc<MTL::AccelerationStructureCurveGeometryDescriptor>(_MTL_PRIVATE_CLS(MTLAccelerationStructureCurveGeometryDescriptor));
}

_MTL_INLINE MTL::Buffer* MTL::AccelerationStructureCurveGeometryDescriptor::controlPointBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(controlPointBuffer));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureCurveGeometryDescriptor::controlPointBufferOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(controlPointBufferOffset));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureCurveGeometryDescriptor::controlPointCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(controlPointCount));
}

_MTL_INLINE MTL::AttributeFormat MTL::AccelerationStructureCurveGeometryDescriptor::controlPointFormat() const
{
    return Object::sendMessage<MTL::AttributeFormat>(this, _MTL_PRIVATE_SEL(controlPointFormat));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureCurveGeometryDescriptor::controlPointStride() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(controlPointStride));
}

_MTL_INLINE MTL::CurveBasis MTL::AccelerationStructureCurveGeometryDescriptor::curveBasis() const
{
    return Object::sendMessage<MTL::CurveBasis>(this, _MTL_PRIVATE_SEL(curveBasis));
}

_MTL_INLINE MTL::CurveEndCaps MTL::AccelerationStructureCurveGeometryDescriptor::curveEndCaps() const
{
    return Object::sendMessage<MTL::CurveEndCaps>(this, _MTL_PRIVATE_SEL(curveEndCaps));
}

_MTL_INLINE MTL::CurveType MTL::AccelerationStructureCurveGeometryDescriptor::curveType() const
{
    return Object::sendMessage<MTL::CurveType>(this, _MTL_PRIVATE_SEL(curveType));
}

_MTL_INLINE MTL::AccelerationStructureCurveGeometryDescriptor* MTL::AccelerationStructureCurveGeometryDescriptor::descriptor()
{
    return Object::sendMessage<MTL::AccelerationStructureCurveGeometryDescriptor*>(_MTL_PRIVATE_CLS(MTLAccelerationStructureCurveGeometryDescriptor), _MTL_PRIVATE_SEL(descriptor));
}

_MTL_INLINE MTL::Buffer* MTL::AccelerationStructureCurveGeometryDescriptor::indexBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(indexBuffer));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureCurveGeometryDescriptor::indexBufferOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(indexBufferOffset));
}

_MTL_INLINE MTL::IndexType MTL::AccelerationStructureCurveGeometryDescriptor::indexType() const
{
    return Object::sendMessage<MTL::IndexType>(this, _MTL_PRIVATE_SEL(indexType));
}

_MTL_INLINE MTL::AccelerationStructureCurveGeometryDescriptor* MTL::AccelerationStructureCurveGeometryDescriptor::init()
{
    return NS::Object::init<MTL::AccelerationStructureCurveGeometryDescriptor>();
}

_MTL_INLINE MTL::Buffer* MTL::AccelerationStructureCurveGeometryDescriptor::radiusBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(radiusBuffer));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureCurveGeometryDescriptor::radiusBufferOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(radiusBufferOffset));
}

_MTL_INLINE MTL::AttributeFormat MTL::AccelerationStructureCurveGeometryDescriptor::radiusFormat() const
{
    return Object::sendMessage<MTL::AttributeFormat>(this, _MTL_PRIVATE_SEL(radiusFormat));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureCurveGeometryDescriptor::radiusStride() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(radiusStride));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureCurveGeometryDescriptor::segmentControlPointCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(segmentControlPointCount));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureCurveGeometryDescriptor::segmentCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(segmentCount));
}

_MTL_INLINE void MTL::AccelerationStructureCurveGeometryDescriptor::setControlPointBuffer(const MTL::Buffer* controlPointBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setControlPointBuffer_), controlPointBuffer);
}

_MTL_INLINE void MTL::AccelerationStructureCurveGeometryDescriptor::setControlPointBufferOffset(NS::UInteger controlPointBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setControlPointBufferOffset_), controlPointBufferOffset);
}

_MTL_INLINE void MTL::AccelerationStructureCurveGeometryDescriptor::setControlPointCount(NS::UInteger controlPointCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setControlPointCount_), controlPointCount);
}

_MTL_INLINE void MTL::AccelerationStructureCurveGeometryDescriptor::setControlPointFormat(MTL::AttributeFormat controlPointFormat)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setControlPointFormat_), controlPointFormat);
}

_MTL_INLINE void MTL::AccelerationStructureCurveGeometryDescriptor::setControlPointStride(NS::UInteger controlPointStride)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setControlPointStride_), controlPointStride);
}

_MTL_INLINE void MTL::AccelerationStructureCurveGeometryDescriptor::setCurveBasis(MTL::CurveBasis curveBasis)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setCurveBasis_), curveBasis);
}

_MTL_INLINE void MTL::AccelerationStructureCurveGeometryDescriptor::setCurveEndCaps(MTL::CurveEndCaps curveEndCaps)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setCurveEndCaps_), curveEndCaps);
}

_MTL_INLINE void MTL::AccelerationStructureCurveGeometryDescriptor::setCurveType(MTL::CurveType curveType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setCurveType_), curveType);
}

_MTL_INLINE void MTL::AccelerationStructureCurveGeometryDescriptor::setIndexBuffer(const MTL::Buffer* indexBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIndexBuffer_), indexBuffer);
}

_MTL_INLINE void MTL::AccelerationStructureCurveGeometryDescriptor::setIndexBufferOffset(NS::UInteger indexBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIndexBufferOffset_), indexBufferOffset);
}

_MTL_INLINE void MTL::AccelerationStructureCurveGeometryDescriptor::setIndexType(MTL::IndexType indexType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIndexType_), indexType);
}

_MTL_INLINE void MTL::AccelerationStructureCurveGeometryDescriptor::setRadiusBuffer(const MTL::Buffer* radiusBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRadiusBuffer_), radiusBuffer);
}

_MTL_INLINE void MTL::AccelerationStructureCurveGeometryDescriptor::setRadiusBufferOffset(NS::UInteger radiusBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRadiusBufferOffset_), radiusBufferOffset);
}

_MTL_INLINE void MTL::AccelerationStructureCurveGeometryDescriptor::setRadiusFormat(MTL::AttributeFormat radiusFormat)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRadiusFormat_), radiusFormat);
}

_MTL_INLINE void MTL::AccelerationStructureCurveGeometryDescriptor::setRadiusStride(NS::UInteger radiusStride)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRadiusStride_), radiusStride);
}

_MTL_INLINE void MTL::AccelerationStructureCurveGeometryDescriptor::setSegmentControlPointCount(NS::UInteger segmentControlPointCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSegmentControlPointCount_), segmentControlPointCount);
}

_MTL_INLINE void MTL::AccelerationStructureCurveGeometryDescriptor::setSegmentCount(NS::UInteger segmentCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSegmentCount_), segmentCount);
}

_MTL_INLINE MTL::AccelerationStructureMotionCurveGeometryDescriptor* MTL::AccelerationStructureMotionCurveGeometryDescriptor::alloc()
{
    return NS::Object::alloc<MTL::AccelerationStructureMotionCurveGeometryDescriptor>(_MTL_PRIVATE_CLS(MTLAccelerationStructureMotionCurveGeometryDescriptor));
}

_MTL_INLINE NS::Array* MTL::AccelerationStructureMotionCurveGeometryDescriptor::controlPointBuffers() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(controlPointBuffers));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureMotionCurveGeometryDescriptor::controlPointCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(controlPointCount));
}

_MTL_INLINE MTL::AttributeFormat MTL::AccelerationStructureMotionCurveGeometryDescriptor::controlPointFormat() const
{
    return Object::sendMessage<MTL::AttributeFormat>(this, _MTL_PRIVATE_SEL(controlPointFormat));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureMotionCurveGeometryDescriptor::controlPointStride() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(controlPointStride));
}

_MTL_INLINE MTL::CurveBasis MTL::AccelerationStructureMotionCurveGeometryDescriptor::curveBasis() const
{
    return Object::sendMessage<MTL::CurveBasis>(this, _MTL_PRIVATE_SEL(curveBasis));
}

_MTL_INLINE MTL::CurveEndCaps MTL::AccelerationStructureMotionCurveGeometryDescriptor::curveEndCaps() const
{
    return Object::sendMessage<MTL::CurveEndCaps>(this, _MTL_PRIVATE_SEL(curveEndCaps));
}

_MTL_INLINE MTL::CurveType MTL::AccelerationStructureMotionCurveGeometryDescriptor::curveType() const
{
    return Object::sendMessage<MTL::CurveType>(this, _MTL_PRIVATE_SEL(curveType));
}

_MTL_INLINE MTL::AccelerationStructureMotionCurveGeometryDescriptor* MTL::AccelerationStructureMotionCurveGeometryDescriptor::descriptor()
{
    return Object::sendMessage<MTL::AccelerationStructureMotionCurveGeometryDescriptor*>(_MTL_PRIVATE_CLS(MTLAccelerationStructureMotionCurveGeometryDescriptor), _MTL_PRIVATE_SEL(descriptor));
}

_MTL_INLINE MTL::Buffer* MTL::AccelerationStructureMotionCurveGeometryDescriptor::indexBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(indexBuffer));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureMotionCurveGeometryDescriptor::indexBufferOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(indexBufferOffset));
}

_MTL_INLINE MTL::IndexType MTL::AccelerationStructureMotionCurveGeometryDescriptor::indexType() const
{
    return Object::sendMessage<MTL::IndexType>(this, _MTL_PRIVATE_SEL(indexType));
}

_MTL_INLINE MTL::AccelerationStructureMotionCurveGeometryDescriptor* MTL::AccelerationStructureMotionCurveGeometryDescriptor::init()
{
    return NS::Object::init<MTL::AccelerationStructureMotionCurveGeometryDescriptor>();
}

_MTL_INLINE NS::Array* MTL::AccelerationStructureMotionCurveGeometryDescriptor::radiusBuffers() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(radiusBuffers));
}

_MTL_INLINE MTL::AttributeFormat MTL::AccelerationStructureMotionCurveGeometryDescriptor::radiusFormat() const
{
    return Object::sendMessage<MTL::AttributeFormat>(this, _MTL_PRIVATE_SEL(radiusFormat));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureMotionCurveGeometryDescriptor::radiusStride() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(radiusStride));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureMotionCurveGeometryDescriptor::segmentControlPointCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(segmentControlPointCount));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructureMotionCurveGeometryDescriptor::segmentCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(segmentCount));
}

_MTL_INLINE void MTL::AccelerationStructureMotionCurveGeometryDescriptor::setControlPointBuffers(const NS::Array* controlPointBuffers)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setControlPointBuffers_), controlPointBuffers);
}

_MTL_INLINE void MTL::AccelerationStructureMotionCurveGeometryDescriptor::setControlPointCount(NS::UInteger controlPointCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setControlPointCount_), controlPointCount);
}

_MTL_INLINE void MTL::AccelerationStructureMotionCurveGeometryDescriptor::setControlPointFormat(MTL::AttributeFormat controlPointFormat)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setControlPointFormat_), controlPointFormat);
}

_MTL_INLINE void MTL::AccelerationStructureMotionCurveGeometryDescriptor::setControlPointStride(NS::UInteger controlPointStride)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setControlPointStride_), controlPointStride);
}

_MTL_INLINE void MTL::AccelerationStructureMotionCurveGeometryDescriptor::setCurveBasis(MTL::CurveBasis curveBasis)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setCurveBasis_), curveBasis);
}

_MTL_INLINE void MTL::AccelerationStructureMotionCurveGeometryDescriptor::setCurveEndCaps(MTL::CurveEndCaps curveEndCaps)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setCurveEndCaps_), curveEndCaps);
}

_MTL_INLINE void MTL::AccelerationStructureMotionCurveGeometryDescriptor::setCurveType(MTL::CurveType curveType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setCurveType_), curveType);
}

_MTL_INLINE void MTL::AccelerationStructureMotionCurveGeometryDescriptor::setIndexBuffer(const MTL::Buffer* indexBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIndexBuffer_), indexBuffer);
}

_MTL_INLINE void MTL::AccelerationStructureMotionCurveGeometryDescriptor::setIndexBufferOffset(NS::UInteger indexBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIndexBufferOffset_), indexBufferOffset);
}

_MTL_INLINE void MTL::AccelerationStructureMotionCurveGeometryDescriptor::setIndexType(MTL::IndexType indexType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIndexType_), indexType);
}

_MTL_INLINE void MTL::AccelerationStructureMotionCurveGeometryDescriptor::setRadiusBuffers(const NS::Array* radiusBuffers)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRadiusBuffers_), radiusBuffers);
}

_MTL_INLINE void MTL::AccelerationStructureMotionCurveGeometryDescriptor::setRadiusFormat(MTL::AttributeFormat radiusFormat)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRadiusFormat_), radiusFormat);
}

_MTL_INLINE void MTL::AccelerationStructureMotionCurveGeometryDescriptor::setRadiusStride(NS::UInteger radiusStride)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRadiusStride_), radiusStride);
}

_MTL_INLINE void MTL::AccelerationStructureMotionCurveGeometryDescriptor::setSegmentControlPointCount(NS::UInteger segmentControlPointCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSegmentControlPointCount_), segmentControlPointCount);
}

_MTL_INLINE void MTL::AccelerationStructureMotionCurveGeometryDescriptor::setSegmentCount(NS::UInteger segmentCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSegmentCount_), segmentCount);
}

_MTL_INLINE MTL::InstanceAccelerationStructureDescriptor* MTL::InstanceAccelerationStructureDescriptor::alloc()
{
    return NS::Object::alloc<MTL::InstanceAccelerationStructureDescriptor>(_MTL_PRIVATE_CLS(MTLInstanceAccelerationStructureDescriptor));
}

_MTL_INLINE MTL::InstanceAccelerationStructureDescriptor* MTL::InstanceAccelerationStructureDescriptor::descriptor()
{
    return Object::sendMessage<MTL::InstanceAccelerationStructureDescriptor*>(_MTL_PRIVATE_CLS(MTLInstanceAccelerationStructureDescriptor), _MTL_PRIVATE_SEL(descriptor));
}

_MTL_INLINE MTL::InstanceAccelerationStructureDescriptor* MTL::InstanceAccelerationStructureDescriptor::init()
{
    return NS::Object::init<MTL::InstanceAccelerationStructureDescriptor>();
}

_MTL_INLINE NS::UInteger MTL::InstanceAccelerationStructureDescriptor::instanceCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(instanceCount));
}

_MTL_INLINE MTL::Buffer* MTL::InstanceAccelerationStructureDescriptor::instanceDescriptorBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(instanceDescriptorBuffer));
}

_MTL_INLINE NS::UInteger MTL::InstanceAccelerationStructureDescriptor::instanceDescriptorBufferOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(instanceDescriptorBufferOffset));
}

_MTL_INLINE NS::UInteger MTL::InstanceAccelerationStructureDescriptor::instanceDescriptorStride() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(instanceDescriptorStride));
}

_MTL_INLINE MTL::AccelerationStructureInstanceDescriptorType MTL::InstanceAccelerationStructureDescriptor::instanceDescriptorType() const
{
    return Object::sendMessage<MTL::AccelerationStructureInstanceDescriptorType>(this, _MTL_PRIVATE_SEL(instanceDescriptorType));
}

_MTL_INLINE MTL::MatrixLayout MTL::InstanceAccelerationStructureDescriptor::instanceTransformationMatrixLayout() const
{
    return Object::sendMessage<MTL::MatrixLayout>(this, _MTL_PRIVATE_SEL(instanceTransformationMatrixLayout));
}

_MTL_INLINE NS::Array* MTL::InstanceAccelerationStructureDescriptor::instancedAccelerationStructures() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(instancedAccelerationStructures));
}

_MTL_INLINE MTL::Buffer* MTL::InstanceAccelerationStructureDescriptor::motionTransformBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(motionTransformBuffer));
}

_MTL_INLINE NS::UInteger MTL::InstanceAccelerationStructureDescriptor::motionTransformBufferOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(motionTransformBufferOffset));
}

_MTL_INLINE NS::UInteger MTL::InstanceAccelerationStructureDescriptor::motionTransformCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(motionTransformCount));
}

_MTL_INLINE NS::UInteger MTL::InstanceAccelerationStructureDescriptor::motionTransformStride() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(motionTransformStride));
}

_MTL_INLINE MTL::TransformType MTL::InstanceAccelerationStructureDescriptor::motionTransformType() const
{
    return Object::sendMessage<MTL::TransformType>(this, _MTL_PRIVATE_SEL(motionTransformType));
}

_MTL_INLINE void MTL::InstanceAccelerationStructureDescriptor::setInstanceCount(NS::UInteger instanceCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInstanceCount_), instanceCount);
}

_MTL_INLINE void MTL::InstanceAccelerationStructureDescriptor::setInstanceDescriptorBuffer(const MTL::Buffer* instanceDescriptorBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInstanceDescriptorBuffer_), instanceDescriptorBuffer);
}

_MTL_INLINE void MTL::InstanceAccelerationStructureDescriptor::setInstanceDescriptorBufferOffset(NS::UInteger instanceDescriptorBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInstanceDescriptorBufferOffset_), instanceDescriptorBufferOffset);
}

_MTL_INLINE void MTL::InstanceAccelerationStructureDescriptor::setInstanceDescriptorStride(NS::UInteger instanceDescriptorStride)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInstanceDescriptorStride_), instanceDescriptorStride);
}

_MTL_INLINE void MTL::InstanceAccelerationStructureDescriptor::setInstanceDescriptorType(MTL::AccelerationStructureInstanceDescriptorType instanceDescriptorType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInstanceDescriptorType_), instanceDescriptorType);
}

_MTL_INLINE void MTL::InstanceAccelerationStructureDescriptor::setInstanceTransformationMatrixLayout(MTL::MatrixLayout instanceTransformationMatrixLayout)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInstanceTransformationMatrixLayout_), instanceTransformationMatrixLayout);
}

_MTL_INLINE void MTL::InstanceAccelerationStructureDescriptor::setInstancedAccelerationStructures(const NS::Array* instancedAccelerationStructures)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInstancedAccelerationStructures_), instancedAccelerationStructures);
}

_MTL_INLINE void MTL::InstanceAccelerationStructureDescriptor::setMotionTransformBuffer(const MTL::Buffer* motionTransformBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMotionTransformBuffer_), motionTransformBuffer);
}

_MTL_INLINE void MTL::InstanceAccelerationStructureDescriptor::setMotionTransformBufferOffset(NS::UInteger motionTransformBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMotionTransformBufferOffset_), motionTransformBufferOffset);
}

_MTL_INLINE void MTL::InstanceAccelerationStructureDescriptor::setMotionTransformCount(NS::UInteger motionTransformCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMotionTransformCount_), motionTransformCount);
}

_MTL_INLINE void MTL::InstanceAccelerationStructureDescriptor::setMotionTransformStride(NS::UInteger motionTransformStride)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMotionTransformStride_), motionTransformStride);
}

_MTL_INLINE void MTL::InstanceAccelerationStructureDescriptor::setMotionTransformType(MTL::TransformType motionTransformType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMotionTransformType_), motionTransformType);
}

_MTL_INLINE MTL::IndirectInstanceAccelerationStructureDescriptor* MTL::IndirectInstanceAccelerationStructureDescriptor::alloc()
{
    return NS::Object::alloc<MTL::IndirectInstanceAccelerationStructureDescriptor>(_MTL_PRIVATE_CLS(MTLIndirectInstanceAccelerationStructureDescriptor));
}

_MTL_INLINE MTL::IndirectInstanceAccelerationStructureDescriptor* MTL::IndirectInstanceAccelerationStructureDescriptor::descriptor()
{
    return Object::sendMessage<MTL::IndirectInstanceAccelerationStructureDescriptor*>(_MTL_PRIVATE_CLS(MTLIndirectInstanceAccelerationStructureDescriptor), _MTL_PRIVATE_SEL(descriptor));
}

_MTL_INLINE MTL::IndirectInstanceAccelerationStructureDescriptor* MTL::IndirectInstanceAccelerationStructureDescriptor::init()
{
    return NS::Object::init<MTL::IndirectInstanceAccelerationStructureDescriptor>();
}

_MTL_INLINE MTL::Buffer* MTL::IndirectInstanceAccelerationStructureDescriptor::instanceCountBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(instanceCountBuffer));
}

_MTL_INLINE NS::UInteger MTL::IndirectInstanceAccelerationStructureDescriptor::instanceCountBufferOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(instanceCountBufferOffset));
}

_MTL_INLINE MTL::Buffer* MTL::IndirectInstanceAccelerationStructureDescriptor::instanceDescriptorBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(instanceDescriptorBuffer));
}

_MTL_INLINE NS::UInteger MTL::IndirectInstanceAccelerationStructureDescriptor::instanceDescriptorBufferOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(instanceDescriptorBufferOffset));
}

_MTL_INLINE NS::UInteger MTL::IndirectInstanceAccelerationStructureDescriptor::instanceDescriptorStride() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(instanceDescriptorStride));
}

_MTL_INLINE MTL::AccelerationStructureInstanceDescriptorType MTL::IndirectInstanceAccelerationStructureDescriptor::instanceDescriptorType() const
{
    return Object::sendMessage<MTL::AccelerationStructureInstanceDescriptorType>(this, _MTL_PRIVATE_SEL(instanceDescriptorType));
}

_MTL_INLINE MTL::MatrixLayout MTL::IndirectInstanceAccelerationStructureDescriptor::instanceTransformationMatrixLayout() const
{
    return Object::sendMessage<MTL::MatrixLayout>(this, _MTL_PRIVATE_SEL(instanceTransformationMatrixLayout));
}

_MTL_INLINE NS::UInteger MTL::IndirectInstanceAccelerationStructureDescriptor::maxInstanceCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxInstanceCount));
}

_MTL_INLINE NS::UInteger MTL::IndirectInstanceAccelerationStructureDescriptor::maxMotionTransformCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxMotionTransformCount));
}

_MTL_INLINE MTL::Buffer* MTL::IndirectInstanceAccelerationStructureDescriptor::motionTransformBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(motionTransformBuffer));
}

_MTL_INLINE NS::UInteger MTL::IndirectInstanceAccelerationStructureDescriptor::motionTransformBufferOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(motionTransformBufferOffset));
}

_MTL_INLINE MTL::Buffer* MTL::IndirectInstanceAccelerationStructureDescriptor::motionTransformCountBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(motionTransformCountBuffer));
}

_MTL_INLINE NS::UInteger MTL::IndirectInstanceAccelerationStructureDescriptor::motionTransformCountBufferOffset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(motionTransformCountBufferOffset));
}

_MTL_INLINE NS::UInteger MTL::IndirectInstanceAccelerationStructureDescriptor::motionTransformStride() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(motionTransformStride));
}

_MTL_INLINE MTL::TransformType MTL::IndirectInstanceAccelerationStructureDescriptor::motionTransformType() const
{
    return Object::sendMessage<MTL::TransformType>(this, _MTL_PRIVATE_SEL(motionTransformType));
}

_MTL_INLINE void MTL::IndirectInstanceAccelerationStructureDescriptor::setInstanceCountBuffer(const MTL::Buffer* instanceCountBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInstanceCountBuffer_), instanceCountBuffer);
}

_MTL_INLINE void MTL::IndirectInstanceAccelerationStructureDescriptor::setInstanceCountBufferOffset(NS::UInteger instanceCountBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInstanceCountBufferOffset_), instanceCountBufferOffset);
}

_MTL_INLINE void MTL::IndirectInstanceAccelerationStructureDescriptor::setInstanceDescriptorBuffer(const MTL::Buffer* instanceDescriptorBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInstanceDescriptorBuffer_), instanceDescriptorBuffer);
}

_MTL_INLINE void MTL::IndirectInstanceAccelerationStructureDescriptor::setInstanceDescriptorBufferOffset(NS::UInteger instanceDescriptorBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInstanceDescriptorBufferOffset_), instanceDescriptorBufferOffset);
}

_MTL_INLINE void MTL::IndirectInstanceAccelerationStructureDescriptor::setInstanceDescriptorStride(NS::UInteger instanceDescriptorStride)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInstanceDescriptorStride_), instanceDescriptorStride);
}

_MTL_INLINE void MTL::IndirectInstanceAccelerationStructureDescriptor::setInstanceDescriptorType(MTL::AccelerationStructureInstanceDescriptorType instanceDescriptorType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInstanceDescriptorType_), instanceDescriptorType);
}

_MTL_INLINE void MTL::IndirectInstanceAccelerationStructureDescriptor::setInstanceTransformationMatrixLayout(MTL::MatrixLayout instanceTransformationMatrixLayout)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInstanceTransformationMatrixLayout_), instanceTransformationMatrixLayout);
}

_MTL_INLINE void MTL::IndirectInstanceAccelerationStructureDescriptor::setMaxInstanceCount(NS::UInteger maxInstanceCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxInstanceCount_), maxInstanceCount);
}

_MTL_INLINE void MTL::IndirectInstanceAccelerationStructureDescriptor::setMaxMotionTransformCount(NS::UInteger maxMotionTransformCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxMotionTransformCount_), maxMotionTransformCount);
}

_MTL_INLINE void MTL::IndirectInstanceAccelerationStructureDescriptor::setMotionTransformBuffer(const MTL::Buffer* motionTransformBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMotionTransformBuffer_), motionTransformBuffer);
}

_MTL_INLINE void MTL::IndirectInstanceAccelerationStructureDescriptor::setMotionTransformBufferOffset(NS::UInteger motionTransformBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMotionTransformBufferOffset_), motionTransformBufferOffset);
}

_MTL_INLINE void MTL::IndirectInstanceAccelerationStructureDescriptor::setMotionTransformCountBuffer(const MTL::Buffer* motionTransformCountBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMotionTransformCountBuffer_), motionTransformCountBuffer);
}

_MTL_INLINE void MTL::IndirectInstanceAccelerationStructureDescriptor::setMotionTransformCountBufferOffset(NS::UInteger motionTransformCountBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMotionTransformCountBufferOffset_), motionTransformCountBufferOffset);
}

_MTL_INLINE void MTL::IndirectInstanceAccelerationStructureDescriptor::setMotionTransformStride(NS::UInteger motionTransformStride)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMotionTransformStride_), motionTransformStride);
}

_MTL_INLINE void MTL::IndirectInstanceAccelerationStructureDescriptor::setMotionTransformType(MTL::TransformType motionTransformType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMotionTransformType_), motionTransformType);
}

_MTL_INLINE MTL::ResourceID MTL::AccelerationStructure::gpuResourceID() const
{
    return Object::sendMessage<MTL::ResourceID>(this, _MTL_PRIVATE_SEL(gpuResourceID));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructure::size() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(size));
}

#pragma once

#pragma once

namespace MTL
{
class Device;

_MTL_OPTIONS(NS::UInteger, ResourceUsage) {
    ResourceUsageRead = 1,
    ResourceUsageWrite = 1 << 1,
    ResourceUsageSample = 1 << 2,
};

_MTL_OPTIONS(NS::UInteger, BarrierScope) {
    BarrierScopeBuffers = 1,
    BarrierScopeTextures = 1 << 1,
    BarrierScopeRenderTargets = 1 << 2,
};

_MTL_OPTIONS(NS::UInteger, Stages) {
    StageVertex = 1,
    StageFragment = 1 << 1,
    StageTile = 1 << 2,
    StageObject = 1 << 3,
    StageMesh = 1 << 4,
    StageResourceState = 1 << 26,
    StageDispatch = 1 << 27,
    StageBlit = 1 << 28,
    StageAccelerationStructure = 1 << 29,
    StageMachineLearning = 1 << 30,
    StageAll = 9223372036854775807,
};

class CommandEncoder : public NS::Referencing<CommandEncoder>
{
public:
    void        barrierAfterQueueStages(MTL::Stages afterQueueStages, MTL::Stages beforeStages);

    Device*     device() const;

    void        endEncoding();

    void        insertDebugSignpost(const NS::String* string);

    NS::String* label() const;

    void        popDebugGroup();

    void        pushDebugGroup(const NS::String* string);

    void        setLabel(const NS::String* label);
};

}
_MTL_INLINE void MTL::CommandEncoder::barrierAfterQueueStages(MTL::Stages afterQueueStages, MTL::Stages beforeStages)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(barrierAfterQueueStages_beforeStages_), afterQueueStages, beforeStages);
}

_MTL_INLINE MTL::Device* MTL::CommandEncoder::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE void MTL::CommandEncoder::endEncoding()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(endEncoding));
}

_MTL_INLINE void MTL::CommandEncoder::insertDebugSignpost(const NS::String* string)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(insertDebugSignpost_), string);
}

_MTL_INLINE NS::String* MTL::CommandEncoder::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE void MTL::CommandEncoder::popDebugGroup()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(popDebugGroup));
}

_MTL_INLINE void MTL::CommandEncoder::pushDebugGroup(const NS::String* string)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(pushDebugGroup_), string);
}

_MTL_INLINE void MTL::CommandEncoder::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

namespace MTL
{
class AccelerationStructure;
class AccelerationStructureDescriptor;
class AccelerationStructurePassDescriptor;
class AccelerationStructurePassSampleBufferAttachmentDescriptor;
class AccelerationStructurePassSampleBufferAttachmentDescriptorArray;
class Buffer;
class CounterSampleBuffer;
class Fence;
class Heap;
class Resource;

class AccelerationStructureCommandEncoder : public NS::Referencing<AccelerationStructureCommandEncoder, CommandEncoder>
{
public:
    void buildAccelerationStructure(const MTL::AccelerationStructure* accelerationStructure, const MTL::AccelerationStructureDescriptor* descriptor, const MTL::Buffer* scratchBuffer, NS::UInteger scratchBufferOffset);

    void copyAccelerationStructure(const MTL::AccelerationStructure* sourceAccelerationStructure, const MTL::AccelerationStructure* destinationAccelerationStructure);

    void copyAndCompactAccelerationStructure(const MTL::AccelerationStructure* sourceAccelerationStructure, const MTL::AccelerationStructure* destinationAccelerationStructure);

    void refitAccelerationStructure(const MTL::AccelerationStructure* sourceAccelerationStructure, const MTL::AccelerationStructureDescriptor* descriptor, const MTL::AccelerationStructure* destinationAccelerationStructure, const MTL::Buffer* scratchBuffer, NS::UInteger scratchBufferOffset);
    void refitAccelerationStructure(const MTL::AccelerationStructure* sourceAccelerationStructure, const MTL::AccelerationStructureDescriptor* descriptor, const MTL::AccelerationStructure* destinationAccelerationStructure, const MTL::Buffer* scratchBuffer, NS::UInteger scratchBufferOffset, MTL::AccelerationStructureRefitOptions options);

    void sampleCountersInBuffer(const MTL::CounterSampleBuffer* sampleBuffer, NS::UInteger sampleIndex, bool barrier);

    void updateFence(const MTL::Fence* fence);

    void useHeap(const MTL::Heap* heap);
    void useHeaps(const MTL::Heap* const heaps[], NS::UInteger count);

    void useResource(const MTL::Resource* resource, MTL::ResourceUsage usage);
    void useResources(const MTL::Resource* const resources[], NS::UInteger count, MTL::ResourceUsage usage);

    void waitForFence(const MTL::Fence* fence);

    void writeCompactedAccelerationStructureSize(const MTL::AccelerationStructure* accelerationStructure, const MTL::Buffer* buffer, NS::UInteger offset);
    void writeCompactedAccelerationStructureSize(const MTL::AccelerationStructure* accelerationStructure, const MTL::Buffer* buffer, NS::UInteger offset, MTL::DataType sizeDataType);
};
class AccelerationStructurePassSampleBufferAttachmentDescriptor : public NS::Copying<AccelerationStructurePassSampleBufferAttachmentDescriptor>
{
public:
    static AccelerationStructurePassSampleBufferAttachmentDescriptor* alloc();

    NS::UInteger                                                      endOfEncoderSampleIndex() const;

    AccelerationStructurePassSampleBufferAttachmentDescriptor*        init();

    CounterSampleBuffer*                                              sampleBuffer() const;

    void                                                              setEndOfEncoderSampleIndex(NS::UInteger endOfEncoderSampleIndex);

    void                                                              setSampleBuffer(const MTL::CounterSampleBuffer* sampleBuffer);

    void                                                              setStartOfEncoderSampleIndex(NS::UInteger startOfEncoderSampleIndex);
    NS::UInteger                                                      startOfEncoderSampleIndex() const;
};
class AccelerationStructurePassSampleBufferAttachmentDescriptorArray : public NS::Referencing<AccelerationStructurePassSampleBufferAttachmentDescriptorArray>
{
public:
    static AccelerationStructurePassSampleBufferAttachmentDescriptorArray* alloc();

    AccelerationStructurePassSampleBufferAttachmentDescriptorArray*        init();

    AccelerationStructurePassSampleBufferAttachmentDescriptor*             object(NS::UInteger attachmentIndex);
    void                                                                   setObject(const MTL::AccelerationStructurePassSampleBufferAttachmentDescriptor* attachment, NS::UInteger attachmentIndex);
};
class AccelerationStructurePassDescriptor : public NS::Copying<AccelerationStructurePassDescriptor>
{
public:
    static AccelerationStructurePassDescriptor*                     accelerationStructurePassDescriptor();

    static AccelerationStructurePassDescriptor*                     alloc();

    AccelerationStructurePassDescriptor*                            init();

    AccelerationStructurePassSampleBufferAttachmentDescriptorArray* sampleBufferAttachments() const;
};

}
_MTL_INLINE void MTL::AccelerationStructureCommandEncoder::buildAccelerationStructure(const MTL::AccelerationStructure* accelerationStructure, const MTL::AccelerationStructureDescriptor* descriptor, const MTL::Buffer* scratchBuffer, NS::UInteger scratchBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(buildAccelerationStructure_descriptor_scratchBuffer_scratchBufferOffset_), accelerationStructure, descriptor, scratchBuffer, scratchBufferOffset);
}

_MTL_INLINE void MTL::AccelerationStructureCommandEncoder::copyAccelerationStructure(const MTL::AccelerationStructure* sourceAccelerationStructure, const MTL::AccelerationStructure* destinationAccelerationStructure)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyAccelerationStructure_toAccelerationStructure_), sourceAccelerationStructure, destinationAccelerationStructure);
}

_MTL_INLINE void MTL::AccelerationStructureCommandEncoder::copyAndCompactAccelerationStructure(const MTL::AccelerationStructure* sourceAccelerationStructure, const MTL::AccelerationStructure* destinationAccelerationStructure)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyAndCompactAccelerationStructure_toAccelerationStructure_), sourceAccelerationStructure, destinationAccelerationStructure);
}

_MTL_INLINE void MTL::AccelerationStructureCommandEncoder::refitAccelerationStructure(const MTL::AccelerationStructure* sourceAccelerationStructure, const MTL::AccelerationStructureDescriptor* descriptor, const MTL::AccelerationStructure* destinationAccelerationStructure, const MTL::Buffer* scratchBuffer, NS::UInteger scratchBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(refitAccelerationStructure_descriptor_destination_scratchBuffer_scratchBufferOffset_), sourceAccelerationStructure, descriptor, destinationAccelerationStructure, scratchBuffer, scratchBufferOffset);
}

_MTL_INLINE void MTL::AccelerationStructureCommandEncoder::refitAccelerationStructure(const MTL::AccelerationStructure* sourceAccelerationStructure, const MTL::AccelerationStructureDescriptor* descriptor, const MTL::AccelerationStructure* destinationAccelerationStructure, const MTL::Buffer* scratchBuffer, NS::UInteger scratchBufferOffset, MTL::AccelerationStructureRefitOptions options)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(refitAccelerationStructure_descriptor_destination_scratchBuffer_scratchBufferOffset_options_), sourceAccelerationStructure, descriptor, destinationAccelerationStructure, scratchBuffer, scratchBufferOffset, options);
}

_MTL_INLINE void MTL::AccelerationStructureCommandEncoder::sampleCountersInBuffer(const MTL::CounterSampleBuffer* sampleBuffer, NS::UInteger sampleIndex, bool barrier)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(sampleCountersInBuffer_atSampleIndex_withBarrier_), sampleBuffer, sampleIndex, barrier);
}

_MTL_INLINE void MTL::AccelerationStructureCommandEncoder::updateFence(const MTL::Fence* fence)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(updateFence_), fence);
}

_MTL_INLINE void MTL::AccelerationStructureCommandEncoder::useHeap(const MTL::Heap* heap)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useHeap_), heap);
}

_MTL_INLINE void MTL::AccelerationStructureCommandEncoder::useHeaps(const MTL::Heap* const heaps[], NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useHeaps_count_), heaps, count);
}

_MTL_INLINE void MTL::AccelerationStructureCommandEncoder::useResource(const MTL::Resource* resource, MTL::ResourceUsage usage)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useResource_usage_), resource, usage);
}

_MTL_INLINE void MTL::AccelerationStructureCommandEncoder::useResources(const MTL::Resource* const resources[], NS::UInteger count, MTL::ResourceUsage usage)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useResources_count_usage_), resources, count, usage);
}

_MTL_INLINE void MTL::AccelerationStructureCommandEncoder::waitForFence(const MTL::Fence* fence)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(waitForFence_), fence);
}

_MTL_INLINE void MTL::AccelerationStructureCommandEncoder::writeCompactedAccelerationStructureSize(const MTL::AccelerationStructure* accelerationStructure, const MTL::Buffer* buffer, NS::UInteger offset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(writeCompactedAccelerationStructureSize_toBuffer_offset_), accelerationStructure, buffer, offset);
}

_MTL_INLINE void MTL::AccelerationStructureCommandEncoder::writeCompactedAccelerationStructureSize(const MTL::AccelerationStructure* accelerationStructure, const MTL::Buffer* buffer, NS::UInteger offset, MTL::DataType sizeDataType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(writeCompactedAccelerationStructureSize_toBuffer_offset_sizeDataType_), accelerationStructure, buffer, offset, sizeDataType);
}

_MTL_INLINE MTL::AccelerationStructurePassSampleBufferAttachmentDescriptor* MTL::AccelerationStructurePassSampleBufferAttachmentDescriptor::alloc()
{
    return NS::Object::alloc<MTL::AccelerationStructurePassSampleBufferAttachmentDescriptor>(_MTL_PRIVATE_CLS(MTLAccelerationStructurePassSampleBufferAttachmentDescriptor));
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructurePassSampleBufferAttachmentDescriptor::endOfEncoderSampleIndex() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(endOfEncoderSampleIndex));
}

_MTL_INLINE MTL::AccelerationStructurePassSampleBufferAttachmentDescriptor* MTL::AccelerationStructurePassSampleBufferAttachmentDescriptor::init()
{
    return NS::Object::init<MTL::AccelerationStructurePassSampleBufferAttachmentDescriptor>();
}

_MTL_INLINE MTL::CounterSampleBuffer* MTL::AccelerationStructurePassSampleBufferAttachmentDescriptor::sampleBuffer() const
{
    return Object::sendMessage<MTL::CounterSampleBuffer*>(this, _MTL_PRIVATE_SEL(sampleBuffer));
}

_MTL_INLINE void MTL::AccelerationStructurePassSampleBufferAttachmentDescriptor::setEndOfEncoderSampleIndex(NS::UInteger endOfEncoderSampleIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setEndOfEncoderSampleIndex_), endOfEncoderSampleIndex);
}

_MTL_INLINE void MTL::AccelerationStructurePassSampleBufferAttachmentDescriptor::setSampleBuffer(const MTL::CounterSampleBuffer* sampleBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSampleBuffer_), sampleBuffer);
}

_MTL_INLINE void MTL::AccelerationStructurePassSampleBufferAttachmentDescriptor::setStartOfEncoderSampleIndex(NS::UInteger startOfEncoderSampleIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStartOfEncoderSampleIndex_), startOfEncoderSampleIndex);
}

_MTL_INLINE NS::UInteger MTL::AccelerationStructurePassSampleBufferAttachmentDescriptor::startOfEncoderSampleIndex() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(startOfEncoderSampleIndex));
}

_MTL_INLINE MTL::AccelerationStructurePassSampleBufferAttachmentDescriptorArray* MTL::AccelerationStructurePassSampleBufferAttachmentDescriptorArray::alloc()
{
    return NS::Object::alloc<MTL::AccelerationStructurePassSampleBufferAttachmentDescriptorArray>(_MTL_PRIVATE_CLS(MTLAccelerationStructurePassSampleBufferAttachmentDescriptorArray));
}

_MTL_INLINE MTL::AccelerationStructurePassSampleBufferAttachmentDescriptorArray* MTL::AccelerationStructurePassSampleBufferAttachmentDescriptorArray::init()
{
    return NS::Object::init<MTL::AccelerationStructurePassSampleBufferAttachmentDescriptorArray>();
}

_MTL_INLINE MTL::AccelerationStructurePassSampleBufferAttachmentDescriptor* MTL::AccelerationStructurePassSampleBufferAttachmentDescriptorArray::object(NS::UInteger attachmentIndex)
{
    return Object::sendMessage<MTL::AccelerationStructurePassSampleBufferAttachmentDescriptor*>(this, _MTL_PRIVATE_SEL(objectAtIndexedSubscript_), attachmentIndex);
}

_MTL_INLINE void MTL::AccelerationStructurePassSampleBufferAttachmentDescriptorArray::setObject(const MTL::AccelerationStructurePassSampleBufferAttachmentDescriptor* attachment, NS::UInteger attachmentIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObject_atIndexedSubscript_), attachment, attachmentIndex);
}

_MTL_INLINE MTL::AccelerationStructurePassDescriptor* MTL::AccelerationStructurePassDescriptor::accelerationStructurePassDescriptor()
{
    return Object::sendMessage<MTL::AccelerationStructurePassDescriptor*>(_MTL_PRIVATE_CLS(MTLAccelerationStructurePassDescriptor), _MTL_PRIVATE_SEL(accelerationStructurePassDescriptor));
}

_MTL_INLINE MTL::AccelerationStructurePassDescriptor* MTL::AccelerationStructurePassDescriptor::alloc()
{
    return NS::Object::alloc<MTL::AccelerationStructurePassDescriptor>(_MTL_PRIVATE_CLS(MTLAccelerationStructurePassDescriptor));
}

_MTL_INLINE MTL::AccelerationStructurePassDescriptor* MTL::AccelerationStructurePassDescriptor::init()
{
    return NS::Object::init<MTL::AccelerationStructurePassDescriptor>();
}

_MTL_INLINE MTL::AccelerationStructurePassSampleBufferAttachmentDescriptorArray* MTL::AccelerationStructurePassDescriptor::sampleBufferAttachments() const
{
    return Object::sendMessage<MTL::AccelerationStructurePassSampleBufferAttachmentDescriptorArray*>(this, _MTL_PRIVATE_SEL(sampleBufferAttachments));
}

#pragma once

#pragma once

#include <cstdint>

namespace MTL
{
class DepthStencilDescriptor;
class Device;
class StencilDescriptor;
_MTL_ENUM(NS::UInteger, CompareFunction) {
    CompareFunctionNever = 0,
    CompareFunctionLess = 1,
    CompareFunctionEqual = 2,
    CompareFunctionLessEqual = 3,
    CompareFunctionGreater = 4,
    CompareFunctionNotEqual = 5,
    CompareFunctionGreaterEqual = 6,
    CompareFunctionAlways = 7,
};

_MTL_ENUM(NS::UInteger, StencilOperation) {
    StencilOperationKeep = 0,
    StencilOperationZero = 1,
    StencilOperationReplace = 2,
    StencilOperationIncrementClamp = 3,
    StencilOperationDecrementClamp = 4,
    StencilOperationInvert = 5,
    StencilOperationIncrementWrap = 6,
    StencilOperationDecrementWrap = 7,
};

class StencilDescriptor : public NS::Copying<StencilDescriptor>
{
public:
    static StencilDescriptor* alloc();

    StencilOperation          depthFailureOperation() const;

    StencilOperation          depthStencilPassOperation() const;

    StencilDescriptor*        init();

    uint32_t                  readMask() const;

    void                      setDepthFailureOperation(MTL::StencilOperation depthFailureOperation);

    void                      setDepthStencilPassOperation(MTL::StencilOperation depthStencilPassOperation);

    void                      setReadMask(uint32_t readMask);

    void                      setStencilCompareFunction(MTL::CompareFunction stencilCompareFunction);

    void                      setStencilFailureOperation(MTL::StencilOperation stencilFailureOperation);

    void                      setWriteMask(uint32_t writeMask);

    CompareFunction           stencilCompareFunction() const;

    StencilOperation          stencilFailureOperation() const;

    uint32_t                  writeMask() const;
};
class DepthStencilDescriptor : public NS::Copying<DepthStencilDescriptor>
{
public:
    static DepthStencilDescriptor* alloc();

    StencilDescriptor*             backFaceStencil() const;

    CompareFunction                depthCompareFunction() const;

    [[deprecated("please use isDepthWriteEnabled instead")]]
    bool                    depthWriteEnabled() const;

    StencilDescriptor*      frontFaceStencil() const;

    DepthStencilDescriptor* init();

    bool                    isDepthWriteEnabled() const;

    NS::String*             label() const;

    void                    setBackFaceStencil(const MTL::StencilDescriptor* backFaceStencil);

    void                    setDepthCompareFunction(MTL::CompareFunction depthCompareFunction);

    void                    setDepthWriteEnabled(bool depthWriteEnabled);

    void                    setFrontFaceStencil(const MTL::StencilDescriptor* frontFaceStencil);

    void                    setLabel(const NS::String* label);
};
class DepthStencilState : public NS::Referencing<DepthStencilState>
{
public:
    Device*     device() const;

    ResourceID  gpuResourceID() const;

    NS::String* label() const;
};

}
_MTL_INLINE MTL::StencilDescriptor* MTL::StencilDescriptor::alloc()
{
    return NS::Object::alloc<MTL::StencilDescriptor>(_MTL_PRIVATE_CLS(MTLStencilDescriptor));
}

_MTL_INLINE MTL::StencilOperation MTL::StencilDescriptor::depthFailureOperation() const
{
    return Object::sendMessage<MTL::StencilOperation>(this, _MTL_PRIVATE_SEL(depthFailureOperation));
}

_MTL_INLINE MTL::StencilOperation MTL::StencilDescriptor::depthStencilPassOperation() const
{
    return Object::sendMessage<MTL::StencilOperation>(this, _MTL_PRIVATE_SEL(depthStencilPassOperation));
}

_MTL_INLINE MTL::StencilDescriptor* MTL::StencilDescriptor::init()
{
    return NS::Object::init<MTL::StencilDescriptor>();
}

_MTL_INLINE uint32_t MTL::StencilDescriptor::readMask() const
{
    return Object::sendMessage<uint32_t>(this, _MTL_PRIVATE_SEL(readMask));
}

_MTL_INLINE void MTL::StencilDescriptor::setDepthFailureOperation(MTL::StencilOperation depthFailureOperation)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthFailureOperation_), depthFailureOperation);
}

_MTL_INLINE void MTL::StencilDescriptor::setDepthStencilPassOperation(MTL::StencilOperation depthStencilPassOperation)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthStencilPassOperation_), depthStencilPassOperation);
}

_MTL_INLINE void MTL::StencilDescriptor::setReadMask(uint32_t readMask)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setReadMask_), readMask);
}

_MTL_INLINE void MTL::StencilDescriptor::setStencilCompareFunction(MTL::CompareFunction stencilCompareFunction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStencilCompareFunction_), stencilCompareFunction);
}

_MTL_INLINE void MTL::StencilDescriptor::setStencilFailureOperation(MTL::StencilOperation stencilFailureOperation)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStencilFailureOperation_), stencilFailureOperation);
}

_MTL_INLINE void MTL::StencilDescriptor::setWriteMask(uint32_t writeMask)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setWriteMask_), writeMask);
}

_MTL_INLINE MTL::CompareFunction MTL::StencilDescriptor::stencilCompareFunction() const
{
    return Object::sendMessage<MTL::CompareFunction>(this, _MTL_PRIVATE_SEL(stencilCompareFunction));
}

_MTL_INLINE MTL::StencilOperation MTL::StencilDescriptor::stencilFailureOperation() const
{
    return Object::sendMessage<MTL::StencilOperation>(this, _MTL_PRIVATE_SEL(stencilFailureOperation));
}

_MTL_INLINE uint32_t MTL::StencilDescriptor::writeMask() const
{
    return Object::sendMessage<uint32_t>(this, _MTL_PRIVATE_SEL(writeMask));
}

_MTL_INLINE MTL::DepthStencilDescriptor* MTL::DepthStencilDescriptor::alloc()
{
    return NS::Object::alloc<MTL::DepthStencilDescriptor>(_MTL_PRIVATE_CLS(MTLDepthStencilDescriptor));
}

_MTL_INLINE MTL::StencilDescriptor* MTL::DepthStencilDescriptor::backFaceStencil() const
{
    return Object::sendMessage<MTL::StencilDescriptor*>(this, _MTL_PRIVATE_SEL(backFaceStencil));
}

_MTL_INLINE MTL::CompareFunction MTL::DepthStencilDescriptor::depthCompareFunction() const
{
    return Object::sendMessage<MTL::CompareFunction>(this, _MTL_PRIVATE_SEL(depthCompareFunction));
}

_MTL_INLINE bool MTL::DepthStencilDescriptor::depthWriteEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isDepthWriteEnabled));
}

_MTL_INLINE MTL::StencilDescriptor* MTL::DepthStencilDescriptor::frontFaceStencil() const
{
    return Object::sendMessage<MTL::StencilDescriptor*>(this, _MTL_PRIVATE_SEL(frontFaceStencil));
}

_MTL_INLINE MTL::DepthStencilDescriptor* MTL::DepthStencilDescriptor::init()
{
    return NS::Object::init<MTL::DepthStencilDescriptor>();
}

_MTL_INLINE bool MTL::DepthStencilDescriptor::isDepthWriteEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isDepthWriteEnabled));
}

_MTL_INLINE NS::String* MTL::DepthStencilDescriptor::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE void MTL::DepthStencilDescriptor::setBackFaceStencil(const MTL::StencilDescriptor* backFaceStencil)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBackFaceStencil_), backFaceStencil);
}

_MTL_INLINE void MTL::DepthStencilDescriptor::setDepthCompareFunction(MTL::CompareFunction depthCompareFunction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthCompareFunction_), depthCompareFunction);
}

_MTL_INLINE void MTL::DepthStencilDescriptor::setDepthWriteEnabled(bool depthWriteEnabled)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthWriteEnabled_), depthWriteEnabled);
}

_MTL_INLINE void MTL::DepthStencilDescriptor::setFrontFaceStencil(const MTL::StencilDescriptor* frontFaceStencil)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFrontFaceStencil_), frontFaceStencil);
}

_MTL_INLINE void MTL::DepthStencilDescriptor::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE MTL::Device* MTL::DepthStencilState::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE MTL::ResourceID MTL::DepthStencilState::gpuResourceID() const
{
    return Object::sendMessage<MTL::ResourceID>(this, _MTL_PRIVATE_SEL(gpuResourceID));
}

_MTL_INLINE NS::String* MTL::DepthStencilState::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

namespace MTL
{
class AccelerationStructure;
class ArgumentEncoder;
class Buffer;
class ComputePipelineState;
class Device;
class IndirectCommandBuffer;
class IntersectionFunctionTable;
class RenderPipelineState;
class SamplerState;
class Texture;
class VisibleFunctionTable;

static const NS::UInteger AttributeStrideStatic = NS::UIntegerMax;

class ArgumentEncoder : public NS::Referencing<ArgumentEncoder>
{
public:
    NS::UInteger     alignment() const;

    void*            constantData(NS::UInteger index);

    Device*          device() const;

    NS::UInteger     encodedLength() const;

    NS::String*      label() const;

    ArgumentEncoder* newArgumentEncoder(NS::UInteger index);

    void             setAccelerationStructure(const MTL::AccelerationStructure* accelerationStructure, NS::UInteger index);

    void             setArgumentBuffer(const MTL::Buffer* argumentBuffer, NS::UInteger offset);
    void             setArgumentBuffer(const MTL::Buffer* argumentBuffer, NS::UInteger startOffset, NS::UInteger arrayElement);

    void             setBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index);
    void             setBuffers(const MTL::Buffer* const buffers[], const NS::UInteger offsets[], NS::Range range);

    void             setComputePipelineState(const MTL::ComputePipelineState* pipeline, NS::UInteger index);
    void             setComputePipelineStates(const MTL::ComputePipelineState* const pipelines[], NS::Range range);

    void             setDepthStencilState(const MTL::DepthStencilState* depthStencilState, NS::UInteger index);
    void             setDepthStencilStates(const MTL::DepthStencilState* const depthStencilStates[], NS::Range range);

    void             setIndirectCommandBuffer(const MTL::IndirectCommandBuffer* indirectCommandBuffer, NS::UInteger index);
    void             setIndirectCommandBuffers(const MTL::IndirectCommandBuffer* const buffers[], NS::Range range);

    void             setIntersectionFunctionTable(const MTL::IntersectionFunctionTable* intersectionFunctionTable, NS::UInteger index);
    void             setIntersectionFunctionTables(const MTL::IntersectionFunctionTable* const intersectionFunctionTables[], NS::Range range);

    void             setLabel(const NS::String* label);

    void             setRenderPipelineState(const MTL::RenderPipelineState* pipeline, NS::UInteger index);
    void             setRenderPipelineStates(const MTL::RenderPipelineState* const pipelines[], NS::Range range);

    void             setSamplerState(const MTL::SamplerState* sampler, NS::UInteger index);
    void             setSamplerStates(const MTL::SamplerState* const samplers[], NS::Range range);

    void             setTexture(const MTL::Texture* texture, NS::UInteger index);
    void             setTextures(const MTL::Texture* const textures[], NS::Range range);

    void             setVisibleFunctionTable(const MTL::VisibleFunctionTable* visibleFunctionTable, NS::UInteger index);
    void             setVisibleFunctionTables(const MTL::VisibleFunctionTable* const visibleFunctionTables[], NS::Range range);
};

}

_MTL_INLINE NS::UInteger MTL::ArgumentEncoder::alignment() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(alignment));
}

_MTL_INLINE void* MTL::ArgumentEncoder::constantData(NS::UInteger index)
{
    return Object::sendMessage<void*>(this, _MTL_PRIVATE_SEL(constantDataAtIndex_), index);
}

_MTL_INLINE MTL::Device* MTL::ArgumentEncoder::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE NS::UInteger MTL::ArgumentEncoder::encodedLength() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(encodedLength));
}

_MTL_INLINE NS::String* MTL::ArgumentEncoder::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE MTL::ArgumentEncoder* MTL::ArgumentEncoder::newArgumentEncoder(NS::UInteger index)
{
    return Object::sendMessage<MTL::ArgumentEncoder*>(this, _MTL_PRIVATE_SEL(newArgumentEncoderForBufferAtIndex_), index);
}

_MTL_INLINE void MTL::ArgumentEncoder::setAccelerationStructure(const MTL::AccelerationStructure* accelerationStructure, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setAccelerationStructure_atIndex_), accelerationStructure, index);
}

_MTL_INLINE void MTL::ArgumentEncoder::setArgumentBuffer(const MTL::Buffer* argumentBuffer, NS::UInteger offset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setArgumentBuffer_offset_), argumentBuffer, offset);
}

_MTL_INLINE void MTL::ArgumentEncoder::setArgumentBuffer(const MTL::Buffer* argumentBuffer, NS::UInteger startOffset, NS::UInteger arrayElement)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setArgumentBuffer_startOffset_arrayElement_), argumentBuffer, startOffset, arrayElement);
}

_MTL_INLINE void MTL::ArgumentEncoder::setBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBuffer_offset_atIndex_), buffer, offset, index);
}

_MTL_INLINE void MTL::ArgumentEncoder::setBuffers(const MTL::Buffer* const buffers[], const NS::UInteger offsets[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBuffers_offsets_withRange_), buffers, offsets, range);
}

_MTL_INLINE void MTL::ArgumentEncoder::setComputePipelineState(const MTL::ComputePipelineState* pipeline, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setComputePipelineState_atIndex_), pipeline, index);
}

_MTL_INLINE void MTL::ArgumentEncoder::setComputePipelineStates(const MTL::ComputePipelineState* const pipelines[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setComputePipelineStates_withRange_), pipelines, range);
}

_MTL_INLINE void MTL::ArgumentEncoder::setDepthStencilState(const MTL::DepthStencilState* depthStencilState, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthStencilState_atIndex_), depthStencilState, index);
}

_MTL_INLINE void MTL::ArgumentEncoder::setDepthStencilStates(const MTL::DepthStencilState* const depthStencilStates[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthStencilStates_withRange_), depthStencilStates, range);
}

_MTL_INLINE void MTL::ArgumentEncoder::setIndirectCommandBuffer(const MTL::IndirectCommandBuffer* indirectCommandBuffer, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIndirectCommandBuffer_atIndex_), indirectCommandBuffer, index);
}

_MTL_INLINE void MTL::ArgumentEncoder::setIndirectCommandBuffers(const MTL::IndirectCommandBuffer* const buffers[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIndirectCommandBuffers_withRange_), buffers, range);
}

_MTL_INLINE void MTL::ArgumentEncoder::setIntersectionFunctionTable(const MTL::IntersectionFunctionTable* intersectionFunctionTable, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIntersectionFunctionTable_atIndex_), intersectionFunctionTable, index);
}

_MTL_INLINE void MTL::ArgumentEncoder::setIntersectionFunctionTables(const MTL::IntersectionFunctionTable* const intersectionFunctionTables[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIntersectionFunctionTables_withRange_), intersectionFunctionTables, range);
}

_MTL_INLINE void MTL::ArgumentEncoder::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE void MTL::ArgumentEncoder::setRenderPipelineState(const MTL::RenderPipelineState* pipeline, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRenderPipelineState_atIndex_), pipeline, index);
}

_MTL_INLINE void MTL::ArgumentEncoder::setRenderPipelineStates(const MTL::RenderPipelineState* const pipelines[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRenderPipelineStates_withRange_), pipelines, range);
}

_MTL_INLINE void MTL::ArgumentEncoder::setSamplerState(const MTL::SamplerState* sampler, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSamplerState_atIndex_), sampler, index);
}

_MTL_INLINE void MTL::ArgumentEncoder::setSamplerStates(const MTL::SamplerState* const samplers[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSamplerStates_withRange_), samplers, range);
}

_MTL_INLINE void MTL::ArgumentEncoder::setTexture(const MTL::Texture* texture, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTexture_atIndex_), texture, index);
}

_MTL_INLINE void MTL::ArgumentEncoder::setTextures(const MTL::Texture* const textures[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTextures_withRange_), textures, range);
}

_MTL_INLINE void MTL::ArgumentEncoder::setVisibleFunctionTable(const MTL::VisibleFunctionTable* visibleFunctionTable, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVisibleFunctionTable_atIndex_), visibleFunctionTable, index);
}

_MTL_INLINE void MTL::ArgumentEncoder::setVisibleFunctionTables(const MTL::VisibleFunctionTable* const visibleFunctionTables[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVisibleFunctionTables_withRange_), visibleFunctionTables, range);
}

#pragma once

namespace MTL
{
class BinaryArchiveDescriptor;
class ComputePipelineDescriptor;
class Device;
class FunctionDescriptor;
class Library;
class MeshRenderPipelineDescriptor;
class RenderPipelineDescriptor;
class StitchedLibraryDescriptor;
class TileRenderPipelineDescriptor;
_MTL_ENUM(NS::UInteger, BinaryArchiveError) {
    BinaryArchiveErrorNone = 0,
    BinaryArchiveErrorInvalidFile = 1,
    BinaryArchiveErrorUnexpectedElement = 2,
    BinaryArchiveErrorCompilationFailure = 3,
    BinaryArchiveErrorInternalError = 4,
};

_MTL_CONST(NS::ErrorDomain, BinaryArchiveDomain);
class BinaryArchiveDescriptor : public NS::Copying<BinaryArchiveDescriptor>
{
public:
    static BinaryArchiveDescriptor* alloc();

    BinaryArchiveDescriptor*        init();

    void                            setUrl(const NS::URL* url);
    NS::URL*                        url() const;
};
class BinaryArchive : public NS::Referencing<BinaryArchive>
{
public:
    bool        addComputePipelineFunctions(const MTL::ComputePipelineDescriptor* descriptor, NS::Error** error);

    bool        addFunction(const MTL::FunctionDescriptor* descriptor, const MTL::Library* library, NS::Error** error);

    bool        addLibrary(const MTL::StitchedLibraryDescriptor* descriptor, NS::Error** error);

    bool        addMeshRenderPipelineFunctions(const MTL::MeshRenderPipelineDescriptor* descriptor, NS::Error** error);

    bool        addRenderPipelineFunctions(const MTL::RenderPipelineDescriptor* descriptor, NS::Error** error);

    bool        addTileRenderPipelineFunctions(const MTL::TileRenderPipelineDescriptor* descriptor, NS::Error** error);

    Device*     device() const;

    NS::String* label() const;

    bool        serializeToURL(const NS::URL* url, NS::Error** error);

    void        setLabel(const NS::String* label);
};

}
_MTL_PRIVATE_DEF_CONST(NS::ErrorDomain, BinaryArchiveDomain);
_MTL_INLINE MTL::BinaryArchiveDescriptor* MTL::BinaryArchiveDescriptor::alloc()
{
    return NS::Object::alloc<MTL::BinaryArchiveDescriptor>(_MTL_PRIVATE_CLS(MTLBinaryArchiveDescriptor));
}

_MTL_INLINE MTL::BinaryArchiveDescriptor* MTL::BinaryArchiveDescriptor::init()
{
    return NS::Object::init<MTL::BinaryArchiveDescriptor>();
}

_MTL_INLINE void MTL::BinaryArchiveDescriptor::setUrl(const NS::URL* url)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setUrl_), url);
}

_MTL_INLINE NS::URL* MTL::BinaryArchiveDescriptor::url() const
{
    return Object::sendMessage<NS::URL*>(this, _MTL_PRIVATE_SEL(url));
}

_MTL_INLINE bool MTL::BinaryArchive::addComputePipelineFunctions(const MTL::ComputePipelineDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(addComputePipelineFunctionsWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE bool MTL::BinaryArchive::addFunction(const MTL::FunctionDescriptor* descriptor, const MTL::Library* library, NS::Error** error)
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(addFunctionWithDescriptor_library_error_), descriptor, library, error);
}

_MTL_INLINE bool MTL::BinaryArchive::addLibrary(const MTL::StitchedLibraryDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(addLibraryWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE bool MTL::BinaryArchive::addMeshRenderPipelineFunctions(const MTL::MeshRenderPipelineDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(addMeshRenderPipelineFunctionsWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE bool MTL::BinaryArchive::addRenderPipelineFunctions(const MTL::RenderPipelineDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(addRenderPipelineFunctionsWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE bool MTL::BinaryArchive::addTileRenderPipelineFunctions(const MTL::TileRenderPipelineDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(addTileRenderPipelineFunctionsWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE MTL::Device* MTL::BinaryArchive::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE NS::String* MTL::BinaryArchive::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE bool MTL::BinaryArchive::serializeToURL(const NS::URL* url, NS::Error** error)
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(serializeToURL_error_), url, error);
}

_MTL_INLINE void MTL::BinaryArchive::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

#pragma once

#include <cstdint>

namespace MTL
{
class Buffer;
class CounterSampleBuffer;
class Fence;
class IndirectCommandBuffer;
class Resource;
class Tensor;
class TensorExtents;
class Texture;

_MTL_OPTIONS(NS::UInteger, BlitOption) {
    BlitOptionNone = 0,
    BlitOptionDepthFromDepthStencil = 1,
    BlitOptionStencilFromDepthStencil = 1 << 1,
    BlitOptionRowLinearPVRTC = 1 << 2,
};

class BlitCommandEncoder : public NS::Referencing<BlitCommandEncoder, CommandEncoder>
{
public:
    void copyFromBuffer(const MTL::Buffer* sourceBuffer, NS::UInteger sourceOffset, NS::UInteger sourceBytesPerRow, NS::UInteger sourceBytesPerImage, MTL::Size sourceSize, const MTL::Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, MTL::Origin destinationOrigin);
    void copyFromBuffer(const MTL::Buffer* sourceBuffer, NS::UInteger sourceOffset, NS::UInteger sourceBytesPerRow, NS::UInteger sourceBytesPerImage, MTL::Size sourceSize, const MTL::Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, MTL::Origin destinationOrigin, MTL::BlitOption options);
    void copyFromBuffer(const MTL::Buffer* sourceBuffer, NS::UInteger sourceOffset, const MTL::Buffer* destinationBuffer, NS::UInteger destinationOffset, NS::UInteger size);

    void copyFromTensor(const MTL::Tensor* sourceTensor, const MTL::TensorExtents* sourceOrigin, const MTL::TensorExtents* sourceDimensions, const MTL::Tensor* destinationTensor, const MTL::TensorExtents* destinationOrigin, const MTL::TensorExtents* destinationDimensions);

    void copyFromTexture(const MTL::Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, MTL::Origin sourceOrigin, MTL::Size sourceSize, const MTL::Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, MTL::Origin destinationOrigin);
    void copyFromTexture(const MTL::Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, MTL::Origin sourceOrigin, MTL::Size sourceSize, const MTL::Buffer* destinationBuffer, NS::UInteger destinationOffset, NS::UInteger destinationBytesPerRow, NS::UInteger destinationBytesPerImage);
    void copyFromTexture(const MTL::Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, MTL::Origin sourceOrigin, MTL::Size sourceSize, const MTL::Buffer* destinationBuffer, NS::UInteger destinationOffset, NS::UInteger destinationBytesPerRow, NS::UInteger destinationBytesPerImage, MTL::BlitOption options);
    void copyFromTexture(const MTL::Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, const MTL::Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, NS::UInteger sliceCount, NS::UInteger levelCount);
    void copyFromTexture(const MTL::Texture* sourceTexture, const MTL::Texture* destinationTexture);

    void copyIndirectCommandBuffer(const MTL::IndirectCommandBuffer* source, NS::Range sourceRange, const MTL::IndirectCommandBuffer* destination, NS::UInteger destinationIndex);

    void fillBuffer(const MTL::Buffer* buffer, NS::Range range, uint8_t value);

    void generateMipmaps(const MTL::Texture* texture);

    void getTextureAccessCounters(const MTL::Texture* texture, MTL::Region region, NS::UInteger mipLevel, NS::UInteger slice, bool resetCounters, const MTL::Buffer* countersBuffer, NS::UInteger countersBufferOffset);

    void optimizeContentsForCPUAccess(const MTL::Texture* texture);
    void optimizeContentsForCPUAccess(const MTL::Texture* texture, NS::UInteger slice, NS::UInteger level);

    void optimizeContentsForGPUAccess(const MTL::Texture* texture);
    void optimizeContentsForGPUAccess(const MTL::Texture* texture, NS::UInteger slice, NS::UInteger level);

    void optimizeIndirectCommandBuffer(const MTL::IndirectCommandBuffer* indirectCommandBuffer, NS::Range range);

    void resetCommandsInBuffer(const MTL::IndirectCommandBuffer* buffer, NS::Range range);

    void resetTextureAccessCounters(const MTL::Texture* texture, MTL::Region region, NS::UInteger mipLevel, NS::UInteger slice);

    void resolveCounters(const MTL::CounterSampleBuffer* sampleBuffer, NS::Range range, const MTL::Buffer* destinationBuffer, NS::UInteger destinationOffset);

    void sampleCountersInBuffer(const MTL::CounterSampleBuffer* sampleBuffer, NS::UInteger sampleIndex, bool barrier);

    void synchronizeResource(const MTL::Resource* resource);

    void synchronizeTexture(const MTL::Texture* texture, NS::UInteger slice, NS::UInteger level);

    void updateFence(const MTL::Fence* fence);

    void waitForFence(const MTL::Fence* fence);
};

}
_MTL_INLINE void MTL::BlitCommandEncoder::copyFromBuffer(const MTL::Buffer* sourceBuffer, NS::UInteger sourceOffset, NS::UInteger sourceBytesPerRow, NS::UInteger sourceBytesPerImage, MTL::Size sourceSize, const MTL::Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, MTL::Origin destinationOrigin)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyFromBuffer_sourceOffset_sourceBytesPerRow_sourceBytesPerImage_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin_), sourceBuffer, sourceOffset, sourceBytesPerRow, sourceBytesPerImage, sourceSize, destinationTexture, destinationSlice, destinationLevel, destinationOrigin);
}

_MTL_INLINE void MTL::BlitCommandEncoder::copyFromBuffer(const MTL::Buffer* sourceBuffer, NS::UInteger sourceOffset, NS::UInteger sourceBytesPerRow, NS::UInteger sourceBytesPerImage, MTL::Size sourceSize, const MTL::Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, MTL::Origin destinationOrigin, MTL::BlitOption options)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyFromBuffer_sourceOffset_sourceBytesPerRow_sourceBytesPerImage_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin_options_), sourceBuffer, sourceOffset, sourceBytesPerRow, sourceBytesPerImage, sourceSize, destinationTexture, destinationSlice, destinationLevel, destinationOrigin, options);
}

_MTL_INLINE void MTL::BlitCommandEncoder::copyFromBuffer(const MTL::Buffer* sourceBuffer, NS::UInteger sourceOffset, const MTL::Buffer* destinationBuffer, NS::UInteger destinationOffset, NS::UInteger size)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyFromBuffer_sourceOffset_toBuffer_destinationOffset_size_), sourceBuffer, sourceOffset, destinationBuffer, destinationOffset, size);
}

_MTL_INLINE void MTL::BlitCommandEncoder::copyFromTensor(const MTL::Tensor* sourceTensor, const MTL::TensorExtents* sourceOrigin, const MTL::TensorExtents* sourceDimensions, const MTL::Tensor* destinationTensor, const MTL::TensorExtents* destinationOrigin, const MTL::TensorExtents* destinationDimensions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyFromTensor_sourceOrigin_sourceDimensions_toTensor_destinationOrigin_destinationDimensions_), sourceTensor, sourceOrigin, sourceDimensions, destinationTensor, destinationOrigin, destinationDimensions);
}

_MTL_INLINE void MTL::BlitCommandEncoder::copyFromTexture(const MTL::Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, MTL::Origin sourceOrigin, MTL::Size sourceSize, const MTL::Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, MTL::Origin destinationOrigin)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin_), sourceTexture, sourceSlice, sourceLevel, sourceOrigin, sourceSize, destinationTexture, destinationSlice, destinationLevel, destinationOrigin);
}

_MTL_INLINE void MTL::BlitCommandEncoder::copyFromTexture(const MTL::Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, MTL::Origin sourceOrigin, MTL::Size sourceSize, const MTL::Buffer* destinationBuffer, NS::UInteger destinationOffset, NS::UInteger destinationBytesPerRow, NS::UInteger destinationBytesPerImage)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toBuffer_destinationOffset_destinationBytesPerRow_destinationBytesPerImage_), sourceTexture, sourceSlice, sourceLevel, sourceOrigin, sourceSize, destinationBuffer, destinationOffset, destinationBytesPerRow, destinationBytesPerImage);
}

_MTL_INLINE void MTL::BlitCommandEncoder::copyFromTexture(const MTL::Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, MTL::Origin sourceOrigin, MTL::Size sourceSize, const MTL::Buffer* destinationBuffer, NS::UInteger destinationOffset, NS::UInteger destinationBytesPerRow, NS::UInteger destinationBytesPerImage, MTL::BlitOption options)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toBuffer_destinationOffset_destinationBytesPerRow_destinationBytesPerImage_options_), sourceTexture, sourceSlice, sourceLevel, sourceOrigin, sourceSize, destinationBuffer, destinationOffset, destinationBytesPerRow, destinationBytesPerImage, options);
}

_MTL_INLINE void MTL::BlitCommandEncoder::copyFromTexture(const MTL::Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, const MTL::Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, NS::UInteger sliceCount, NS::UInteger levelCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyFromTexture_sourceSlice_sourceLevel_toTexture_destinationSlice_destinationLevel_sliceCount_levelCount_), sourceTexture, sourceSlice, sourceLevel, destinationTexture, destinationSlice, destinationLevel, sliceCount, levelCount);
}

_MTL_INLINE void MTL::BlitCommandEncoder::copyFromTexture(const MTL::Texture* sourceTexture, const MTL::Texture* destinationTexture)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyFromTexture_toTexture_), sourceTexture, destinationTexture);
}

_MTL_INLINE void MTL::BlitCommandEncoder::copyIndirectCommandBuffer(const MTL::IndirectCommandBuffer* source, NS::Range sourceRange, const MTL::IndirectCommandBuffer* destination, NS::UInteger destinationIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyIndirectCommandBuffer_sourceRange_destination_destinationIndex_), source, sourceRange, destination, destinationIndex);
}

_MTL_INLINE void MTL::BlitCommandEncoder::fillBuffer(const MTL::Buffer* buffer, NS::Range range, uint8_t value)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(fillBuffer_range_value_), buffer, range, value);
}

_MTL_INLINE void MTL::BlitCommandEncoder::generateMipmaps(const MTL::Texture* texture)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(generateMipmapsForTexture_), texture);
}

_MTL_INLINE void MTL::BlitCommandEncoder::getTextureAccessCounters(const MTL::Texture* texture, MTL::Region region, NS::UInteger mipLevel, NS::UInteger slice, bool resetCounters, const MTL::Buffer* countersBuffer, NS::UInteger countersBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(getTextureAccessCounters_region_mipLevel_slice_resetCounters_countersBuffer_countersBufferOffset_), texture, region, mipLevel, slice, resetCounters, countersBuffer, countersBufferOffset);
}

_MTL_INLINE void MTL::BlitCommandEncoder::optimizeContentsForCPUAccess(const MTL::Texture* texture)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(optimizeContentsForCPUAccess_), texture);
}

_MTL_INLINE void MTL::BlitCommandEncoder::optimizeContentsForCPUAccess(const MTL::Texture* texture, NS::UInteger slice, NS::UInteger level)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(optimizeContentsForCPUAccess_slice_level_), texture, slice, level);
}

_MTL_INLINE void MTL::BlitCommandEncoder::optimizeContentsForGPUAccess(const MTL::Texture* texture)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(optimizeContentsForGPUAccess_), texture);
}

_MTL_INLINE void MTL::BlitCommandEncoder::optimizeContentsForGPUAccess(const MTL::Texture* texture, NS::UInteger slice, NS::UInteger level)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(optimizeContentsForGPUAccess_slice_level_), texture, slice, level);
}

_MTL_INLINE void MTL::BlitCommandEncoder::optimizeIndirectCommandBuffer(const MTL::IndirectCommandBuffer* indirectCommandBuffer, NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(optimizeIndirectCommandBuffer_withRange_), indirectCommandBuffer, range);
}

_MTL_INLINE void MTL::BlitCommandEncoder::resetCommandsInBuffer(const MTL::IndirectCommandBuffer* buffer, NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(resetCommandsInBuffer_withRange_), buffer, range);
}

_MTL_INLINE void MTL::BlitCommandEncoder::resetTextureAccessCounters(const MTL::Texture* texture, MTL::Region region, NS::UInteger mipLevel, NS::UInteger slice)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(resetTextureAccessCounters_region_mipLevel_slice_), texture, region, mipLevel, slice);
}

_MTL_INLINE void MTL::BlitCommandEncoder::resolveCounters(const MTL::CounterSampleBuffer* sampleBuffer, NS::Range range, const MTL::Buffer* destinationBuffer, NS::UInteger destinationOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(resolveCounters_inRange_destinationBuffer_destinationOffset_), sampleBuffer, range, destinationBuffer, destinationOffset);
}

_MTL_INLINE void MTL::BlitCommandEncoder::sampleCountersInBuffer(const MTL::CounterSampleBuffer* sampleBuffer, NS::UInteger sampleIndex, bool barrier)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(sampleCountersInBuffer_atSampleIndex_withBarrier_), sampleBuffer, sampleIndex, barrier);
}

_MTL_INLINE void MTL::BlitCommandEncoder::synchronizeResource(const MTL::Resource* resource)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(synchronizeResource_), resource);
}

_MTL_INLINE void MTL::BlitCommandEncoder::synchronizeTexture(const MTL::Texture* texture, NS::UInteger slice, NS::UInteger level)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(synchronizeTexture_slice_level_), texture, slice, level);
}

_MTL_INLINE void MTL::BlitCommandEncoder::updateFence(const MTL::Fence* fence)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(updateFence_), fence);
}

_MTL_INLINE void MTL::BlitCommandEncoder::waitForFence(const MTL::Fence* fence)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(waitForFence_), fence);
}

#pragma once

namespace MTL
{
class BlitPassDescriptor;
class BlitPassSampleBufferAttachmentDescriptor;
class BlitPassSampleBufferAttachmentDescriptorArray;
class CounterSampleBuffer;

class BlitPassSampleBufferAttachmentDescriptor : public NS::Copying<BlitPassSampleBufferAttachmentDescriptor>
{
public:
    static BlitPassSampleBufferAttachmentDescriptor* alloc();

    NS::UInteger                                     endOfEncoderSampleIndex() const;

    BlitPassSampleBufferAttachmentDescriptor*        init();

    CounterSampleBuffer*                             sampleBuffer() const;

    void                                             setEndOfEncoderSampleIndex(NS::UInteger endOfEncoderSampleIndex);

    void                                             setSampleBuffer(const MTL::CounterSampleBuffer* sampleBuffer);

    void                                             setStartOfEncoderSampleIndex(NS::UInteger startOfEncoderSampleIndex);
    NS::UInteger                                     startOfEncoderSampleIndex() const;
};
class BlitPassSampleBufferAttachmentDescriptorArray : public NS::Referencing<BlitPassSampleBufferAttachmentDescriptorArray>
{
public:
    static BlitPassSampleBufferAttachmentDescriptorArray* alloc();

    BlitPassSampleBufferAttachmentDescriptorArray*        init();

    BlitPassSampleBufferAttachmentDescriptor*             object(NS::UInteger attachmentIndex);
    void                                                  setObject(const MTL::BlitPassSampleBufferAttachmentDescriptor* attachment, NS::UInteger attachmentIndex);
};
class BlitPassDescriptor : public NS::Copying<BlitPassDescriptor>
{
public:
    static BlitPassDescriptor*                     alloc();

    static BlitPassDescriptor*                     blitPassDescriptor();

    BlitPassDescriptor*                            init();

    BlitPassSampleBufferAttachmentDescriptorArray* sampleBufferAttachments() const;
};

}
_MTL_INLINE MTL::BlitPassSampleBufferAttachmentDescriptor* MTL::BlitPassSampleBufferAttachmentDescriptor::alloc()
{
    return NS::Object::alloc<MTL::BlitPassSampleBufferAttachmentDescriptor>(_MTL_PRIVATE_CLS(MTLBlitPassSampleBufferAttachmentDescriptor));
}

_MTL_INLINE NS::UInteger MTL::BlitPassSampleBufferAttachmentDescriptor::endOfEncoderSampleIndex() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(endOfEncoderSampleIndex));
}

_MTL_INLINE MTL::BlitPassSampleBufferAttachmentDescriptor* MTL::BlitPassSampleBufferAttachmentDescriptor::init()
{
    return NS::Object::init<MTL::BlitPassSampleBufferAttachmentDescriptor>();
}

_MTL_INLINE MTL::CounterSampleBuffer* MTL::BlitPassSampleBufferAttachmentDescriptor::sampleBuffer() const
{
    return Object::sendMessage<MTL::CounterSampleBuffer*>(this, _MTL_PRIVATE_SEL(sampleBuffer));
}

_MTL_INLINE void MTL::BlitPassSampleBufferAttachmentDescriptor::setEndOfEncoderSampleIndex(NS::UInteger endOfEncoderSampleIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setEndOfEncoderSampleIndex_), endOfEncoderSampleIndex);
}

_MTL_INLINE void MTL::BlitPassSampleBufferAttachmentDescriptor::setSampleBuffer(const MTL::CounterSampleBuffer* sampleBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSampleBuffer_), sampleBuffer);
}

_MTL_INLINE void MTL::BlitPassSampleBufferAttachmentDescriptor::setStartOfEncoderSampleIndex(NS::UInteger startOfEncoderSampleIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStartOfEncoderSampleIndex_), startOfEncoderSampleIndex);
}

_MTL_INLINE NS::UInteger MTL::BlitPassSampleBufferAttachmentDescriptor::startOfEncoderSampleIndex() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(startOfEncoderSampleIndex));
}

_MTL_INLINE MTL::BlitPassSampleBufferAttachmentDescriptorArray* MTL::BlitPassSampleBufferAttachmentDescriptorArray::alloc()
{
    return NS::Object::alloc<MTL::BlitPassSampleBufferAttachmentDescriptorArray>(_MTL_PRIVATE_CLS(MTLBlitPassSampleBufferAttachmentDescriptorArray));
}

_MTL_INLINE MTL::BlitPassSampleBufferAttachmentDescriptorArray* MTL::BlitPassSampleBufferAttachmentDescriptorArray::init()
{
    return NS::Object::init<MTL::BlitPassSampleBufferAttachmentDescriptorArray>();
}

_MTL_INLINE MTL::BlitPassSampleBufferAttachmentDescriptor* MTL::BlitPassSampleBufferAttachmentDescriptorArray::object(NS::UInteger attachmentIndex)
{
    return Object::sendMessage<MTL::BlitPassSampleBufferAttachmentDescriptor*>(this, _MTL_PRIVATE_SEL(objectAtIndexedSubscript_), attachmentIndex);
}

_MTL_INLINE void MTL::BlitPassSampleBufferAttachmentDescriptorArray::setObject(const MTL::BlitPassSampleBufferAttachmentDescriptor* attachment, NS::UInteger attachmentIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObject_atIndexedSubscript_), attachment, attachmentIndex);
}

_MTL_INLINE MTL::BlitPassDescriptor* MTL::BlitPassDescriptor::alloc()
{
    return NS::Object::alloc<MTL::BlitPassDescriptor>(_MTL_PRIVATE_CLS(MTLBlitPassDescriptor));
}

_MTL_INLINE MTL::BlitPassDescriptor* MTL::BlitPassDescriptor::blitPassDescriptor()
{
    return Object::sendMessage<MTL::BlitPassDescriptor*>(_MTL_PRIVATE_CLS(MTLBlitPassDescriptor), _MTL_PRIVATE_SEL(blitPassDescriptor));
}

_MTL_INLINE MTL::BlitPassDescriptor* MTL::BlitPassDescriptor::init()
{
    return NS::Object::init<MTL::BlitPassDescriptor>();
}

_MTL_INLINE MTL::BlitPassSampleBufferAttachmentDescriptorArray* MTL::BlitPassDescriptor::sampleBufferAttachments() const
{
    return Object::sendMessage<MTL::BlitPassSampleBufferAttachmentDescriptorArray*>(this, _MTL_PRIVATE_SEL(sampleBufferAttachments));
}

#pragma once

#pragma once

#ifdef __METAL_VERSION__

#include <metal_stdlib>

#else

#include <cstdint>

#endif // __METAL_VERSION__

namespace MTL
{
    using GPUAddress = uint64_t;
}

namespace MTL
{
class Buffer;
class Device;
class Tensor;
class TensorDescriptor;
class Texture;
class TextureDescriptor;

class Buffer : public NS::Referencing<Buffer, Resource>
{
public:
    void             addDebugMarker(const NS::String* marker, NS::Range range);

    void*            contents();

    void             didModifyRange(NS::Range range);

    GPUAddress       gpuAddress() const;

    NS::UInteger     length() const;

    Buffer*          newRemoteBufferViewForDevice(const MTL::Device* device);

    Tensor*          newTensor(const MTL::TensorDescriptor* descriptor, NS::UInteger offset, NS::Error** error);

    Texture*         newTexture(const MTL::TextureDescriptor* descriptor, NS::UInteger offset, NS::UInteger bytesPerRow);

    Buffer*          remoteStorageBuffer() const;

    void             removeAllDebugMarkers();

    BufferSparseTier sparseBufferTier() const;
};

}
_MTL_INLINE void MTL::Buffer::addDebugMarker(const NS::String* marker, NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(addDebugMarker_range_), marker, range);
}

_MTL_INLINE void* MTL::Buffer::contents()
{
    return Object::sendMessage<void*>(this, _MTL_PRIVATE_SEL(contents));
}

_MTL_INLINE void MTL::Buffer::didModifyRange(NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(didModifyRange_), range);
}

_MTL_INLINE MTL::GPUAddress MTL::Buffer::gpuAddress() const
{
    return Object::sendMessage<MTL::GPUAddress>(this, _MTL_PRIVATE_SEL(gpuAddress));
}

_MTL_INLINE NS::UInteger MTL::Buffer::length() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(length));
}

_MTL_INLINE MTL::Buffer* MTL::Buffer::newRemoteBufferViewForDevice(const MTL::Device* device)
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(newRemoteBufferViewForDevice_), device);
}

_MTL_INLINE MTL::Tensor* MTL::Buffer::newTensor(const MTL::TensorDescriptor* descriptor, NS::UInteger offset, NS::Error** error)
{
    return Object::sendMessage<MTL::Tensor*>(this, _MTL_PRIVATE_SEL(newTensorWithDescriptor_offset_error_), descriptor, offset, error);
}

_MTL_INLINE MTL::Texture* MTL::Buffer::newTexture(const MTL::TextureDescriptor* descriptor, NS::UInteger offset, NS::UInteger bytesPerRow)
{
    return Object::sendMessage<MTL::Texture*>(this, _MTL_PRIVATE_SEL(newTextureWithDescriptor_offset_bytesPerRow_), descriptor, offset, bytesPerRow);
}

_MTL_INLINE MTL::Buffer* MTL::Buffer::remoteStorageBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(remoteStorageBuffer));
}

_MTL_INLINE void MTL::Buffer::removeAllDebugMarkers()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(removeAllDebugMarkers));
}

_MTL_INLINE MTL::BufferSparseTier MTL::Buffer::sparseBufferTier() const
{
    return Object::sendMessage<MTL::BufferSparseTier>(this, _MTL_PRIVATE_SEL(sparseBufferTier));
}

#pragma once

namespace MTL
{
class CaptureDescriptor;
class CaptureManager;
class CaptureScope;
class CommandQueue;
class Device;
}

namespace MTL4
{
class CommandQueue;
}

namespace MTL
{
_MTL_ENUM(NS::Integer, CaptureError) {
    CaptureErrorNotSupported = 1,
    CaptureErrorAlreadyCapturing = 2,
    CaptureErrorInvalidDescriptor = 3,
};

_MTL_ENUM(NS::Integer, CaptureDestination) {
    CaptureDestinationDeveloperTools = 1,
    CaptureDestinationGPUTraceDocument = 2,
};

class CaptureDescriptor : public NS::Copying<CaptureDescriptor>
{
public:
    static CaptureDescriptor* alloc();

    NS::Object*               captureObject() const;

    CaptureDestination        destination() const;

    CaptureDescriptor*        init();

    NS::URL*                  outputURL() const;

    void                      setCaptureObject(NS::Object* captureObject);

    void                      setDestination(MTL::CaptureDestination destination);

    void                      setOutputURL(const NS::URL* outputURL);
};
class CaptureManager : public NS::Referencing<CaptureManager>
{
public:
    static CaptureManager* alloc();

    CaptureScope*          defaultCaptureScope() const;

    CaptureManager*        init();

    bool                   isCapturing() const;

    CaptureScope*          newCaptureScope(const MTL::Device* device);
    CaptureScope*          newCaptureScope(const MTL::CommandQueue* commandQueue);
    CaptureScope*          newCaptureScope(const MTL4::CommandQueue* commandQueue);

    void                   setDefaultCaptureScope(const MTL::CaptureScope* defaultCaptureScope);

    static CaptureManager* sharedCaptureManager();

    bool                   startCapture(const MTL::CaptureDescriptor* descriptor, NS::Error** error);
    void                   startCapture(const MTL::Device* device);
    void                   startCapture(const MTL::CommandQueue* commandQueue);
    void                   startCapture(const MTL::CaptureScope* captureScope);

    void                   stopCapture();

    bool                   supportsDestination(MTL::CaptureDestination destination);
};

}
_MTL_INLINE MTL::CaptureDescriptor* MTL::CaptureDescriptor::alloc()
{
    return NS::Object::alloc<MTL::CaptureDescriptor>(_MTL_PRIVATE_CLS(MTLCaptureDescriptor));
}

_MTL_INLINE NS::Object* MTL::CaptureDescriptor::captureObject() const
{
    return Object::sendMessage<NS::Object*>(this, _MTL_PRIVATE_SEL(captureObject));
}

_MTL_INLINE MTL::CaptureDestination MTL::CaptureDescriptor::destination() const
{
    return Object::sendMessage<MTL::CaptureDestination>(this, _MTL_PRIVATE_SEL(destination));
}

_MTL_INLINE MTL::CaptureDescriptor* MTL::CaptureDescriptor::init()
{
    return NS::Object::init<MTL::CaptureDescriptor>();
}

_MTL_INLINE NS::URL* MTL::CaptureDescriptor::outputURL() const
{
    return Object::sendMessage<NS::URL*>(this, _MTL_PRIVATE_SEL(outputURL));
}

_MTL_INLINE void MTL::CaptureDescriptor::setCaptureObject(NS::Object* captureObject)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setCaptureObject_), captureObject);
}

_MTL_INLINE void MTL::CaptureDescriptor::setDestination(MTL::CaptureDestination destination)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDestination_), destination);
}

_MTL_INLINE void MTL::CaptureDescriptor::setOutputURL(const NS::URL* outputURL)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setOutputURL_), outputURL);
}

_MTL_INLINE MTL::CaptureManager* MTL::CaptureManager::alloc()
{
    return NS::Object::alloc<MTL::CaptureManager>(_MTL_PRIVATE_CLS(MTLCaptureManager));
}

_MTL_INLINE MTL::CaptureScope* MTL::CaptureManager::defaultCaptureScope() const
{
    return Object::sendMessage<MTL::CaptureScope*>(this, _MTL_PRIVATE_SEL(defaultCaptureScope));
}

_MTL_INLINE MTL::CaptureManager* MTL::CaptureManager::init()
{
    return NS::Object::init<MTL::CaptureManager>();
}

_MTL_INLINE bool MTL::CaptureManager::isCapturing() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isCapturing));
}

_MTL_INLINE MTL::CaptureScope* MTL::CaptureManager::newCaptureScope(const MTL::Device* device)
{
    return Object::sendMessage<MTL::CaptureScope*>(this, _MTL_PRIVATE_SEL(newCaptureScopeWithDevice_), device);
}

_MTL_INLINE MTL::CaptureScope* MTL::CaptureManager::newCaptureScope(const MTL::CommandQueue* commandQueue)
{
    return Object::sendMessage<MTL::CaptureScope*>(this, _MTL_PRIVATE_SEL(newCaptureScopeWithCommandQueue_), commandQueue);
}

_MTL_INLINE MTL::CaptureScope* MTL::CaptureManager::newCaptureScope(const MTL4::CommandQueue* commandQueue)
{
    return Object::sendMessage<MTL::CaptureScope*>(this, _MTL_PRIVATE_SEL(newCaptureScopeWithMTL4CommandQueue_), commandQueue);
}

_MTL_INLINE void MTL::CaptureManager::setDefaultCaptureScope(const MTL::CaptureScope* defaultCaptureScope)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDefaultCaptureScope_), defaultCaptureScope);
}

_MTL_INLINE MTL::CaptureManager* MTL::CaptureManager::sharedCaptureManager()
{
    return Object::sendMessage<MTL::CaptureManager*>(_MTL_PRIVATE_CLS(MTLCaptureManager), _MTL_PRIVATE_SEL(sharedCaptureManager));
}

_MTL_INLINE bool MTL::CaptureManager::startCapture(const MTL::CaptureDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(startCaptureWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE void MTL::CaptureManager::startCapture(const MTL::Device* device)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(startCaptureWithDevice_), device);
}

_MTL_INLINE void MTL::CaptureManager::startCapture(const MTL::CommandQueue* commandQueue)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(startCaptureWithCommandQueue_), commandQueue);
}

_MTL_INLINE void MTL::CaptureManager::startCapture(const MTL::CaptureScope* captureScope)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(startCaptureWithScope_), captureScope);
}

_MTL_INLINE void MTL::CaptureManager::stopCapture()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(stopCapture));
}

_MTL_INLINE bool MTL::CaptureManager::supportsDestination(MTL::CaptureDestination destination)
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportsDestination_), destination);
}

namespace MTL
{
class CaptureScope : public NS::Referencing<CaptureScope>
{
public:
    class Device*       device() const;

    NS::String*         label() const;
    void                setLabel(const NS::String* pLabel);

    class CommandQueue* commandQueue() const;

    void                beginScope();
    void                endScope();
};
}

_MTL_INLINE MTL::Device* MTL::CaptureScope::device() const
{
    return Object::sendMessage<Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE NS::String* MTL::CaptureScope::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE void MTL::CaptureScope::setLabel(const NS::String* pLabel)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), pLabel);
}

_MTL_INLINE MTL::CommandQueue* MTL::CaptureScope::commandQueue() const
{
    return Object::sendMessage<CommandQueue*>(this, _MTL_PRIVATE_SEL(commandQueue));
}

_MTL_INLINE void MTL::CaptureScope::beginScope()
{
    return Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(beginScope));
}

_MTL_INLINE void MTL::CaptureScope::endScope()
{
    return Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(endScope));
}

#pragma once

#include <CoreFoundation/CoreFoundation.h>
#include <cstdint>

#include <functional>

namespace MTL
{
class AccelerationStructureCommandEncoder;
class AccelerationStructurePassDescriptor;
class BlitCommandEncoder;
class BlitPassDescriptor;
class CommandBuffer;
class CommandBufferDescriptor;
class CommandQueue;
class ComputeCommandEncoder;
class ComputePassDescriptor;
class Device;
class Drawable;
class Event;
class LogContainer;
class LogState;
class ParallelRenderCommandEncoder;
class RenderCommandEncoder;
class RenderPassDescriptor;
class ResidencySet;
class ResourceStateCommandEncoder;
class ResourceStatePassDescriptor;
_MTL_ENUM(NS::UInteger, CommandBufferStatus) {
    CommandBufferStatusNotEnqueued = 0,
    CommandBufferStatusEnqueued = 1,
    CommandBufferStatusCommitted = 2,
    CommandBufferStatusScheduled = 3,
    CommandBufferStatusCompleted = 4,
    CommandBufferStatusError = 5,
};

_MTL_ENUM(NS::UInteger, CommandBufferError) {
    CommandBufferErrorNone = 0,
    CommandBufferErrorInternal = 1,
    CommandBufferErrorTimeout = 2,
    CommandBufferErrorPageFault = 3,
    CommandBufferErrorBlacklisted = 4,
    CommandBufferErrorAccessRevoked = 4,
    CommandBufferErrorNotPermitted = 7,
    CommandBufferErrorOutOfMemory = 8,
    CommandBufferErrorInvalidResource = 9,
    CommandBufferErrorMemoryless = 10,
    CommandBufferErrorDeviceRemoved = 11,
    CommandBufferErrorStackOverflow = 12,
};

_MTL_ENUM(NS::Integer, CommandEncoderErrorState) {
    CommandEncoderErrorStateUnknown = 0,
    CommandEncoderErrorStateCompleted = 1,
    CommandEncoderErrorStateAffected = 2,
    CommandEncoderErrorStatePending = 3,
    CommandEncoderErrorStateFaulted = 4,
};

_MTL_ENUM(NS::UInteger, DispatchType) {
    DispatchTypeSerial = 0,
    DispatchTypeConcurrent = 1,
};

_MTL_OPTIONS(NS::UInteger, CommandBufferErrorOption) {
    CommandBufferErrorOptionNone = 0,
    CommandBufferErrorOptionEncoderExecutionStatus = 1,
};

using CommandBufferHandler = void (^)(CommandBuffer*);
using HandlerFunction = std::function<void(CommandBuffer*)>;

class CommandBufferDescriptor : public NS::Copying<CommandBufferDescriptor>
{
public:
    static CommandBufferDescriptor* alloc();

    CommandBufferErrorOption        errorOptions() const;

    CommandBufferDescriptor*        init();

    LogState*                       logState() const;

    bool                            retainedReferences() const;

    void                            setErrorOptions(MTL::CommandBufferErrorOption errorOptions);

    void                            setLogState(const MTL::LogState* logState);

    void                            setRetainedReferences(bool retainedReferences);
};
class CommandBufferEncoderInfo : public NS::Referencing<CommandBufferEncoderInfo>
{
public:
    NS::Array*               debugSignposts() const;

    CommandEncoderErrorState errorState() const;

    NS::String*              label() const;
};
class CommandBuffer : public NS::Referencing<CommandBuffer>
{
public:
    CFTimeInterval                       GPUEndTime() const;

    CFTimeInterval                       GPUStartTime() const;

    AccelerationStructureCommandEncoder* accelerationStructureCommandEncoder();
    AccelerationStructureCommandEncoder* accelerationStructureCommandEncoder(const MTL::AccelerationStructurePassDescriptor* descriptor);

    void                                 addCompletedHandler(const MTL::CommandBufferHandler block);
    void                                 addCompletedHandler(const MTL::HandlerFunction& function);

    void                                 addScheduledHandler(const MTL::CommandBufferHandler block);
    void                                 addScheduledHandler(const MTL::HandlerFunction& function);

    BlitCommandEncoder*                  blitCommandEncoder();
    BlitCommandEncoder*                  blitCommandEncoder(const MTL::BlitPassDescriptor* blitPassDescriptor);

    CommandQueue*                        commandQueue() const;

    void                                 commit();

    ComputeCommandEncoder*               computeCommandEncoder(const MTL::ComputePassDescriptor* computePassDescriptor);
    ComputeCommandEncoder*               computeCommandEncoder();
    ComputeCommandEncoder*               computeCommandEncoder(MTL::DispatchType dispatchType);

    Device*                              device() const;

    void                                 encodeSignalEvent(const MTL::Event* event, uint64_t value);

    void                                 encodeWait(const MTL::Event* event, uint64_t value);

    void                                 enqueue();

    NS::Error*                           error() const;
    CommandBufferErrorOption             errorOptions() const;

    CFTimeInterval                       kernelEndTime() const;

    CFTimeInterval                       kernelStartTime() const;

    NS::String*                          label() const;

    LogContainer*                        logs() const;

    ParallelRenderCommandEncoder*        parallelRenderCommandEncoder(const MTL::RenderPassDescriptor* renderPassDescriptor);

    void                                 popDebugGroup();

    void                                 presentDrawable(const MTL::Drawable* drawable);
    void                                 presentDrawableAfterMinimumDuration(const MTL::Drawable* drawable, CFTimeInterval duration);

    void                                 presentDrawableAtTime(const MTL::Drawable* drawable, CFTimeInterval presentationTime);

    void                                 pushDebugGroup(const NS::String* string);

    RenderCommandEncoder*                renderCommandEncoder(const MTL::RenderPassDescriptor* renderPassDescriptor);

    ResourceStateCommandEncoder*         resourceStateCommandEncoder();
    ResourceStateCommandEncoder*         resourceStateCommandEncoder(const MTL::ResourceStatePassDescriptor* resourceStatePassDescriptor);

    bool                                 retainedReferences() const;

    void                                 setLabel(const NS::String* label);

    CommandBufferStatus                  status() const;

    void                                 useResidencySet(const MTL::ResidencySet* residencySet);
    void                                 useResidencySets(const MTL::ResidencySet* const residencySets[], NS::UInteger count);

    void                                 waitUntilCompleted();

    void                                 waitUntilScheduled();
};

}
_MTL_INLINE MTL::CommandBufferDescriptor* MTL::CommandBufferDescriptor::alloc()
{
    return NS::Object::alloc<MTL::CommandBufferDescriptor>(_MTL_PRIVATE_CLS(MTLCommandBufferDescriptor));
}

_MTL_INLINE MTL::CommandBufferErrorOption MTL::CommandBufferDescriptor::errorOptions() const
{
    return Object::sendMessage<MTL::CommandBufferErrorOption>(this, _MTL_PRIVATE_SEL(errorOptions));
}

_MTL_INLINE MTL::CommandBufferDescriptor* MTL::CommandBufferDescriptor::init()
{
    return NS::Object::init<MTL::CommandBufferDescriptor>();
}

_MTL_INLINE MTL::LogState* MTL::CommandBufferDescriptor::logState() const
{
    return Object::sendMessage<MTL::LogState*>(this, _MTL_PRIVATE_SEL(logState));
}

_MTL_INLINE bool MTL::CommandBufferDescriptor::retainedReferences() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(retainedReferences));
}

_MTL_INLINE void MTL::CommandBufferDescriptor::setErrorOptions(MTL::CommandBufferErrorOption errorOptions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setErrorOptions_), errorOptions);
}

_MTL_INLINE void MTL::CommandBufferDescriptor::setLogState(const MTL::LogState* logState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLogState_), logState);
}

_MTL_INLINE void MTL::CommandBufferDescriptor::setRetainedReferences(bool retainedReferences)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRetainedReferences_), retainedReferences);
}

_MTL_INLINE NS::Array* MTL::CommandBufferEncoderInfo::debugSignposts() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(debugSignposts));
}

_MTL_INLINE MTL::CommandEncoderErrorState MTL::CommandBufferEncoderInfo::errorState() const
{
    return Object::sendMessage<MTL::CommandEncoderErrorState>(this, _MTL_PRIVATE_SEL(errorState));
}

_MTL_INLINE NS::String* MTL::CommandBufferEncoderInfo::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE CFTimeInterval MTL::CommandBuffer::GPUEndTime() const
{
    return Object::sendMessage<CFTimeInterval>(this, _MTL_PRIVATE_SEL(GPUEndTime));
}

_MTL_INLINE CFTimeInterval MTL::CommandBuffer::GPUStartTime() const
{
    return Object::sendMessage<CFTimeInterval>(this, _MTL_PRIVATE_SEL(GPUStartTime));
}

_MTL_INLINE MTL::AccelerationStructureCommandEncoder* MTL::CommandBuffer::accelerationStructureCommandEncoder()
{
    return Object::sendMessage<MTL::AccelerationStructureCommandEncoder*>(this, _MTL_PRIVATE_SEL(accelerationStructureCommandEncoder));
}

_MTL_INLINE MTL::AccelerationStructureCommandEncoder* MTL::CommandBuffer::accelerationStructureCommandEncoder(const MTL::AccelerationStructurePassDescriptor* descriptor)
{
    return Object::sendMessage<MTL::AccelerationStructureCommandEncoder*>(this, _MTL_PRIVATE_SEL(accelerationStructureCommandEncoderWithDescriptor_), descriptor);
}

_MTL_INLINE void MTL::CommandBuffer::addCompletedHandler(const MTL::CommandBufferHandler block)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(addCompletedHandler_), block);
}

_MTL_INLINE void MTL::CommandBuffer::addCompletedHandler(const MTL::HandlerFunction& function)
{
    __block HandlerFunction blockFunction = function;
    addCompletedHandler(^(MTL::CommandBuffer* pCommandBuffer) { blockFunction(pCommandBuffer); });
}

_MTL_INLINE void MTL::CommandBuffer::addScheduledHandler(const MTL::CommandBufferHandler block)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(addScheduledHandler_), block);
}

_MTL_INLINE void MTL::CommandBuffer::addScheduledHandler(const MTL::HandlerFunction& function)
{
    __block HandlerFunction blockFunction = function;
    addScheduledHandler(^(MTL::CommandBuffer* pCommandBuffer) { blockFunction(pCommandBuffer); });
}

_MTL_INLINE MTL::BlitCommandEncoder* MTL::CommandBuffer::blitCommandEncoder()
{
    return Object::sendMessage<MTL::BlitCommandEncoder*>(this, _MTL_PRIVATE_SEL(blitCommandEncoder));
}

_MTL_INLINE MTL::BlitCommandEncoder* MTL::CommandBuffer::blitCommandEncoder(const MTL::BlitPassDescriptor* blitPassDescriptor)
{
    return Object::sendMessage<MTL::BlitCommandEncoder*>(this, _MTL_PRIVATE_SEL(blitCommandEncoderWithDescriptor_), blitPassDescriptor);
}

_MTL_INLINE MTL::CommandQueue* MTL::CommandBuffer::commandQueue() const
{
    return Object::sendMessage<MTL::CommandQueue*>(this, _MTL_PRIVATE_SEL(commandQueue));
}

_MTL_INLINE void MTL::CommandBuffer::commit()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(commit));
}

_MTL_INLINE MTL::ComputeCommandEncoder* MTL::CommandBuffer::computeCommandEncoder(const MTL::ComputePassDescriptor* computePassDescriptor)
{
    return Object::sendMessage<MTL::ComputeCommandEncoder*>(this, _MTL_PRIVATE_SEL(computeCommandEncoderWithDescriptor_), computePassDescriptor);
}

_MTL_INLINE MTL::ComputeCommandEncoder* MTL::CommandBuffer::computeCommandEncoder()
{
    return Object::sendMessage<MTL::ComputeCommandEncoder*>(this, _MTL_PRIVATE_SEL(computeCommandEncoder));
}

_MTL_INLINE MTL::ComputeCommandEncoder* MTL::CommandBuffer::computeCommandEncoder(MTL::DispatchType dispatchType)
{
    return Object::sendMessage<MTL::ComputeCommandEncoder*>(this, _MTL_PRIVATE_SEL(computeCommandEncoderWithDispatchType_), dispatchType);
}

_MTL_INLINE MTL::Device* MTL::CommandBuffer::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE void MTL::CommandBuffer::encodeSignalEvent(const MTL::Event* event, uint64_t value)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(encodeSignalEvent_value_), event, value);
}

_MTL_INLINE void MTL::CommandBuffer::encodeWait(const MTL::Event* event, uint64_t value)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(encodeWaitForEvent_value_), event, value);
}

_MTL_INLINE void MTL::CommandBuffer::enqueue()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(enqueue));
}

_MTL_INLINE NS::Error* MTL::CommandBuffer::error() const
{
    return Object::sendMessage<NS::Error*>(this, _MTL_PRIVATE_SEL(error));
}

_MTL_INLINE MTL::CommandBufferErrorOption MTL::CommandBuffer::errorOptions() const
{
    return Object::sendMessage<MTL::CommandBufferErrorOption>(this, _MTL_PRIVATE_SEL(errorOptions));
}

_MTL_INLINE CFTimeInterval MTL::CommandBuffer::kernelEndTime() const
{
    return Object::sendMessage<CFTimeInterval>(this, _MTL_PRIVATE_SEL(kernelEndTime));
}

_MTL_INLINE CFTimeInterval MTL::CommandBuffer::kernelStartTime() const
{
    return Object::sendMessage<CFTimeInterval>(this, _MTL_PRIVATE_SEL(kernelStartTime));
}

_MTL_INLINE NS::String* MTL::CommandBuffer::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE MTL::LogContainer* MTL::CommandBuffer::logs() const
{
    return Object::sendMessage<MTL::LogContainer*>(this, _MTL_PRIVATE_SEL(logs));
}

_MTL_INLINE MTL::ParallelRenderCommandEncoder* MTL::CommandBuffer::parallelRenderCommandEncoder(const MTL::RenderPassDescriptor* renderPassDescriptor)
{
    return Object::sendMessage<MTL::ParallelRenderCommandEncoder*>(this, _MTL_PRIVATE_SEL(parallelRenderCommandEncoderWithDescriptor_), renderPassDescriptor);
}

_MTL_INLINE void MTL::CommandBuffer::popDebugGroup()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(popDebugGroup));
}

_MTL_INLINE void MTL::CommandBuffer::presentDrawable(const MTL::Drawable* drawable)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(presentDrawable_), drawable);
}

_MTL_INLINE void MTL::CommandBuffer::presentDrawableAfterMinimumDuration(const MTL::Drawable* drawable, CFTimeInterval duration)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(presentDrawable_afterMinimumDuration_), drawable, duration);
}

_MTL_INLINE void MTL::CommandBuffer::presentDrawableAtTime(const MTL::Drawable* drawable, CFTimeInterval presentationTime)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(presentDrawable_atTime_), drawable, presentationTime);
}

_MTL_INLINE void MTL::CommandBuffer::pushDebugGroup(const NS::String* string)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(pushDebugGroup_), string);
}

_MTL_INLINE MTL::RenderCommandEncoder* MTL::CommandBuffer::renderCommandEncoder(const MTL::RenderPassDescriptor* renderPassDescriptor)
{
    return Object::sendMessage<MTL::RenderCommandEncoder*>(this, _MTL_PRIVATE_SEL(renderCommandEncoderWithDescriptor_), renderPassDescriptor);
}

_MTL_INLINE MTL::ResourceStateCommandEncoder* MTL::CommandBuffer::resourceStateCommandEncoder()
{
    return Object::sendMessage<MTL::ResourceStateCommandEncoder*>(this, _MTL_PRIVATE_SEL(resourceStateCommandEncoder));
}

_MTL_INLINE MTL::ResourceStateCommandEncoder* MTL::CommandBuffer::resourceStateCommandEncoder(const MTL::ResourceStatePassDescriptor* resourceStatePassDescriptor)
{
    return Object::sendMessage<MTL::ResourceStateCommandEncoder*>(this, _MTL_PRIVATE_SEL(resourceStateCommandEncoderWithDescriptor_), resourceStatePassDescriptor);
}

_MTL_INLINE bool MTL::CommandBuffer::retainedReferences() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(retainedReferences));
}

_MTL_INLINE void MTL::CommandBuffer::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE MTL::CommandBufferStatus MTL::CommandBuffer::status() const
{
    return Object::sendMessage<MTL::CommandBufferStatus>(this, _MTL_PRIVATE_SEL(status));
}

_MTL_INLINE void MTL::CommandBuffer::useResidencySet(const MTL::ResidencySet* residencySet)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useResidencySet_), residencySet);
}

_MTL_INLINE void MTL::CommandBuffer::useResidencySets(const MTL::ResidencySet* const residencySets[], NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useResidencySets_count_), residencySets, count);
}

_MTL_INLINE void MTL::CommandBuffer::waitUntilCompleted()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(waitUntilCompleted));
}

_MTL_INLINE void MTL::CommandBuffer::waitUntilScheduled()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(waitUntilScheduled));
}

#pragma once

namespace MTL
{
class CommandBuffer;
class CommandBufferDescriptor;
class CommandQueueDescriptor;
class Device;
class LogState;
class ResidencySet;

class CommandQueue : public NS::Referencing<CommandQueue>
{
public:
    void           addResidencySet(const MTL::ResidencySet* residencySet);
    void           addResidencySets(const MTL::ResidencySet* const residencySets[], NS::UInteger count);

    CommandBuffer* commandBuffer();
    CommandBuffer* commandBuffer(const MTL::CommandBufferDescriptor* descriptor);
    CommandBuffer* commandBufferWithUnretainedReferences();

    Device*        device() const;

    void           insertDebugCaptureBoundary();

    NS::String*    label() const;

    void           removeResidencySet(const MTL::ResidencySet* residencySet);
    void           removeResidencySets(const MTL::ResidencySet* const residencySets[], NS::UInteger count);

    void           setLabel(const NS::String* label);
};
class CommandQueueDescriptor : public NS::Copying<CommandQueueDescriptor>
{
public:
    static CommandQueueDescriptor* alloc();

    CommandQueueDescriptor*        init();

    LogState*                      logState() const;

    NS::UInteger                   maxCommandBufferCount() const;

    void                           setLogState(const MTL::LogState* logState);

    void                           setMaxCommandBufferCount(NS::UInteger maxCommandBufferCount);
};

}
_MTL_INLINE void MTL::CommandQueue::addResidencySet(const MTL::ResidencySet* residencySet)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(addResidencySet_), residencySet);
}

_MTL_INLINE void MTL::CommandQueue::addResidencySets(const MTL::ResidencySet* const residencySets[], NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(addResidencySets_count_), residencySets, count);
}

_MTL_INLINE MTL::CommandBuffer* MTL::CommandQueue::commandBuffer()
{
    return Object::sendMessage<MTL::CommandBuffer*>(this, _MTL_PRIVATE_SEL(commandBuffer));
}

_MTL_INLINE MTL::CommandBuffer* MTL::CommandQueue::commandBuffer(const MTL::CommandBufferDescriptor* descriptor)
{
    return Object::sendMessage<MTL::CommandBuffer*>(this, _MTL_PRIVATE_SEL(commandBufferWithDescriptor_), descriptor);
}

_MTL_INLINE MTL::CommandBuffer* MTL::CommandQueue::commandBufferWithUnretainedReferences()
{
    return Object::sendMessage<MTL::CommandBuffer*>(this, _MTL_PRIVATE_SEL(commandBufferWithUnretainedReferences));
}

_MTL_INLINE MTL::Device* MTL::CommandQueue::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE void MTL::CommandQueue::insertDebugCaptureBoundary()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(insertDebugCaptureBoundary));
}

_MTL_INLINE NS::String* MTL::CommandQueue::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE void MTL::CommandQueue::removeResidencySet(const MTL::ResidencySet* residencySet)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(removeResidencySet_), residencySet);
}

_MTL_INLINE void MTL::CommandQueue::removeResidencySets(const MTL::ResidencySet* const residencySets[], NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(removeResidencySets_count_), residencySets, count);
}

_MTL_INLINE void MTL::CommandQueue::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE MTL::CommandQueueDescriptor* MTL::CommandQueueDescriptor::alloc()
{
    return NS::Object::alloc<MTL::CommandQueueDescriptor>(_MTL_PRIVATE_CLS(MTLCommandQueueDescriptor));
}

_MTL_INLINE MTL::CommandQueueDescriptor* MTL::CommandQueueDescriptor::init()
{
    return NS::Object::init<MTL::CommandQueueDescriptor>();
}

_MTL_INLINE MTL::LogState* MTL::CommandQueueDescriptor::logState() const
{
    return Object::sendMessage<MTL::LogState*>(this, _MTL_PRIVATE_SEL(logState));
}

_MTL_INLINE NS::UInteger MTL::CommandQueueDescriptor::maxCommandBufferCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxCommandBufferCount));
}

_MTL_INLINE void MTL::CommandQueueDescriptor::setLogState(const MTL::LogState* logState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLogState_), logState);
}

_MTL_INLINE void MTL::CommandQueueDescriptor::setMaxCommandBufferCount(NS::UInteger maxCommandBufferCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxCommandBufferCount_), maxCommandBufferCount);
}

#pragma once

#include <cstdint>

namespace MTL
{
class AccelerationStructure;
class Buffer;
class ComputePipelineState;
class CounterSampleBuffer;
class Fence;
class Heap;
class IndirectCommandBuffer;
class IntersectionFunctionTable;
class Resource;
class SamplerState;
class Texture;
class VisibleFunctionTable;

struct DispatchThreadgroupsIndirectArguments
{
    uint32_t threadgroupsPerGrid[3];
} _MTL_PACKED;

struct DispatchThreadsIndirectArguments
{
    uint32_t threadsPerGrid[3];
    uint32_t threadsPerThreadgroup[3];
} _MTL_PACKED;

struct StageInRegionIndirectArguments
{
    uint32_t stageInOrigin[3];
    uint32_t stageInSize[3];
} _MTL_PACKED;

class ComputeCommandEncoder : public NS::Referencing<ComputeCommandEncoder, CommandEncoder>
{
public:
    void         dispatchThreadgroups(MTL::Size threadgroupsPerGrid, MTL::Size threadsPerThreadgroup);
    void         dispatchThreadgroups(const MTL::Buffer* indirectBuffer, NS::UInteger indirectBufferOffset, MTL::Size threadsPerThreadgroup);

    void         dispatchThreads(MTL::Size threadsPerGrid, MTL::Size threadsPerThreadgroup);

    DispatchType dispatchType() const;

    void         executeCommandsInBuffer(const MTL::IndirectCommandBuffer* indirectCommandBuffer, NS::Range executionRange);
    void         executeCommandsInBuffer(const MTL::IndirectCommandBuffer* indirectCommandbuffer, const MTL::Buffer* indirectRangeBuffer, NS::UInteger indirectBufferOffset);

    void         memoryBarrier(MTL::BarrierScope scope);
    void         memoryBarrier(const MTL::Resource* const resources[], NS::UInteger count);

    void         sampleCountersInBuffer(const MTL::CounterSampleBuffer* sampleBuffer, NS::UInteger sampleIndex, bool barrier);

    void         setAccelerationStructure(const MTL::AccelerationStructure* accelerationStructure, NS::UInteger bufferIndex);

    void         setBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index);
    void         setBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger stride, NS::UInteger index);
    void         setBufferOffset(NS::UInteger offset, NS::UInteger index);
    void         setBufferOffset(NS::UInteger offset, NS::UInteger stride, NS::UInteger index);

    void         setBuffers(const MTL::Buffer* const buffers[], const NS::UInteger offsets[], NS::Range range);
    void         setBuffers(const MTL::Buffer* const buffers[], const NS::UInteger* offsets, const NS::UInteger* strides, NS::Range range);

    void         setBytes(const void* bytes, NS::UInteger length, NS::UInteger index);
    void         setBytes(const void* bytes, NS::UInteger length, NS::UInteger stride, NS::UInteger index);

    void         setComputePipelineState(const MTL::ComputePipelineState* state);

    void         setImageblockWidth(NS::UInteger width, NS::UInteger height);

    void         setIntersectionFunctionTable(const MTL::IntersectionFunctionTable* intersectionFunctionTable, NS::UInteger bufferIndex);
    void         setIntersectionFunctionTables(const MTL::IntersectionFunctionTable* const intersectionFunctionTables[], NS::Range range);

    void         setSamplerState(const MTL::SamplerState* sampler, NS::UInteger index);
    void         setSamplerState(const MTL::SamplerState* sampler, float lodMinClamp, float lodMaxClamp, NS::UInteger index);
    void         setSamplerStates(const MTL::SamplerState* const samplers[], NS::Range range);
    void         setSamplerStates(const MTL::SamplerState* const samplers[], const float lodMinClamps[], const float lodMaxClamps[], NS::Range range);

    void         setStageInRegion(MTL::Region region);
    void         setStageInRegion(const MTL::Buffer* indirectBuffer, NS::UInteger indirectBufferOffset);

    void         setTexture(const MTL::Texture* texture, NS::UInteger index);
    void         setTextures(const MTL::Texture* const textures[], NS::Range range);

    void         setThreadgroupMemoryLength(NS::UInteger length, NS::UInteger index);

    void         setVisibleFunctionTable(const MTL::VisibleFunctionTable* visibleFunctionTable, NS::UInteger bufferIndex);
    void         setVisibleFunctionTables(const MTL::VisibleFunctionTable* const visibleFunctionTables[], NS::Range range);

    void         updateFence(const MTL::Fence* fence);

    void         useHeap(const MTL::Heap* heap);
    void         useHeaps(const MTL::Heap* const heaps[], NS::UInteger count);

    void         useResource(const MTL::Resource* resource, MTL::ResourceUsage usage);
    void         useResources(const MTL::Resource* const resources[], NS::UInteger count, MTL::ResourceUsage usage);

    void         waitForFence(const MTL::Fence* fence);
};

}

_MTL_INLINE void MTL::ComputeCommandEncoder::dispatchThreadgroups(MTL::Size threadgroupsPerGrid, MTL::Size threadsPerThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(dispatchThreadgroups_threadsPerThreadgroup_), threadgroupsPerGrid, threadsPerThreadgroup);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::dispatchThreadgroups(const MTL::Buffer* indirectBuffer, NS::UInteger indirectBufferOffset, MTL::Size threadsPerThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(dispatchThreadgroupsWithIndirectBuffer_indirectBufferOffset_threadsPerThreadgroup_), indirectBuffer, indirectBufferOffset, threadsPerThreadgroup);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::dispatchThreads(MTL::Size threadsPerGrid, MTL::Size threadsPerThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(dispatchThreads_threadsPerThreadgroup_), threadsPerGrid, threadsPerThreadgroup);
}

_MTL_INLINE MTL::DispatchType MTL::ComputeCommandEncoder::dispatchType() const
{
    return Object::sendMessage<MTL::DispatchType>(this, _MTL_PRIVATE_SEL(dispatchType));
}

_MTL_INLINE void MTL::ComputeCommandEncoder::executeCommandsInBuffer(const MTL::IndirectCommandBuffer* indirectCommandBuffer, NS::Range executionRange)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(executeCommandsInBuffer_withRange_), indirectCommandBuffer, executionRange);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::executeCommandsInBuffer(const MTL::IndirectCommandBuffer* indirectCommandbuffer, const MTL::Buffer* indirectRangeBuffer, NS::UInteger indirectBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(executeCommandsInBuffer_indirectBuffer_indirectBufferOffset_), indirectCommandbuffer, indirectRangeBuffer, indirectBufferOffset);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::memoryBarrier(MTL::BarrierScope scope)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(memoryBarrierWithScope_), scope);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::memoryBarrier(const MTL::Resource* const resources[], NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(memoryBarrierWithResources_count_), resources, count);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::sampleCountersInBuffer(const MTL::CounterSampleBuffer* sampleBuffer, NS::UInteger sampleIndex, bool barrier)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(sampleCountersInBuffer_atSampleIndex_withBarrier_), sampleBuffer, sampleIndex, barrier);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setAccelerationStructure(const MTL::AccelerationStructure* accelerationStructure, NS::UInteger bufferIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setAccelerationStructure_atBufferIndex_), accelerationStructure, bufferIndex);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBuffer_offset_atIndex_), buffer, offset, index);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger stride, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBuffer_offset_attributeStride_atIndex_), buffer, offset, stride, index);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setBufferOffset(NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBufferOffset_atIndex_), offset, index);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setBufferOffset(NS::UInteger offset, NS::UInteger stride, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBufferOffset_attributeStride_atIndex_), offset, stride, index);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setBuffers(const MTL::Buffer* const buffers[], const NS::UInteger offsets[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBuffers_offsets_withRange_), buffers, offsets, range);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setBuffers(const MTL::Buffer* const buffers[], const NS::UInteger* offsets, const NS::UInteger* strides, NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBuffers_offsets_attributeStrides_withRange_), buffers, offsets, strides, range);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setBytes(const void* bytes, NS::UInteger length, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBytes_length_atIndex_), bytes, length, index);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setBytes(const void* bytes, NS::UInteger length, NS::UInteger stride, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBytes_length_attributeStride_atIndex_), bytes, length, stride, index);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setComputePipelineState(const MTL::ComputePipelineState* state)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setComputePipelineState_), state);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setImageblockWidth(NS::UInteger width, NS::UInteger height)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setImageblockWidth_height_), width, height);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setIntersectionFunctionTable(const MTL::IntersectionFunctionTable* intersectionFunctionTable, NS::UInteger bufferIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIntersectionFunctionTable_atBufferIndex_), intersectionFunctionTable, bufferIndex);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setIntersectionFunctionTables(const MTL::IntersectionFunctionTable* const intersectionFunctionTables[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIntersectionFunctionTables_withBufferRange_), intersectionFunctionTables, range);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setSamplerState(const MTL::SamplerState* sampler, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSamplerState_atIndex_), sampler, index);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setSamplerState(const MTL::SamplerState* sampler, float lodMinClamp, float lodMaxClamp, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSamplerState_lodMinClamp_lodMaxClamp_atIndex_), sampler, lodMinClamp, lodMaxClamp, index);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setSamplerStates(const MTL::SamplerState* const samplers[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSamplerStates_withRange_), samplers, range);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setSamplerStates(const MTL::SamplerState* const samplers[], const float lodMinClamps[], const float lodMaxClamps[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSamplerStates_lodMinClamps_lodMaxClamps_withRange_), samplers, lodMinClamps, lodMaxClamps, range);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setStageInRegion(MTL::Region region)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStageInRegion_), region);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setStageInRegion(const MTL::Buffer* indirectBuffer, NS::UInteger indirectBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStageInRegionWithIndirectBuffer_indirectBufferOffset_), indirectBuffer, indirectBufferOffset);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setTexture(const MTL::Texture* texture, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTexture_atIndex_), texture, index);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setTextures(const MTL::Texture* const textures[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTextures_withRange_), textures, range);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setThreadgroupMemoryLength(NS::UInteger length, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setThreadgroupMemoryLength_atIndex_), length, index);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setVisibleFunctionTable(const MTL::VisibleFunctionTable* visibleFunctionTable, NS::UInteger bufferIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVisibleFunctionTable_atBufferIndex_), visibleFunctionTable, bufferIndex);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::setVisibleFunctionTables(const MTL::VisibleFunctionTable* const visibleFunctionTables[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVisibleFunctionTables_withBufferRange_), visibleFunctionTables, range);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::updateFence(const MTL::Fence* fence)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(updateFence_), fence);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::useHeap(const MTL::Heap* heap)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useHeap_), heap);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::useHeaps(const MTL::Heap* const heaps[], NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useHeaps_count_), heaps, count);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::useResource(const MTL::Resource* resource, MTL::ResourceUsage usage)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useResource_usage_), resource, usage);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::useResources(const MTL::Resource* const resources[], NS::UInteger count, MTL::ResourceUsage usage)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useResources_count_usage_), resources, count, usage);
}

_MTL_INLINE void MTL::ComputeCommandEncoder::waitForFence(const MTL::Fence* fence)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(waitForFence_), fence);
}

#pragma once

namespace MTL
{
class ComputePassDescriptor;
class ComputePassSampleBufferAttachmentDescriptor;
class ComputePassSampleBufferAttachmentDescriptorArray;
class CounterSampleBuffer;

class ComputePassSampleBufferAttachmentDescriptor : public NS::Copying<ComputePassSampleBufferAttachmentDescriptor>
{
public:
    static ComputePassSampleBufferAttachmentDescriptor* alloc();

    NS::UInteger                                        endOfEncoderSampleIndex() const;

    ComputePassSampleBufferAttachmentDescriptor*        init();

    CounterSampleBuffer*                                sampleBuffer() const;

    void                                                setEndOfEncoderSampleIndex(NS::UInteger endOfEncoderSampleIndex);

    void                                                setSampleBuffer(const MTL::CounterSampleBuffer* sampleBuffer);

    void                                                setStartOfEncoderSampleIndex(NS::UInteger startOfEncoderSampleIndex);
    NS::UInteger                                        startOfEncoderSampleIndex() const;
};
class ComputePassSampleBufferAttachmentDescriptorArray : public NS::Referencing<ComputePassSampleBufferAttachmentDescriptorArray>
{
public:
    static ComputePassSampleBufferAttachmentDescriptorArray* alloc();

    ComputePassSampleBufferAttachmentDescriptorArray*        init();

    ComputePassSampleBufferAttachmentDescriptor*             object(NS::UInteger attachmentIndex);
    void                                                     setObject(const MTL::ComputePassSampleBufferAttachmentDescriptor* attachment, NS::UInteger attachmentIndex);
};
class ComputePassDescriptor : public NS::Copying<ComputePassDescriptor>
{
public:
    static ComputePassDescriptor*                     alloc();

    static ComputePassDescriptor*                     computePassDescriptor();

    DispatchType                                      dispatchType() const;

    ComputePassDescriptor*                            init();

    ComputePassSampleBufferAttachmentDescriptorArray* sampleBufferAttachments() const;

    void                                              setDispatchType(MTL::DispatchType dispatchType);
};

}
_MTL_INLINE MTL::ComputePassSampleBufferAttachmentDescriptor* MTL::ComputePassSampleBufferAttachmentDescriptor::alloc()
{
    return NS::Object::alloc<MTL::ComputePassSampleBufferAttachmentDescriptor>(_MTL_PRIVATE_CLS(MTLComputePassSampleBufferAttachmentDescriptor));
}

_MTL_INLINE NS::UInteger MTL::ComputePassSampleBufferAttachmentDescriptor::endOfEncoderSampleIndex() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(endOfEncoderSampleIndex));
}

_MTL_INLINE MTL::ComputePassSampleBufferAttachmentDescriptor* MTL::ComputePassSampleBufferAttachmentDescriptor::init()
{
    return NS::Object::init<MTL::ComputePassSampleBufferAttachmentDescriptor>();
}

_MTL_INLINE MTL::CounterSampleBuffer* MTL::ComputePassSampleBufferAttachmentDescriptor::sampleBuffer() const
{
    return Object::sendMessage<MTL::CounterSampleBuffer*>(this, _MTL_PRIVATE_SEL(sampleBuffer));
}

_MTL_INLINE void MTL::ComputePassSampleBufferAttachmentDescriptor::setEndOfEncoderSampleIndex(NS::UInteger endOfEncoderSampleIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setEndOfEncoderSampleIndex_), endOfEncoderSampleIndex);
}

_MTL_INLINE void MTL::ComputePassSampleBufferAttachmentDescriptor::setSampleBuffer(const MTL::CounterSampleBuffer* sampleBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSampleBuffer_), sampleBuffer);
}

_MTL_INLINE void MTL::ComputePassSampleBufferAttachmentDescriptor::setStartOfEncoderSampleIndex(NS::UInteger startOfEncoderSampleIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStartOfEncoderSampleIndex_), startOfEncoderSampleIndex);
}

_MTL_INLINE NS::UInteger MTL::ComputePassSampleBufferAttachmentDescriptor::startOfEncoderSampleIndex() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(startOfEncoderSampleIndex));
}

_MTL_INLINE MTL::ComputePassSampleBufferAttachmentDescriptorArray* MTL::ComputePassSampleBufferAttachmentDescriptorArray::alloc()
{
    return NS::Object::alloc<MTL::ComputePassSampleBufferAttachmentDescriptorArray>(_MTL_PRIVATE_CLS(MTLComputePassSampleBufferAttachmentDescriptorArray));
}

_MTL_INLINE MTL::ComputePassSampleBufferAttachmentDescriptorArray* MTL::ComputePassSampleBufferAttachmentDescriptorArray::init()
{
    return NS::Object::init<MTL::ComputePassSampleBufferAttachmentDescriptorArray>();
}

_MTL_INLINE MTL::ComputePassSampleBufferAttachmentDescriptor* MTL::ComputePassSampleBufferAttachmentDescriptorArray::object(NS::UInteger attachmentIndex)
{
    return Object::sendMessage<MTL::ComputePassSampleBufferAttachmentDescriptor*>(this, _MTL_PRIVATE_SEL(objectAtIndexedSubscript_), attachmentIndex);
}

_MTL_INLINE void MTL::ComputePassSampleBufferAttachmentDescriptorArray::setObject(const MTL::ComputePassSampleBufferAttachmentDescriptor* attachment, NS::UInteger attachmentIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObject_atIndexedSubscript_), attachment, attachmentIndex);
}

_MTL_INLINE MTL::ComputePassDescriptor* MTL::ComputePassDescriptor::alloc()
{
    return NS::Object::alloc<MTL::ComputePassDescriptor>(_MTL_PRIVATE_CLS(MTLComputePassDescriptor));
}

_MTL_INLINE MTL::ComputePassDescriptor* MTL::ComputePassDescriptor::computePassDescriptor()
{
    return Object::sendMessage<MTL::ComputePassDescriptor*>(_MTL_PRIVATE_CLS(MTLComputePassDescriptor), _MTL_PRIVATE_SEL(computePassDescriptor));
}

_MTL_INLINE MTL::DispatchType MTL::ComputePassDescriptor::dispatchType() const
{
    return Object::sendMessage<MTL::DispatchType>(this, _MTL_PRIVATE_SEL(dispatchType));
}

_MTL_INLINE MTL::ComputePassDescriptor* MTL::ComputePassDescriptor::init()
{
    return NS::Object::init<MTL::ComputePassDescriptor>();
}

_MTL_INLINE MTL::ComputePassSampleBufferAttachmentDescriptorArray* MTL::ComputePassDescriptor::sampleBufferAttachments() const
{
    return Object::sendMessage<MTL::ComputePassSampleBufferAttachmentDescriptorArray*>(this, _MTL_PRIVATE_SEL(sampleBufferAttachments));
}

_MTL_INLINE void MTL::ComputePassDescriptor::setDispatchType(MTL::DispatchType dispatchType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDispatchType_), dispatchType);
}

#pragma once

#pragma once

namespace MTL
{
class PipelineBufferDescriptor;
class PipelineBufferDescriptorArray;
_MTL_ENUM(NS::UInteger, Mutability) {
    MutabilityDefault = 0,
    MutabilityMutable = 1,
    MutabilityImmutable = 2,
};

_MTL_ENUM(NS::Integer, ShaderValidation) {
    ShaderValidationDefault = 0,
    ShaderValidationEnabled = 1,
    ShaderValidationDisabled = 2,
};

class PipelineBufferDescriptor : public NS::Copying<PipelineBufferDescriptor>
{
public:
    static PipelineBufferDescriptor* alloc();

    PipelineBufferDescriptor*        init();

    Mutability                       mutability() const;
    void                             setMutability(MTL::Mutability mutability);
};
class PipelineBufferDescriptorArray : public NS::Referencing<PipelineBufferDescriptorArray>
{
public:
    static PipelineBufferDescriptorArray* alloc();

    PipelineBufferDescriptorArray*        init();

    PipelineBufferDescriptor*             object(NS::UInteger bufferIndex);
    void                                  setObject(const MTL::PipelineBufferDescriptor* buffer, NS::UInteger bufferIndex);
};

}
_MTL_INLINE MTL::PipelineBufferDescriptor* MTL::PipelineBufferDescriptor::alloc()
{
    return NS::Object::alloc<MTL::PipelineBufferDescriptor>(_MTL_PRIVATE_CLS(MTLPipelineBufferDescriptor));
}

_MTL_INLINE MTL::PipelineBufferDescriptor* MTL::PipelineBufferDescriptor::init()
{
    return NS::Object::init<MTL::PipelineBufferDescriptor>();
}

_MTL_INLINE MTL::Mutability MTL::PipelineBufferDescriptor::mutability() const
{
    return Object::sendMessage<MTL::Mutability>(this, _MTL_PRIVATE_SEL(mutability));
}

_MTL_INLINE void MTL::PipelineBufferDescriptor::setMutability(MTL::Mutability mutability)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMutability_), mutability);
}

_MTL_INLINE MTL::PipelineBufferDescriptorArray* MTL::PipelineBufferDescriptorArray::alloc()
{
    return NS::Object::alloc<MTL::PipelineBufferDescriptorArray>(_MTL_PRIVATE_CLS(MTLPipelineBufferDescriptorArray));
}

_MTL_INLINE MTL::PipelineBufferDescriptorArray* MTL::PipelineBufferDescriptorArray::init()
{
    return NS::Object::init<MTL::PipelineBufferDescriptorArray>();
}

_MTL_INLINE MTL::PipelineBufferDescriptor* MTL::PipelineBufferDescriptorArray::object(NS::UInteger bufferIndex)
{
    return Object::sendMessage<MTL::PipelineBufferDescriptor*>(this, _MTL_PRIVATE_SEL(objectAtIndexedSubscript_), bufferIndex);
}

_MTL_INLINE void MTL::PipelineBufferDescriptorArray::setObject(const MTL::PipelineBufferDescriptor* buffer, NS::UInteger bufferIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObject_atIndexedSubscript_), buffer, bufferIndex);
}

namespace MTL
{
class ComputePipelineDescriptor;
class ComputePipelineReflection;
class ComputePipelineState;
class Device;
class Function;
class FunctionHandle;
class IntersectionFunctionTable;
class IntersectionFunctionTableDescriptor;
class LinkedFunctions;
class PipelineBufferDescriptorArray;
class StageInputOutputDescriptor;
class VisibleFunctionTable;
class VisibleFunctionTableDescriptor;

}
namespace MTL4
{
class BinaryFunction;

}
namespace MTL
{
class ComputePipelineReflection : public NS::Referencing<ComputePipelineReflection>
{
public:
    static ComputePipelineReflection* alloc();

    NS::Array*                        arguments() const;

    NS::Array*                        bindings() const;

    ComputePipelineReflection*        init();
};
class ComputePipelineDescriptor : public NS::Copying<ComputePipelineDescriptor>
{
public:
    static ComputePipelineDescriptor* alloc();

    NS::Array*                        binaryArchives() const;

    PipelineBufferDescriptorArray*    buffers() const;

    Function*                         computeFunction() const;

    ComputePipelineDescriptor*        init();

    NS::Array*                        insertLibraries() const;

    NS::String*                       label() const;

    LinkedFunctions*                  linkedFunctions() const;

    NS::UInteger                      maxCallStackDepth() const;

    NS::UInteger                      maxTotalThreadsPerThreadgroup() const;

    NS::Array*                        preloadedLibraries() const;

    Size                              requiredThreadsPerThreadgroup() const;

    void                              reset();

    void                              setBinaryArchives(const NS::Array* binaryArchives);

    void                              setComputeFunction(const MTL::Function* computeFunction);

    void                              setInsertLibraries(const NS::Array* insertLibraries);

    void                              setLabel(const NS::String* label);

    void                              setLinkedFunctions(const MTL::LinkedFunctions* linkedFunctions);

    void                              setMaxCallStackDepth(NS::UInteger maxCallStackDepth);

    void                              setMaxTotalThreadsPerThreadgroup(NS::UInteger maxTotalThreadsPerThreadgroup);

    void                              setPreloadedLibraries(const NS::Array* preloadedLibraries);

    void                              setRequiredThreadsPerThreadgroup(MTL::Size requiredThreadsPerThreadgroup);

    void                              setShaderValidation(MTL::ShaderValidation shaderValidation);

    void                              setStageInputDescriptor(const MTL::StageInputOutputDescriptor* stageInputDescriptor);

    void                              setSupportAddingBinaryFunctions(bool supportAddingBinaryFunctions);

    void                              setSupportIndirectCommandBuffers(bool supportIndirectCommandBuffers);

    void                              setThreadGroupSizeIsMultipleOfThreadExecutionWidth(bool threadGroupSizeIsMultipleOfThreadExecutionWidth);

    ShaderValidation                  shaderValidation() const;

    StageInputOutputDescriptor*       stageInputDescriptor() const;

    bool                              supportAddingBinaryFunctions() const;

    bool                              supportIndirectCommandBuffers() const;

    bool                              threadGroupSizeIsMultipleOfThreadExecutionWidth() const;
};
class ComputePipelineState : public NS::Referencing<ComputePipelineState, Allocation>
{
public:
    Device*                    device() const;

    FunctionHandle*            functionHandle(const NS::String* name);
    FunctionHandle*            functionHandle(const MTL4::BinaryFunction* function);
    FunctionHandle*            functionHandle(const MTL::Function* function);

    ResourceID                 gpuResourceID() const;

    NS::UInteger               imageblockMemoryLength(MTL::Size imageblockDimensions);

    NS::String*                label() const;

    NS::UInteger               maxTotalThreadsPerThreadgroup() const;

    ComputePipelineState*      newComputePipelineStateWithBinaryFunctions(const NS::Array* additionalBinaryFunctions, NS::Error** error);
    ComputePipelineState*      newComputePipelineState(const NS::Array* functions, NS::Error** error);

    IntersectionFunctionTable* newIntersectionFunctionTable(const MTL::IntersectionFunctionTableDescriptor* descriptor);

    VisibleFunctionTable*      newVisibleFunctionTable(const MTL::VisibleFunctionTableDescriptor* descriptor);

    ComputePipelineReflection* reflection() const;

    Size                       requiredThreadsPerThreadgroup() const;

    ShaderValidation           shaderValidation() const;

    NS::UInteger               staticThreadgroupMemoryLength() const;

    bool                       supportIndirectCommandBuffers() const;

    NS::UInteger               threadExecutionWidth() const;
};

}
_MTL_INLINE MTL::ComputePipelineReflection* MTL::ComputePipelineReflection::alloc()
{
    return NS::Object::alloc<MTL::ComputePipelineReflection>(_MTL_PRIVATE_CLS(MTLComputePipelineReflection));
}

_MTL_INLINE NS::Array* MTL::ComputePipelineReflection::arguments() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(arguments));
}

_MTL_INLINE NS::Array* MTL::ComputePipelineReflection::bindings() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(bindings));
}

_MTL_INLINE MTL::ComputePipelineReflection* MTL::ComputePipelineReflection::init()
{
    return NS::Object::init<MTL::ComputePipelineReflection>();
}

_MTL_INLINE MTL::ComputePipelineDescriptor* MTL::ComputePipelineDescriptor::alloc()
{
    return NS::Object::alloc<MTL::ComputePipelineDescriptor>(_MTL_PRIVATE_CLS(MTLComputePipelineDescriptor));
}

_MTL_INLINE NS::Array* MTL::ComputePipelineDescriptor::binaryArchives() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(binaryArchives));
}

_MTL_INLINE MTL::PipelineBufferDescriptorArray* MTL::ComputePipelineDescriptor::buffers() const
{
    return Object::sendMessage<MTL::PipelineBufferDescriptorArray*>(this, _MTL_PRIVATE_SEL(buffers));
}

_MTL_INLINE MTL::Function* MTL::ComputePipelineDescriptor::computeFunction() const
{
    return Object::sendMessage<MTL::Function*>(this, _MTL_PRIVATE_SEL(computeFunction));
}

_MTL_INLINE MTL::ComputePipelineDescriptor* MTL::ComputePipelineDescriptor::init()
{
    return NS::Object::init<MTL::ComputePipelineDescriptor>();
}

_MTL_INLINE NS::Array* MTL::ComputePipelineDescriptor::insertLibraries() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(insertLibraries));
}

_MTL_INLINE NS::String* MTL::ComputePipelineDescriptor::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE MTL::LinkedFunctions* MTL::ComputePipelineDescriptor::linkedFunctions() const
{
    return Object::sendMessage<MTL::LinkedFunctions*>(this, _MTL_PRIVATE_SEL(linkedFunctions));
}

_MTL_INLINE NS::UInteger MTL::ComputePipelineDescriptor::maxCallStackDepth() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxCallStackDepth));
}

_MTL_INLINE NS::UInteger MTL::ComputePipelineDescriptor::maxTotalThreadsPerThreadgroup() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxTotalThreadsPerThreadgroup));
}

_MTL_INLINE NS::Array* MTL::ComputePipelineDescriptor::preloadedLibraries() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(preloadedLibraries));
}

_MTL_INLINE MTL::Size MTL::ComputePipelineDescriptor::requiredThreadsPerThreadgroup() const
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(requiredThreadsPerThreadgroup));
}

_MTL_INLINE void MTL::ComputePipelineDescriptor::reset()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(reset));
}

_MTL_INLINE void MTL::ComputePipelineDescriptor::setBinaryArchives(const NS::Array* binaryArchives)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBinaryArchives_), binaryArchives);
}

_MTL_INLINE void MTL::ComputePipelineDescriptor::setComputeFunction(const MTL::Function* computeFunction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setComputeFunction_), computeFunction);
}

_MTL_INLINE void MTL::ComputePipelineDescriptor::setInsertLibraries(const NS::Array* insertLibraries)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInsertLibraries_), insertLibraries);
}

_MTL_INLINE void MTL::ComputePipelineDescriptor::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE void MTL::ComputePipelineDescriptor::setLinkedFunctions(const MTL::LinkedFunctions* linkedFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLinkedFunctions_), linkedFunctions);
}

_MTL_INLINE void MTL::ComputePipelineDescriptor::setMaxCallStackDepth(NS::UInteger maxCallStackDepth)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxCallStackDepth_), maxCallStackDepth);
}

_MTL_INLINE void MTL::ComputePipelineDescriptor::setMaxTotalThreadsPerThreadgroup(NS::UInteger maxTotalThreadsPerThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxTotalThreadsPerThreadgroup_), maxTotalThreadsPerThreadgroup);
}

_MTL_INLINE void MTL::ComputePipelineDescriptor::setPreloadedLibraries(const NS::Array* preloadedLibraries)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPreloadedLibraries_), preloadedLibraries);
}

_MTL_INLINE void MTL::ComputePipelineDescriptor::setRequiredThreadsPerThreadgroup(MTL::Size requiredThreadsPerThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRequiredThreadsPerThreadgroup_), requiredThreadsPerThreadgroup);
}

_MTL_INLINE void MTL::ComputePipelineDescriptor::setShaderValidation(MTL::ShaderValidation shaderValidation)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setShaderValidation_), shaderValidation);
}

_MTL_INLINE void MTL::ComputePipelineDescriptor::setStageInputDescriptor(const MTL::StageInputOutputDescriptor* stageInputDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStageInputDescriptor_), stageInputDescriptor);
}

_MTL_INLINE void MTL::ComputePipelineDescriptor::setSupportAddingBinaryFunctions(bool supportAddingBinaryFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportAddingBinaryFunctions_), supportAddingBinaryFunctions);
}

_MTL_INLINE void MTL::ComputePipelineDescriptor::setSupportIndirectCommandBuffers(bool supportIndirectCommandBuffers)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportIndirectCommandBuffers_), supportIndirectCommandBuffers);
}

_MTL_INLINE void MTL::ComputePipelineDescriptor::setThreadGroupSizeIsMultipleOfThreadExecutionWidth(bool threadGroupSizeIsMultipleOfThreadExecutionWidth)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setThreadGroupSizeIsMultipleOfThreadExecutionWidth_), threadGroupSizeIsMultipleOfThreadExecutionWidth);
}

_MTL_INLINE MTL::ShaderValidation MTL::ComputePipelineDescriptor::shaderValidation() const
{
    return Object::sendMessage<MTL::ShaderValidation>(this, _MTL_PRIVATE_SEL(shaderValidation));
}

_MTL_INLINE MTL::StageInputOutputDescriptor* MTL::ComputePipelineDescriptor::stageInputDescriptor() const
{
    return Object::sendMessage<MTL::StageInputOutputDescriptor*>(this, _MTL_PRIVATE_SEL(stageInputDescriptor));
}

_MTL_INLINE bool MTL::ComputePipelineDescriptor::supportAddingBinaryFunctions() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportAddingBinaryFunctions));
}

_MTL_INLINE bool MTL::ComputePipelineDescriptor::supportIndirectCommandBuffers() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportIndirectCommandBuffers));
}

_MTL_INLINE bool MTL::ComputePipelineDescriptor::threadGroupSizeIsMultipleOfThreadExecutionWidth() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(threadGroupSizeIsMultipleOfThreadExecutionWidth));
}

_MTL_INLINE MTL::Device* MTL::ComputePipelineState::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE MTL::FunctionHandle* MTL::ComputePipelineState::functionHandle(const NS::String* name)
{
    return Object::sendMessage<MTL::FunctionHandle*>(this, _MTL_PRIVATE_SEL(functionHandleWithName_), name);
}

_MTL_INLINE MTL::FunctionHandle* MTL::ComputePipelineState::functionHandle(const MTL4::BinaryFunction* function)
{
    return Object::sendMessage<MTL::FunctionHandle*>(this, _MTL_PRIVATE_SEL(functionHandleWithBinaryFunction_), function);
}

_MTL_INLINE MTL::FunctionHandle* MTL::ComputePipelineState::functionHandle(const MTL::Function* function)
{
    return Object::sendMessage<MTL::FunctionHandle*>(this, _MTL_PRIVATE_SEL(functionHandleWithFunction_), function);
}

_MTL_INLINE MTL::ResourceID MTL::ComputePipelineState::gpuResourceID() const
{
    return Object::sendMessage<MTL::ResourceID>(this, _MTL_PRIVATE_SEL(gpuResourceID));
}

_MTL_INLINE NS::UInteger MTL::ComputePipelineState::imageblockMemoryLength(MTL::Size imageblockDimensions)
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(imageblockMemoryLengthForDimensions_), imageblockDimensions);
}

_MTL_INLINE NS::String* MTL::ComputePipelineState::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE NS::UInteger MTL::ComputePipelineState::maxTotalThreadsPerThreadgroup() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxTotalThreadsPerThreadgroup));
}

_MTL_INLINE MTL::ComputePipelineState* MTL::ComputePipelineState::newComputePipelineStateWithBinaryFunctions(const NS::Array* additionalBinaryFunctions, NS::Error** error)
{
    return Object::sendMessage<MTL::ComputePipelineState*>(this, _MTL_PRIVATE_SEL(newComputePipelineStateWithBinaryFunctions_error_), additionalBinaryFunctions, error);
}

_MTL_INLINE MTL::ComputePipelineState* MTL::ComputePipelineState::newComputePipelineState(const NS::Array* functions, NS::Error** error)
{
    return Object::sendMessage<MTL::ComputePipelineState*>(this, _MTL_PRIVATE_SEL(newComputePipelineStateWithAdditionalBinaryFunctions_error_), functions, error);
}

_MTL_INLINE MTL::IntersectionFunctionTable* MTL::ComputePipelineState::newIntersectionFunctionTable(const MTL::IntersectionFunctionTableDescriptor* descriptor)
{
    return Object::sendMessage<MTL::IntersectionFunctionTable*>(this, _MTL_PRIVATE_SEL(newIntersectionFunctionTableWithDescriptor_), descriptor);
}

_MTL_INLINE MTL::VisibleFunctionTable* MTL::ComputePipelineState::newVisibleFunctionTable(const MTL::VisibleFunctionTableDescriptor* descriptor)
{
    return Object::sendMessage<MTL::VisibleFunctionTable*>(this, _MTL_PRIVATE_SEL(newVisibleFunctionTableWithDescriptor_), descriptor);
}

_MTL_INLINE MTL::ComputePipelineReflection* MTL::ComputePipelineState::reflection() const
{
    return Object::sendMessage<MTL::ComputePipelineReflection*>(this, _MTL_PRIVATE_SEL(reflection));
}

_MTL_INLINE MTL::Size MTL::ComputePipelineState::requiredThreadsPerThreadgroup() const
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(requiredThreadsPerThreadgroup));
}

_MTL_INLINE MTL::ShaderValidation MTL::ComputePipelineState::shaderValidation() const
{
    return Object::sendMessage<MTL::ShaderValidation>(this, _MTL_PRIVATE_SEL(shaderValidation));
}

_MTL_INLINE NS::UInteger MTL::ComputePipelineState::staticThreadgroupMemoryLength() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(staticThreadgroupMemoryLength));
}

_MTL_INLINE bool MTL::ComputePipelineState::supportIndirectCommandBuffers() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportIndirectCommandBuffers));
}

_MTL_INLINE NS::UInteger MTL::ComputePipelineState::threadExecutionWidth() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(threadExecutionWidth));
}

#pragma once

#include <cstdint>

namespace MTL
{
class CounterSampleBufferDescriptor;
class CounterSet;
class Device;
_MTL_ENUM(NS::Integer, CounterSampleBufferError) {
    CounterSampleBufferErrorOutOfMemory = 0,
    CounterSampleBufferErrorInvalid = 1,
    CounterSampleBufferErrorInternal = 2,
};

using CommonCounter = NS::String*;
using CommonCounterSet = NS::String*;

static const NS::UInteger CounterErrorValue = static_cast<NS::UInteger>(~0ULL);
static const NS::UInteger CounterDontSample = static_cast<NS::UInteger>(-1);
_MTL_CONST(NS::ErrorDomain, CounterErrorDomain);
_MTL_CONST(CommonCounter, CommonCounterTimestamp);
_MTL_CONST(CommonCounter, CommonCounterTessellationInputPatches);
_MTL_CONST(CommonCounter, CommonCounterVertexInvocations);
_MTL_CONST(CommonCounter, CommonCounterPostTessellationVertexInvocations);
_MTL_CONST(CommonCounter, CommonCounterClipperInvocations);
_MTL_CONST(CommonCounter, CommonCounterClipperPrimitivesOut);
_MTL_CONST(CommonCounter, CommonCounterFragmentInvocations);
_MTL_CONST(CommonCounter, CommonCounterFragmentsPassed);
_MTL_CONST(CommonCounter, CommonCounterComputeKernelInvocations);
_MTL_CONST(CommonCounter, CommonCounterTotalCycles);
_MTL_CONST(CommonCounter, CommonCounterVertexCycles);
_MTL_CONST(CommonCounter, CommonCounterTessellationCycles);
_MTL_CONST(CommonCounter, CommonCounterPostTessellationVertexCycles);
_MTL_CONST(CommonCounter, CommonCounterFragmentCycles);
_MTL_CONST(CommonCounter, CommonCounterRenderTargetWriteCycles);
_MTL_CONST(CommonCounterSet, CommonCounterSetTimestamp);
_MTL_CONST(CommonCounterSet, CommonCounterSetStageUtilization);
_MTL_CONST(CommonCounterSet, CommonCounterSetStatistic);
struct CounterResultTimestamp
{
    uint64_t timestamp;
} _MTL_PACKED;

struct CounterResultStageUtilization
{
    uint64_t totalCycles;
    uint64_t vertexCycles;
    uint64_t tessellationCycles;
    uint64_t postTessellationVertexCycles;
    uint64_t fragmentCycles;
    uint64_t renderTargetCycles;
} _MTL_PACKED;

struct CounterResultStatistic
{
    uint64_t tessellationInputPatches;
    uint64_t vertexInvocations;
    uint64_t postTessellationVertexInvocations;
    uint64_t clipperInvocations;
    uint64_t clipperPrimitivesOut;
    uint64_t fragmentInvocations;
    uint64_t fragmentsPassed;
    uint64_t computeKernelInvocations;
} _MTL_PACKED;

class Counter : public NS::Referencing<Counter>
{
public:
    NS::String* name() const;
};
class CounterSet : public NS::Referencing<CounterSet>
{
public:
    NS::Array*  counters() const;

    NS::String* name() const;
};
class CounterSampleBufferDescriptor : public NS::Copying<CounterSampleBufferDescriptor>
{
public:
    static CounterSampleBufferDescriptor* alloc();

    CounterSet*                           counterSet() const;

    CounterSampleBufferDescriptor*        init();

    NS::String*                           label() const;

    NS::UInteger                          sampleCount() const;

    void                                  setCounterSet(const MTL::CounterSet* counterSet);

    void                                  setLabel(const NS::String* label);

    void                                  setSampleCount(NS::UInteger sampleCount);

    void                                  setStorageMode(MTL::StorageMode storageMode);
    StorageMode                           storageMode() const;
};
class CounterSampleBuffer : public NS::Referencing<CounterSampleBuffer>
{
public:
    Device*      device() const;

    NS::String*  label() const;

    NS::Data*    resolveCounterRange(NS::Range range);

    NS::UInteger sampleCount() const;
};

}

_MTL_PRIVATE_DEF_CONST(NS::ErrorDomain, CounterErrorDomain);
_MTL_PRIVATE_DEF_CONST(MTL::CommonCounter, CommonCounterTimestamp);
_MTL_PRIVATE_DEF_CONST(MTL::CommonCounter, CommonCounterTessellationInputPatches);
_MTL_PRIVATE_DEF_CONST(MTL::CommonCounter, CommonCounterVertexInvocations);
_MTL_PRIVATE_DEF_CONST(MTL::CommonCounter, CommonCounterPostTessellationVertexInvocations);
_MTL_PRIVATE_DEF_CONST(MTL::CommonCounter, CommonCounterClipperInvocations);
_MTL_PRIVATE_DEF_CONST(MTL::CommonCounter, CommonCounterClipperPrimitivesOut);
_MTL_PRIVATE_DEF_CONST(MTL::CommonCounter, CommonCounterFragmentInvocations);
_MTL_PRIVATE_DEF_CONST(MTL::CommonCounter, CommonCounterFragmentsPassed);
_MTL_PRIVATE_DEF_CONST(MTL::CommonCounter, CommonCounterComputeKernelInvocations);
_MTL_PRIVATE_DEF_CONST(MTL::CommonCounter, CommonCounterTotalCycles);
_MTL_PRIVATE_DEF_CONST(MTL::CommonCounter, CommonCounterVertexCycles);
_MTL_PRIVATE_DEF_CONST(MTL::CommonCounter, CommonCounterTessellationCycles);
_MTL_PRIVATE_DEF_CONST(MTL::CommonCounter, CommonCounterPostTessellationVertexCycles);
_MTL_PRIVATE_DEF_CONST(MTL::CommonCounter, CommonCounterFragmentCycles);
_MTL_PRIVATE_DEF_CONST(MTL::CommonCounter, CommonCounterRenderTargetWriteCycles);
_MTL_PRIVATE_DEF_CONST(MTL::CommonCounterSet, CommonCounterSetTimestamp);
_MTL_PRIVATE_DEF_CONST(MTL::CommonCounterSet, CommonCounterSetStageUtilization);
_MTL_PRIVATE_DEF_CONST(MTL::CommonCounterSet, CommonCounterSetStatistic);

_MTL_INLINE NS::String* MTL::Counter::name() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(name));
}

_MTL_INLINE NS::Array* MTL::CounterSet::counters() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(counters));
}

_MTL_INLINE NS::String* MTL::CounterSet::name() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(name));
}

_MTL_INLINE MTL::CounterSampleBufferDescriptor* MTL::CounterSampleBufferDescriptor::alloc()
{
    return NS::Object::alloc<MTL::CounterSampleBufferDescriptor>(_MTL_PRIVATE_CLS(MTLCounterSampleBufferDescriptor));
}

_MTL_INLINE MTL::CounterSet* MTL::CounterSampleBufferDescriptor::counterSet() const
{
    return Object::sendMessage<MTL::CounterSet*>(this, _MTL_PRIVATE_SEL(counterSet));
}

_MTL_INLINE MTL::CounterSampleBufferDescriptor* MTL::CounterSampleBufferDescriptor::init()
{
    return NS::Object::init<MTL::CounterSampleBufferDescriptor>();
}

_MTL_INLINE NS::String* MTL::CounterSampleBufferDescriptor::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE NS::UInteger MTL::CounterSampleBufferDescriptor::sampleCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(sampleCount));
}

_MTL_INLINE void MTL::CounterSampleBufferDescriptor::setCounterSet(const MTL::CounterSet* counterSet)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setCounterSet_), counterSet);
}

_MTL_INLINE void MTL::CounterSampleBufferDescriptor::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE void MTL::CounterSampleBufferDescriptor::setSampleCount(NS::UInteger sampleCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSampleCount_), sampleCount);
}

_MTL_INLINE void MTL::CounterSampleBufferDescriptor::setStorageMode(MTL::StorageMode storageMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStorageMode_), storageMode);
}

_MTL_INLINE MTL::StorageMode MTL::CounterSampleBufferDescriptor::storageMode() const
{
    return Object::sendMessage<MTL::StorageMode>(this, _MTL_PRIVATE_SEL(storageMode));
}

_MTL_INLINE MTL::Device* MTL::CounterSampleBuffer::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE NS::String* MTL::CounterSampleBuffer::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE NS::Data* MTL::CounterSampleBuffer::resolveCounterRange(NS::Range range)
{
    return Object::sendMessage<NS::Data*>(this, _MTL_PRIVATE_SEL(resolveCounterRange_), range);
}

_MTL_INLINE NS::UInteger MTL::CounterSampleBuffer::sampleCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(sampleCount));
}

#pragma once

#pragma once

#include <cstdint>

#include <cstdint>

namespace MTL4
{
class CounterHeapDescriptor;
_MTL_ENUM(NS::Integer, CounterHeapType) {
    CounterHeapTypeInvalid,
    CounterHeapTypeTimestamp,
};

_MTL_ENUM(NS::Integer, TimestampGranularity) {
    TimestampGranularityRelaxed = 0,
    TimestampGranularityPrecise = 1,
};

struct TimestampHeapEntry
{
    uint64_t timestamp;
} _MTL_PACKED;

class CounterHeapDescriptor : public NS::Copying<CounterHeapDescriptor>
{
public:
    static CounterHeapDescriptor* alloc();

    NS::UInteger                  count() const;

    CounterHeapDescriptor*        init();

    void                          setCount(NS::UInteger count);

    void                          setType(MTL4::CounterHeapType type);
    CounterHeapType               type() const;
};
class CounterHeap : public NS::Referencing<CounterHeap>
{
public:
    NS::UInteger    count() const;
    void            invalidateCounterRange(NS::Range range);

    NS::String*     label() const;

    NS::Data*       resolveCounterRange(NS::Range range);

    void            setLabel(const NS::String* label);

    CounterHeapType type() const;
};

}

_MTL_INLINE MTL4::CounterHeapDescriptor* MTL4::CounterHeapDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::CounterHeapDescriptor>(_MTL_PRIVATE_CLS(MTL4CounterHeapDescriptor));
}

_MTL_INLINE NS::UInteger MTL4::CounterHeapDescriptor::count() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(count));
}

_MTL_INLINE MTL4::CounterHeapDescriptor* MTL4::CounterHeapDescriptor::init()
{
    return NS::Object::init<MTL4::CounterHeapDescriptor>();
}

_MTL_INLINE void MTL4::CounterHeapDescriptor::setCount(NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setCount_), count);
}

_MTL_INLINE void MTL4::CounterHeapDescriptor::setType(MTL4::CounterHeapType type)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setType_), type);
}

_MTL_INLINE MTL4::CounterHeapType MTL4::CounterHeapDescriptor::type() const
{
    return Object::sendMessage<MTL4::CounterHeapType>(this, _MTL_PRIVATE_SEL(type));
}

_MTL_INLINE NS::UInteger MTL4::CounterHeap::count() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(count));
}

_MTL_INLINE void MTL4::CounterHeap::invalidateCounterRange(NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(invalidateCounterRange_), range);
}

_MTL_INLINE NS::String* MTL4::CounterHeap::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE NS::Data* MTL4::CounterHeap::resolveCounterRange(NS::Range range)
{
    return Object::sendMessage<NS::Data*>(this, _MTL_PRIVATE_SEL(resolveCounterRange_), range);
}

_MTL_INLINE void MTL4::CounterHeap::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE MTL4::CounterHeapType MTL4::CounterHeap::type() const
{
    return Object::sendMessage<MTL4::CounterHeapType>(this, _MTL_PRIVATE_SEL(type));
}

#include <IOSurface/IOSurfaceRef.h>
#include <cstdint>
#include <dispatch/dispatch.h>

#include <TargetConditionals.h>
#include <cstdint>
#include <functional>

namespace MTL
{
class AccelerationStructure;
class AccelerationStructureDescriptor;
class Architecture;
class ArgumentDescriptor;
class ArgumentEncoder;
class BinaryArchive;
class BinaryArchiveDescriptor;
class Buffer;
class BufferBinding;
class CommandQueue;
class CommandQueueDescriptor;
class CompileOptions;
class ComputePipelineDescriptor;
class ComputePipelineReflection;
class ComputePipelineState;
class CounterSampleBuffer;
class CounterSampleBufferDescriptor;
class DepthStencilDescriptor;
class DepthStencilState;
class Device;
class DynamicLibrary;
class Event;
class Fence;
class Function;
class FunctionConstantValues;
class FunctionHandle;
class Heap;
class HeapDescriptor;
class IOCommandQueue;
class IOCommandQueueDescriptor;
class IOFileHandle;
class IndirectCommandBuffer;
class IndirectCommandBufferDescriptor;
class Library;
class LogState;
class LogStateDescriptor;
class MeshRenderPipelineDescriptor;
class RasterizationRateMap;
class RasterizationRateMapDescriptor;
struct Region;
class RenderPipelineDescriptor;
class RenderPipelineReflection;
class RenderPipelineState;
class ResidencySet;
class ResidencySetDescriptor;
class ResourceViewPoolDescriptor;
struct SamplePosition;
class SamplerDescriptor;
class SamplerState;
class SharedEvent;
class SharedEventHandle;
class SharedTextureHandle;
class StitchedLibraryDescriptor;
class Tensor;
class TensorDescriptor;
class Texture;
class TextureDescriptor;
class TextureViewPool;
class TileRenderPipelineDescriptor;

}
namespace MTL4
{
class Archive;
class ArgumentTable;
class ArgumentTableDescriptor;
class BinaryFunction;
class CommandAllocator;
class CommandAllocatorDescriptor;
class CommandBuffer;
class CommandQueue;
class CommandQueueDescriptor;
class Compiler;
class CompilerDescriptor;
class CounterHeap;
class CounterHeapDescriptor;
class PipelineDataSetSerializer;
class PipelineDataSetSerializerDescriptor;

}
namespace MTL
{
_MTL_ENUM(NS::Integer, IOCompressionMethod) {
    IOCompressionMethodZlib = 0,
    IOCompressionMethodLZFSE = 1,
    IOCompressionMethodLZ4 = 2,
    IOCompressionMethodLZMA = 3,
    IOCompressionMethodLZBitmap = 4,
};

_MTL_ENUM(NS::UInteger, FeatureSet) {
    FeatureSet_iOS_GPUFamily1_v1 = 0,
    FeatureSet_iOS_GPUFamily2_v1 = 1,
    FeatureSet_iOS_GPUFamily1_v2 = 2,
    FeatureSet_iOS_GPUFamily2_v2 = 3,
    FeatureSet_iOS_GPUFamily3_v1 = 4,
    FeatureSet_iOS_GPUFamily1_v3 = 5,
    FeatureSet_iOS_GPUFamily2_v3 = 6,
    FeatureSet_iOS_GPUFamily3_v2 = 7,
    FeatureSet_iOS_GPUFamily1_v4 = 8,
    FeatureSet_iOS_GPUFamily2_v4 = 9,
    FeatureSet_iOS_GPUFamily3_v3 = 10,
    FeatureSet_iOS_GPUFamily4_v1 = 11,
    FeatureSet_iOS_GPUFamily1_v5 = 12,
    FeatureSet_iOS_GPUFamily2_v5 = 13,
    FeatureSet_iOS_GPUFamily3_v4 = 14,
    FeatureSet_iOS_GPUFamily4_v2 = 15,
    FeatureSet_iOS_GPUFamily5_v1 = 16,
    FeatureSet_macOS_GPUFamily1_v1 = 10000,
    FeatureSet_OSX_GPUFamily1_v1 = 10000,
    FeatureSet_macOS_GPUFamily1_v2 = 10001,
    FeatureSet_OSX_GPUFamily1_v2 = 10001,
    FeatureSet_macOS_ReadWriteTextureTier2 = 10002,
    FeatureSet_OSX_ReadWriteTextureTier2 = 10002,
    FeatureSet_macOS_GPUFamily1_v3 = 10003,
    FeatureSet_macOS_GPUFamily1_v4 = 10004,
    FeatureSet_macOS_GPUFamily2_v1 = 10005,
    FeatureSet_watchOS_GPUFamily1_v1 = 20000,
    FeatureSet_WatchOS_GPUFamily1_v1 = 20000,
    FeatureSet_watchOS_GPUFamily2_v1 = 20001,
    FeatureSet_WatchOS_GPUFamily2_v1 = 20001,
    FeatureSet_tvOS_GPUFamily1_v1 = 30000,
    FeatureSet_TVOS_GPUFamily1_v1 = 30000,
    FeatureSet_tvOS_GPUFamily1_v2 = 30001,
    FeatureSet_tvOS_GPUFamily1_v3 = 30002,
    FeatureSet_tvOS_GPUFamily2_v1 = 30003,
    FeatureSet_tvOS_GPUFamily1_v4 = 30004,
    FeatureSet_tvOS_GPUFamily2_v2 = 30005,
};

_MTL_ENUM(NS::Integer, GPUFamily) {
    GPUFamilyApple1 = 1001,
    GPUFamilyApple2 = 1002,
    GPUFamilyApple3 = 1003,
    GPUFamilyApple4 = 1004,
    GPUFamilyApple5 = 1005,
    GPUFamilyApple6 = 1006,
    GPUFamilyApple7 = 1007,
    GPUFamilyApple8 = 1008,
    GPUFamilyApple9 = 1009,
    GPUFamilyApple10 = 1010,
    GPUFamilyMac1 = 2001,
    GPUFamilyMac2 = 2002,
    GPUFamilyCommon1 = 3001,
    GPUFamilyCommon2 = 3002,
    GPUFamilyCommon3 = 3003,
    GPUFamilyMacCatalyst1 = 4001,
    GPUFamilyMacCatalyst2 = 4002,
    GPUFamilyMetal3 = 5001,
    GPUFamilyMetal4 = 5002,
};

_MTL_ENUM(NS::UInteger, DeviceLocation) {
    DeviceLocationBuiltIn = 0,
    DeviceLocationSlot = 1,
    DeviceLocationExternal = 2,
    DeviceLocationUnspecified = NS::UIntegerMax,
};

_MTL_ENUM(NS::UInteger, ReadWriteTextureTier) {
    ReadWriteTextureTierNone = 0,
    ReadWriteTextureTier1 = 1,
    ReadWriteTextureTier2 = 2,
};

_MTL_ENUM(NS::UInteger, ArgumentBuffersTier) {
    ArgumentBuffersTier1 = 0,
    ArgumentBuffersTier2 = 1,
};

_MTL_ENUM(NS::UInteger, SparseTextureRegionAlignmentMode) {
    SparseTextureRegionAlignmentModeOutward = 0,
    SparseTextureRegionAlignmentModeInward = 1,
};

_MTL_ENUM(NS::UInteger, CounterSamplingPoint) {
    CounterSamplingPointAtStageBoundary = 0,
    CounterSamplingPointAtDrawBoundary = 1,
    CounterSamplingPointAtDispatchBoundary = 2,
    CounterSamplingPointAtTileDispatchBoundary = 3,
    CounterSamplingPointAtBlitBoundary = 4,
};

_MTL_OPTIONS(NS::UInteger, PipelineOption) {
    PipelineOptionNone = 0,
    PipelineOptionArgumentInfo = 1,
    PipelineOptionBindingInfo = 1,
    PipelineOptionBufferTypeInfo = 1 << 1,
    PipelineOptionFailOnBinaryArchiveMiss = 1 << 2,
};

using DeviceNotificationName = NS::String*;
using DeviceNotificationHandlerBlock = void (^)(MTL::Device* pDevice, MTL::DeviceNotificationName notifyName);
using DeviceNotificationHandlerFunction = std::function<void(MTL::Device* pDevice, MTL::DeviceNotificationName notifyName)>;
using AutoreleasedComputePipelineReflection = MTL::ComputePipelineReflection*;
using AutoreleasedRenderPipelineReflection = MTL::RenderPipelineReflection*;
using NewLibraryCompletionHandler = void (^)(MTL::Library*, NS::Error*);
using NewLibraryCompletionHandlerFunction = std::function<void(MTL::Library*, NS::Error*)>;
using NewRenderPipelineStateCompletionHandler = void (^)(MTL::RenderPipelineState*, NS::Error*);
using NewRenderPipelineStateCompletionHandlerFunction = std::function<void(MTL::RenderPipelineState*, NS::Error*)>;
using NewRenderPipelineStateWithReflectionCompletionHandler = void (^)(MTL::RenderPipelineState*, MTL::RenderPipelineReflection*, NS::Error*);
using NewRenderPipelineStateWithReflectionCompletionHandlerFunction = std::function<void(MTL::RenderPipelineState*, MTL::RenderPipelineReflection*, NS::Error*)>;
using NewComputePipelineStateCompletionHandler = void (^)(MTL::ComputePipelineState*, NS::Error*);
using NewComputePipelineStateCompletionHandlerFunction = std::function<void(MTL::ComputePipelineState*, NS::Error*)>;
using NewComputePipelineStateWithReflectionCompletionHandler = void (^)(MTL::ComputePipelineState*, MTL::ComputePipelineReflection*, NS::Error*);
using NewComputePipelineStateWithReflectionCompletionHandlerFunction = std::function<void(MTL::ComputePipelineState*, MTL::ComputePipelineReflection*, NS::Error*)>;
using Timestamp = std::uint64_t;

_MTL_CONST(DeviceNotificationName, DeviceWasAddedNotification);
_MTL_CONST(DeviceNotificationName, DeviceRemovalRequestedNotification);
_MTL_CONST(DeviceNotificationName, DeviceWasRemovedNotification);
_MTL_CONST(NS::ErrorUserInfoKey, CommandBufferEncoderInfoErrorKey);
Device*    CreateSystemDefaultDevice();
NS::Array* CopyAllDevices();
NS::Array* CopyAllDevicesWithObserver(NS::Object** pOutObserver, MTL::DeviceNotificationHandlerBlock handler);
NS::Array* CopyAllDevicesWithObserver(NS::Object** pOutObserver, const MTL::DeviceNotificationHandlerFunction& handler);
void       RemoveDeviceObserver(const NS::Object* pObserver);
struct AccelerationStructureSizes
{
    NS::UInteger accelerationStructureSize;
    NS::UInteger buildScratchBufferSize;
    NS::UInteger refitScratchBufferSize;
} _MTL_PACKED;

struct SizeAndAlign
{
    NS::UInteger size;
    NS::UInteger align;
} _MTL_PACKED;

class ArgumentDescriptor : public NS::Copying<ArgumentDescriptor>
{
public:
    BindingAccess              access() const;

    static ArgumentDescriptor* alloc();

    static ArgumentDescriptor* argumentDescriptor();

    NS::UInteger               arrayLength() const;

    NS::UInteger               constantBlockAlignment() const;

    DataType                   dataType() const;

    NS::UInteger               index() const;

    ArgumentDescriptor*        init();

    void                       setAccess(MTL::BindingAccess access);

    void                       setArrayLength(NS::UInteger arrayLength);

    void                       setConstantBlockAlignment(NS::UInteger constantBlockAlignment);

    void                       setDataType(MTL::DataType dataType);

    void                       setIndex(NS::UInteger index);

    void                       setTextureType(MTL::TextureType textureType);
    TextureType                textureType() const;
};
class Architecture : public NS::Copying<Architecture>
{
public:
    static Architecture* alloc();

    Architecture*        init();

    NS::String*          name() const;
};
class Device : public NS::Referencing<Device>
{
public:
    AccelerationStructureSizes accelerationStructureSizes(const MTL::AccelerationStructureDescriptor* descriptor);

    Architecture*              architecture() const;

    bool                       areBarycentricCoordsSupported() const;

    bool                       areProgrammableSamplePositionsSupported() const;

    bool                       areRasterOrderGroupsSupported() const;

    ArgumentBuffersTier        argumentBuffersSupport() const;

    [[deprecated("please use areBarycentricCoordsSupported instead")]]
    bool         barycentricCoordsSupported() const;

    void         convertSparsePixelRegions(const MTL::Region* pixelRegions, MTL::Region* tileRegions, MTL::Size tileSize, MTL::SparseTextureRegionAlignmentMode mode, NS::UInteger numRegions);

    void         convertSparseTileRegions(const MTL::Region* tileRegions, MTL::Region* pixelRegions, MTL::Size tileSize, NS::UInteger numRegions);

    NS::Array*   counterSets() const;

    NS::UInteger currentAllocatedSize() const;

    [[deprecated("please use isDepth24Stencil8PixelFormatSupported instead")]]
    bool            depth24Stencil8PixelFormatSupported() const;

    FunctionHandle* functionHandle(const MTL::Function* function);
    FunctionHandle* functionHandle(const MTL4::BinaryFunction* function);

    void            getDefaultSamplePositions(MTL::SamplePosition* positions, NS::UInteger count);

    bool            hasUnifiedMemory() const;

    [[deprecated("please use isHeadless instead")]]
    bool           headless() const;

    SizeAndAlign   heapAccelerationStructureSizeAndAlign(NS::UInteger size);
    SizeAndAlign   heapAccelerationStructureSizeAndAlign(const MTL::AccelerationStructureDescriptor* descriptor);

    SizeAndAlign   heapBufferSizeAndAlign(NS::UInteger length, MTL::ResourceOptions options);

    SizeAndAlign   heapTextureSizeAndAlign(const MTL::TextureDescriptor* desc);

    bool           isDepth24Stencil8PixelFormatSupported() const;

    bool           isHeadless() const;

    bool           isLowPower() const;

    bool           isRemovable() const;

    DeviceLocation location() const;
    NS::UInteger   locationNumber() const;

    [[deprecated("please use isLowPower instead")]]
    bool                             lowPower() const;

    NS::UInteger                     maxArgumentBufferSamplerCount() const;

    NS::UInteger                     maxBufferLength() const;

    NS::UInteger                     maxThreadgroupMemoryLength() const;

    Size                             maxThreadsPerThreadgroup() const;

    uint64_t                         maxTransferRate() const;

    NS::UInteger                     maximumConcurrentCompilationTaskCount() const;

    NS::UInteger                     minimumLinearTextureAlignmentForPixelFormat(MTL::PixelFormat format);

    NS::UInteger                     minimumTextureBufferAlignmentForPixelFormat(MTL::PixelFormat format);

    NS::String*                      name() const;

    AccelerationStructure*           newAccelerationStructure(NS::UInteger size);
    AccelerationStructure*           newAccelerationStructure(const MTL::AccelerationStructureDescriptor* descriptor);

    MTL4::Archive*                   newArchive(const NS::URL* url, NS::Error** error);

    ArgumentEncoder*                 newArgumentEncoder(const NS::Array* arguments);
    ArgumentEncoder*                 newArgumentEncoder(const MTL::BufferBinding* bufferBinding);

    MTL4::ArgumentTable*             newArgumentTable(const MTL4::ArgumentTableDescriptor* descriptor, NS::Error** error);

    BinaryArchive*                   newBinaryArchive(const MTL::BinaryArchiveDescriptor* descriptor, NS::Error** error);

    Buffer*                          newBuffer(NS::UInteger length, MTL::ResourceOptions options);
    Buffer*                          newBuffer(const void* pointer, NS::UInteger length, MTL::ResourceOptions options);
    Buffer*                          newBuffer(const void* pointer, NS::UInteger length, MTL::ResourceOptions options, void (^deallocator)(void*, NS::UInteger));
    Buffer*                          newBuffer(NS::UInteger length, MTL::ResourceOptions options, MTL::SparsePageSize placementSparsePageSize);

    MTL4::CommandAllocator*          newCommandAllocator();
    MTL4::CommandAllocator*          newCommandAllocator(const MTL4::CommandAllocatorDescriptor* descriptor, NS::Error** error);

    MTL4::CommandBuffer*             newCommandBuffer();

    CommandQueue*                    newCommandQueue();
    CommandQueue*                    newCommandQueue(NS::UInteger maxCommandBufferCount);
    CommandQueue*                    newCommandQueue(const MTL::CommandQueueDescriptor* descriptor);

    MTL4::Compiler*                  newCompiler(const MTL4::CompilerDescriptor* descriptor, NS::Error** error);

    ComputePipelineState*            newComputePipelineState(const MTL::Function* computeFunction, NS::Error** error);
    ComputePipelineState*            newComputePipelineState(const MTL::Function* computeFunction, MTL::PipelineOption options, const MTL::AutoreleasedComputePipelineReflection* reflection, NS::Error** error);
    void                             newComputePipelineState(const MTL::Function* computeFunction, const MTL::NewComputePipelineStateCompletionHandler completionHandler);
    void                             newComputePipelineState(const MTL::Function* computeFunction, MTL::PipelineOption options, const MTL::NewComputePipelineStateWithReflectionCompletionHandler completionHandler);
    ComputePipelineState*            newComputePipelineState(const MTL::ComputePipelineDescriptor* descriptor, MTL::PipelineOption options, const MTL::AutoreleasedComputePipelineReflection* reflection, NS::Error** error);
    void                             newComputePipelineState(const MTL::ComputePipelineDescriptor* descriptor, MTL::PipelineOption options, const MTL::NewComputePipelineStateWithReflectionCompletionHandler completionHandler);
    void                             newComputePipelineState(const MTL::Function* pFunction, const MTL::NewComputePipelineStateCompletionHandlerFunction& completionHandler);
    void                             newComputePipelineState(const MTL::Function* pFunction, MTL::PipelineOption options, const MTL::NewComputePipelineStateWithReflectionCompletionHandlerFunction& completionHandler);
    void                             newComputePipelineState(const MTL::ComputePipelineDescriptor* pDescriptor, MTL::PipelineOption options, const MTL::NewComputePipelineStateWithReflectionCompletionHandlerFunction& completionHandler);

    MTL4::CounterHeap*               newCounterHeap(const MTL4::CounterHeapDescriptor* descriptor, NS::Error** error);

    CounterSampleBuffer*             newCounterSampleBuffer(const MTL::CounterSampleBufferDescriptor* descriptor, NS::Error** error);

    Library*                         newDefaultLibrary();
    Library*                         newDefaultLibrary(const NS::Bundle* bundle, NS::Error** error);

    DepthStencilState*               newDepthStencilState(const MTL::DepthStencilDescriptor* descriptor);

    DynamicLibrary*                  newDynamicLibrary(const MTL::Library* library, NS::Error** error);
    DynamicLibrary*                  newDynamicLibrary(const NS::URL* url, NS::Error** error);

    Event*                           newEvent();

    Fence*                           newFence();

    Heap*                            newHeap(const MTL::HeapDescriptor* descriptor);

    IOCommandQueue*                  newIOCommandQueue(const MTL::IOCommandQueueDescriptor* descriptor, NS::Error** error);

    IOFileHandle*                    newIOFileHandle(const NS::URL* url, NS::Error** error);
    IOFileHandle*                    newIOFileHandle(const NS::URL* url, MTL::IOCompressionMethod compressionMethod, NS::Error** error);

    IOFileHandle*                    newIOHandle(const NS::URL* url, NS::Error** error);
    IOFileHandle*                    newIOHandle(const NS::URL* url, MTL::IOCompressionMethod compressionMethod, NS::Error** error);

    IndirectCommandBuffer*           newIndirectCommandBuffer(const MTL::IndirectCommandBufferDescriptor* descriptor, NS::UInteger maxCount, MTL::ResourceOptions options);

    Library*                         newLibrary(const NS::String* filepath, NS::Error** error);
    Library*                         newLibrary(const NS::URL* url, NS::Error** error);
    Library*                         newLibrary(const dispatch_data_t data, NS::Error** error);
    Library*                         newLibrary(const NS::String* source, const MTL::CompileOptions* options, NS::Error** error);
    void                             newLibrary(const NS::String* source, const MTL::CompileOptions* options, const MTL::NewLibraryCompletionHandler completionHandler);
    Library*                         newLibrary(const MTL::StitchedLibraryDescriptor* descriptor, NS::Error** error);
    void                             newLibrary(const MTL::StitchedLibraryDescriptor* descriptor, const MTL::NewLibraryCompletionHandler completionHandler);
    void                             newLibrary(const NS::String* pSource, const MTL::CompileOptions* pOptions, const MTL::NewLibraryCompletionHandlerFunction& completionHandler);
    void                             newLibrary(const MTL::StitchedLibraryDescriptor* pDescriptor, const MTL::NewLibraryCompletionHandlerFunction& completionHandler);

    LogState*                        newLogState(const MTL::LogStateDescriptor* descriptor, NS::Error** error);

    MTL4::CommandQueue*              newMTL4CommandQueue();
    MTL4::CommandQueue*              newMTL4CommandQueue(const MTL4::CommandQueueDescriptor* descriptor, NS::Error** error);

    MTL4::PipelineDataSetSerializer* newPipelineDataSetSerializer(const MTL4::PipelineDataSetSerializerDescriptor* descriptor);

    RasterizationRateMap*            newRasterizationRateMap(const MTL::RasterizationRateMapDescriptor* descriptor);

    RenderPipelineState*             newRenderPipelineState(const MTL::RenderPipelineDescriptor* descriptor, NS::Error** error);
    RenderPipelineState*             newRenderPipelineState(const MTL::RenderPipelineDescriptor* descriptor, MTL::PipelineOption options, const MTL::AutoreleasedRenderPipelineReflection* reflection, NS::Error** error);
    void                             newRenderPipelineState(const MTL::RenderPipelineDescriptor* descriptor, const MTL::NewRenderPipelineStateCompletionHandler completionHandler);
    void                             newRenderPipelineState(const MTL::RenderPipelineDescriptor* descriptor, MTL::PipelineOption options, const MTL::NewRenderPipelineStateWithReflectionCompletionHandler completionHandler);
    RenderPipelineState*             newRenderPipelineState(const MTL::TileRenderPipelineDescriptor* descriptor, MTL::PipelineOption options, const MTL::AutoreleasedRenderPipelineReflection* reflection, NS::Error** error);
    void                             newRenderPipelineState(const MTL::TileRenderPipelineDescriptor* descriptor, MTL::PipelineOption options, const MTL::NewRenderPipelineStateWithReflectionCompletionHandler completionHandler);
    RenderPipelineState*             newRenderPipelineState(const MTL::MeshRenderPipelineDescriptor* descriptor, MTL::PipelineOption options, const MTL::AutoreleasedRenderPipelineReflection* reflection, NS::Error** error);
    void                             newRenderPipelineState(const MTL::MeshRenderPipelineDescriptor* descriptor, MTL::PipelineOption options, const MTL::NewRenderPipelineStateWithReflectionCompletionHandler completionHandler);
    void                             newRenderPipelineState(const MTL::RenderPipelineDescriptor* pDescriptor, const MTL::NewRenderPipelineStateCompletionHandlerFunction& completionHandler);
    void                             newRenderPipelineState(const MTL::RenderPipelineDescriptor* pDescriptor, MTL::PipelineOption options, const MTL::NewRenderPipelineStateWithReflectionCompletionHandlerFunction& completionHandler);
    void                             newRenderPipelineState(const MTL::TileRenderPipelineDescriptor* pDescriptor, MTL::PipelineOption options, const MTL::NewRenderPipelineStateWithReflectionCompletionHandlerFunction& completionHandler);

    ResidencySet*                    newResidencySet(const MTL::ResidencySetDescriptor* desc, NS::Error** error);

    SamplerState*                    newSamplerState(const MTL::SamplerDescriptor* descriptor);

    SharedEvent*                     newSharedEvent();
    SharedEvent*                     newSharedEvent(const MTL::SharedEventHandle* sharedEventHandle);

    Texture*                         newSharedTexture(const MTL::TextureDescriptor* descriptor);
    Texture*                         newSharedTexture(const MTL::SharedTextureHandle* sharedHandle);

    Tensor*                          newTensor(const MTL::TensorDescriptor* descriptor, NS::Error** error);

    Texture*                         newTexture(const MTL::TextureDescriptor* descriptor);
    Texture*                         newTexture(const MTL::TextureDescriptor* descriptor, const IOSurfaceRef iosurface, NS::UInteger plane);
    TextureViewPool*                 newTextureViewPool(const MTL::ResourceViewPoolDescriptor* descriptor, NS::Error** error);

    uint32_t                         peerCount() const;

    uint64_t                         peerGroupID() const;

    uint32_t                         peerIndex() const;

    [[deprecated("please use areProgrammableSamplePositionsSupported instead")]]
    bool     programmableSamplePositionsSupported() const;

    uint64_t queryTimestampFrequency();

    [[deprecated("please use areRasterOrderGroupsSupported instead")]]
    bool                 rasterOrderGroupsSupported() const;

    ReadWriteTextureTier readWriteTextureSupport() const;

    uint64_t             recommendedMaxWorkingSetSize() const;

    uint64_t             registryID() const;

    [[deprecated("please use isRemovable instead")]]
    bool         removable() const;

    void         sampleTimestamps(MTL::Timestamp* cpuTimestamp, MTL::Timestamp* gpuTimestamp);

    void         setShouldMaximizeConcurrentCompilation(bool shouldMaximizeConcurrentCompilation);
    bool         shouldMaximizeConcurrentCompilation() const;

    NS::UInteger sizeOfCounterHeapEntry(MTL4::CounterHeapType type);

    Size         sparseTileSize(MTL::TextureType textureType, MTL::PixelFormat pixelFormat, NS::UInteger sampleCount);
    Size         sparseTileSize(MTL::TextureType textureType, MTL::PixelFormat pixelFormat, NS::UInteger sampleCount, MTL::SparsePageSize sparsePageSize);
    NS::UInteger sparseTileSizeInBytes() const;
    NS::UInteger sparseTileSizeInBytes(MTL::SparsePageSize sparsePageSize);

    bool         supports32BitFloatFiltering() const;

    bool         supports32BitMSAA() const;

    bool         supportsBCTextureCompression() const;

    bool         supportsCounterSampling(MTL::CounterSamplingPoint samplingPoint);

    bool         supportsDynamicLibraries() const;

    bool         supportsFamily(MTL::GPUFamily gpuFamily);

    bool         supportsFeatureSet(MTL::FeatureSet featureSet);

    bool         supportsFunctionPointers() const;
    bool         supportsFunctionPointersFromRender() const;

    bool         supportsPrimitiveMotionBlur() const;

    bool         supportsPullModelInterpolation() const;

    bool         supportsQueryTextureLOD() const;

    bool         supportsRasterizationRateMap(NS::UInteger layerCount);

    bool         supportsRaytracing() const;
    bool         supportsRaytracingFromRender() const;

    bool         supportsRenderDynamicLibraries() const;

    bool         supportsShaderBarycentricCoordinates() const;

    bool         supportsTextureSampleCount(NS::UInteger sampleCount);

    bool         supportsVertexAmplificationCount(NS::UInteger count);

    SizeAndAlign tensorSizeAndAlign(const MTL::TensorDescriptor* descriptor);
};

}

#if defined(MTL_PRIVATE_IMPLEMENTATION)
extern "C" MTL::Device* MTLCreateSystemDefaultDevice();
extern "C" NS::Array*   MTLCopyAllDevices();
extern "C" NS::Array*   MTLCopyAllDevicesWithObserver(NS::Object**, MTL::DeviceNotificationHandlerBlock);
extern "C" void         MTLRemoveDeviceObserver(const NS::Object*);
_MTL_PRIVATE_DEF_WEAK_CONST(MTL::DeviceNotificationName, DeviceWasAddedNotification);
_MTL_PRIVATE_DEF_WEAK_CONST(MTL::DeviceNotificationName, DeviceRemovalRequestedNotification);
_MTL_PRIVATE_DEF_WEAK_CONST(MTL::DeviceNotificationName, DeviceWasRemovedNotification);
_MTL_PRIVATE_DEF_CONST(NS::ErrorUserInfoKey, CommandBufferEncoderInfoErrorKey);
_NS_EXPORT MTL::Device* MTL::CreateSystemDefaultDevice()
{
    return ::MTLCreateSystemDefaultDevice();
}

_NS_EXPORT NS::Array* MTL::CopyAllDevices()
{
#if (__IPHONE_OS_VERSION_MIN_REQUIRED >= 180000) || (__MAC_OS_X_VERSION_MIN_REQUIRED >= 101100)
    return ::MTLCopyAllDevices();
#else
    return nullptr;
#endif
}

_NS_EXPORT NS::Array* MTL::CopyAllDevicesWithObserver(NS::Object** pOutObserver, MTL::DeviceNotificationHandlerBlock handler)
{
#if TARGET_OS_OSX
    return ::MTLCopyAllDevicesWithObserver(pOutObserver, handler);
#else
    (void)pOutObserver;
    (void)handler;
    return nullptr;
#endif // TARGET_OS_OSX
}

_NS_EXPORT NS::Array* MTL::CopyAllDevicesWithObserver(NS::Object** pOutObserver, const MTL::DeviceNotificationHandlerFunction& handler)
{
    __block DeviceNotificationHandlerFunction function = handler;
    return CopyAllDevicesWithObserver(pOutObserver, ^(Device* pDevice, DeviceNotificationName pNotificationName) { function(pDevice, pNotificationName); });
}

_NS_EXPORT void MTL::RemoveDeviceObserver(const NS::Object* pObserver)
{
    (void)pObserver;
#if TARGET_OS_OSX
    ::MTLRemoveDeviceObserver(pObserver);
#endif // TARGET_OS_OSX
}

#endif // MTL_PRIVATE_IMPLEMENTATION

_MTL_INLINE MTL::BindingAccess MTL::ArgumentDescriptor::access() const
{
    return Object::sendMessage<MTL::BindingAccess>(this, _MTL_PRIVATE_SEL(access));
}

_MTL_INLINE MTL::ArgumentDescriptor* MTL::ArgumentDescriptor::alloc()
{
    return NS::Object::alloc<MTL::ArgumentDescriptor>(_MTL_PRIVATE_CLS(MTLArgumentDescriptor));
}

_MTL_INLINE MTL::ArgumentDescriptor* MTL::ArgumentDescriptor::argumentDescriptor()
{
    return Object::sendMessage<MTL::ArgumentDescriptor*>(_MTL_PRIVATE_CLS(MTLArgumentDescriptor), _MTL_PRIVATE_SEL(argumentDescriptor));
}

_MTL_INLINE NS::UInteger MTL::ArgumentDescriptor::arrayLength() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(arrayLength));
}

_MTL_INLINE NS::UInteger MTL::ArgumentDescriptor::constantBlockAlignment() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(constantBlockAlignment));
}

_MTL_INLINE MTL::DataType MTL::ArgumentDescriptor::dataType() const
{
    return Object::sendMessage<MTL::DataType>(this, _MTL_PRIVATE_SEL(dataType));
}

_MTL_INLINE NS::UInteger MTL::ArgumentDescriptor::index() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(index));
}

_MTL_INLINE MTL::ArgumentDescriptor* MTL::ArgumentDescriptor::init()
{
    return NS::Object::init<MTL::ArgumentDescriptor>();
}

_MTL_INLINE void MTL::ArgumentDescriptor::setAccess(MTL::BindingAccess access)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setAccess_), access);
}

_MTL_INLINE void MTL::ArgumentDescriptor::setArrayLength(NS::UInteger arrayLength)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setArrayLength_), arrayLength);
}

_MTL_INLINE void MTL::ArgumentDescriptor::setConstantBlockAlignment(NS::UInteger constantBlockAlignment)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setConstantBlockAlignment_), constantBlockAlignment);
}

_MTL_INLINE void MTL::ArgumentDescriptor::setDataType(MTL::DataType dataType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDataType_), dataType);
}

_MTL_INLINE void MTL::ArgumentDescriptor::setIndex(NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setIndex_), index);
}

_MTL_INLINE void MTL::ArgumentDescriptor::setTextureType(MTL::TextureType textureType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTextureType_), textureType);
}

_MTL_INLINE MTL::TextureType MTL::ArgumentDescriptor::textureType() const
{
    return Object::sendMessage<MTL::TextureType>(this, _MTL_PRIVATE_SEL(textureType));
}

_MTL_INLINE MTL::Architecture* MTL::Architecture::alloc()
{
    return NS::Object::alloc<MTL::Architecture>(_MTL_PRIVATE_CLS(MTLArchitecture));
}

_MTL_INLINE MTL::Architecture* MTL::Architecture::init()
{
    return NS::Object::init<MTL::Architecture>();
}

_MTL_INLINE NS::String* MTL::Architecture::name() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(name));
}

_MTL_INLINE MTL::AccelerationStructureSizes MTL::Device::accelerationStructureSizes(const MTL::AccelerationStructureDescriptor* descriptor)
{
    return Object::sendMessage<MTL::AccelerationStructureSizes>(this, _MTL_PRIVATE_SEL(accelerationStructureSizesWithDescriptor_), descriptor);
}

_MTL_INLINE MTL::Architecture* MTL::Device::architecture() const
{
    return Object::sendMessage<MTL::Architecture*>(this, _MTL_PRIVATE_SEL(architecture));
}

_MTL_INLINE bool MTL::Device::areBarycentricCoordsSupported() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(areBarycentricCoordsSupported));
}

_MTL_INLINE bool MTL::Device::areProgrammableSamplePositionsSupported() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(areProgrammableSamplePositionsSupported));
}

_MTL_INLINE bool MTL::Device::areRasterOrderGroupsSupported() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(areRasterOrderGroupsSupported));
}

_MTL_INLINE MTL::ArgumentBuffersTier MTL::Device::argumentBuffersSupport() const
{
    return Object::sendMessage<MTL::ArgumentBuffersTier>(this, _MTL_PRIVATE_SEL(argumentBuffersSupport));
}

_MTL_INLINE bool MTL::Device::barycentricCoordsSupported() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(areBarycentricCoordsSupported));
}

_MTL_INLINE void MTL::Device::convertSparsePixelRegions(const MTL::Region* pixelRegions, MTL::Region* tileRegions, MTL::Size tileSize, MTL::SparseTextureRegionAlignmentMode mode, NS::UInteger numRegions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(convertSparsePixelRegions_toTileRegions_withTileSize_alignmentMode_numRegions_), pixelRegions, tileRegions, tileSize, mode, numRegions);
}

_MTL_INLINE void MTL::Device::convertSparseTileRegions(const MTL::Region* tileRegions, MTL::Region* pixelRegions, MTL::Size tileSize, NS::UInteger numRegions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(convertSparseTileRegions_toPixelRegions_withTileSize_numRegions_), tileRegions, pixelRegions, tileSize, numRegions);
}

_MTL_INLINE NS::Array* MTL::Device::counterSets() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(counterSets));
}

_MTL_INLINE NS::UInteger MTL::Device::currentAllocatedSize() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(currentAllocatedSize));
}

_MTL_INLINE bool MTL::Device::depth24Stencil8PixelFormatSupported() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(isDepth24Stencil8PixelFormatSupported));
}

_MTL_INLINE MTL::FunctionHandle* MTL::Device::functionHandle(const MTL::Function* function)
{
    return Object::sendMessage<MTL::FunctionHandle*>(this, _MTL_PRIVATE_SEL(functionHandleWithFunction_), function);
}

_MTL_INLINE MTL::FunctionHandle* MTL::Device::functionHandle(const MTL4::BinaryFunction* function)
{
    return Object::sendMessage<MTL::FunctionHandle*>(this, _MTL_PRIVATE_SEL(functionHandleWithBinaryFunction_), function);
}

_MTL_INLINE void MTL::Device::getDefaultSamplePositions(MTL::SamplePosition* positions, NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(getDefaultSamplePositions_count_), positions, count);
}

_MTL_INLINE bool MTL::Device::hasUnifiedMemory() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(hasUnifiedMemory));
}

_MTL_INLINE bool MTL::Device::headless() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isHeadless));
}

_MTL_INLINE MTL::SizeAndAlign MTL::Device::heapAccelerationStructureSizeAndAlign(NS::UInteger size)
{
    return Object::sendMessage<MTL::SizeAndAlign>(this, _MTL_PRIVATE_SEL(heapAccelerationStructureSizeAndAlignWithSize_), size);
}

_MTL_INLINE MTL::SizeAndAlign MTL::Device::heapAccelerationStructureSizeAndAlign(const MTL::AccelerationStructureDescriptor* descriptor)
{
    return Object::sendMessage<MTL::SizeAndAlign>(this, _MTL_PRIVATE_SEL(heapAccelerationStructureSizeAndAlignWithDescriptor_), descriptor);
}

_MTL_INLINE MTL::SizeAndAlign MTL::Device::heapBufferSizeAndAlign(NS::UInteger length, MTL::ResourceOptions options)
{
    return Object::sendMessage<MTL::SizeAndAlign>(this, _MTL_PRIVATE_SEL(heapBufferSizeAndAlignWithLength_options_), length, options);
}

_MTL_INLINE MTL::SizeAndAlign MTL::Device::heapTextureSizeAndAlign(const MTL::TextureDescriptor* desc)
{
    return Object::sendMessage<MTL::SizeAndAlign>(this, _MTL_PRIVATE_SEL(heapTextureSizeAndAlignWithDescriptor_), desc);
}

_MTL_INLINE bool MTL::Device::isDepth24Stencil8PixelFormatSupported() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(isDepth24Stencil8PixelFormatSupported));
}

_MTL_INLINE bool MTL::Device::isHeadless() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isHeadless));
}

_MTL_INLINE bool MTL::Device::isLowPower() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isLowPower));
}

_MTL_INLINE bool MTL::Device::isRemovable() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isRemovable));
}

_MTL_INLINE MTL::DeviceLocation MTL::Device::location() const
{
    return Object::sendMessage<MTL::DeviceLocation>(this, _MTL_PRIVATE_SEL(location));
}

_MTL_INLINE NS::UInteger MTL::Device::locationNumber() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(locationNumber));
}

_MTL_INLINE bool MTL::Device::lowPower() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isLowPower));
}

_MTL_INLINE NS::UInteger MTL::Device::maxArgumentBufferSamplerCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxArgumentBufferSamplerCount));
}

_MTL_INLINE NS::UInteger MTL::Device::maxBufferLength() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxBufferLength));
}

_MTL_INLINE NS::UInteger MTL::Device::maxThreadgroupMemoryLength() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxThreadgroupMemoryLength));
}

_MTL_INLINE MTL::Size MTL::Device::maxThreadsPerThreadgroup() const
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(maxThreadsPerThreadgroup));
}

_MTL_INLINE uint64_t MTL::Device::maxTransferRate() const
{
    return Object::sendMessage<uint64_t>(this, _MTL_PRIVATE_SEL(maxTransferRate));
}

_MTL_INLINE NS::UInteger MTL::Device::maximumConcurrentCompilationTaskCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maximumConcurrentCompilationTaskCount));
}

_MTL_INLINE NS::UInteger MTL::Device::minimumLinearTextureAlignmentForPixelFormat(MTL::PixelFormat format)
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(minimumLinearTextureAlignmentForPixelFormat_), format);
}

_MTL_INLINE NS::UInteger MTL::Device::minimumTextureBufferAlignmentForPixelFormat(MTL::PixelFormat format)
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(minimumTextureBufferAlignmentForPixelFormat_), format);
}

_MTL_INLINE NS::String* MTL::Device::name() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(name));
}

_MTL_INLINE MTL::AccelerationStructure* MTL::Device::newAccelerationStructure(NS::UInteger size)
{
    return Object::sendMessage<MTL::AccelerationStructure*>(this, _MTL_PRIVATE_SEL(newAccelerationStructureWithSize_), size);
}

_MTL_INLINE MTL::AccelerationStructure* MTL::Device::newAccelerationStructure(const MTL::AccelerationStructureDescriptor* descriptor)
{
    return Object::sendMessage<MTL::AccelerationStructure*>(this, _MTL_PRIVATE_SEL(newAccelerationStructureWithDescriptor_), descriptor);
}

_MTL_INLINE MTL4::Archive* MTL::Device::newArchive(const NS::URL* url, NS::Error** error)
{
    return Object::sendMessage<MTL4::Archive*>(this, _MTL_PRIVATE_SEL(newArchiveWithURL_error_), url, error);
}

_MTL_INLINE MTL::ArgumentEncoder* MTL::Device::newArgumentEncoder(const NS::Array* arguments)
{
    return Object::sendMessage<MTL::ArgumentEncoder*>(this, _MTL_PRIVATE_SEL(newArgumentEncoderWithArguments_), arguments);
}

_MTL_INLINE MTL::ArgumentEncoder* MTL::Device::newArgumentEncoder(const MTL::BufferBinding* bufferBinding)
{
    return Object::sendMessage<MTL::ArgumentEncoder*>(this, _MTL_PRIVATE_SEL(newArgumentEncoderWithBufferBinding_), bufferBinding);
}

_MTL_INLINE MTL4::ArgumentTable* MTL::Device::newArgumentTable(const MTL4::ArgumentTableDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL4::ArgumentTable*>(this, _MTL_PRIVATE_SEL(newArgumentTableWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE MTL::BinaryArchive* MTL::Device::newBinaryArchive(const MTL::BinaryArchiveDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL::BinaryArchive*>(this, _MTL_PRIVATE_SEL(newBinaryArchiveWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE MTL::Buffer* MTL::Device::newBuffer(NS::UInteger length, MTL::ResourceOptions options)
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(newBufferWithLength_options_), length, options);
}

_MTL_INLINE MTL::Buffer* MTL::Device::newBuffer(const void* pointer, NS::UInteger length, MTL::ResourceOptions options)
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(newBufferWithBytes_length_options_), pointer, length, options);
}

_MTL_INLINE MTL::Buffer* MTL::Device::newBuffer(const void* pointer, NS::UInteger length, MTL::ResourceOptions options, void (^deallocator)(void*, NS::UInteger))
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(newBufferWithBytesNoCopy_length_options_deallocator_), pointer, length, options, deallocator);
}

_MTL_INLINE MTL::Buffer* MTL::Device::newBuffer(NS::UInteger length, MTL::ResourceOptions options, MTL::SparsePageSize placementSparsePageSize)
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(newBufferWithLength_options_placementSparsePageSize_), length, options, placementSparsePageSize);
}

_MTL_INLINE MTL4::CommandAllocator* MTL::Device::newCommandAllocator()
{
    return Object::sendMessage<MTL4::CommandAllocator*>(this, _MTL_PRIVATE_SEL(newCommandAllocator));
}

_MTL_INLINE MTL4::CommandAllocator* MTL::Device::newCommandAllocator(const MTL4::CommandAllocatorDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL4::CommandAllocator*>(this, _MTL_PRIVATE_SEL(newCommandAllocatorWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE MTL4::CommandBuffer* MTL::Device::newCommandBuffer()
{
    return Object::sendMessage<MTL4::CommandBuffer*>(this, _MTL_PRIVATE_SEL(newCommandBuffer));
}

_MTL_INLINE MTL::CommandQueue* MTL::Device::newCommandQueue()
{
    return Object::sendMessage<MTL::CommandQueue*>(this, _MTL_PRIVATE_SEL(newCommandQueue));
}

_MTL_INLINE MTL::CommandQueue* MTL::Device::newCommandQueue(NS::UInteger maxCommandBufferCount)
{
    return Object::sendMessage<MTL::CommandQueue*>(this, _MTL_PRIVATE_SEL(newCommandQueueWithMaxCommandBufferCount_), maxCommandBufferCount);
}

_MTL_INLINE MTL::CommandQueue* MTL::Device::newCommandQueue(const MTL::CommandQueueDescriptor* descriptor)
{
    return Object::sendMessage<MTL::CommandQueue*>(this, _MTL_PRIVATE_SEL(newCommandQueueWithDescriptor_), descriptor);
}

_MTL_INLINE MTL4::Compiler* MTL::Device::newCompiler(const MTL4::CompilerDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL4::Compiler*>(this, _MTL_PRIVATE_SEL(newCompilerWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE MTL::ComputePipelineState* MTL::Device::newComputePipelineState(const MTL::Function* computeFunction, NS::Error** error)
{
    return Object::sendMessage<MTL::ComputePipelineState*>(this, _MTL_PRIVATE_SEL(newComputePipelineStateWithFunction_error_), computeFunction, error);
}

_MTL_INLINE MTL::ComputePipelineState* MTL::Device::newComputePipelineState(const MTL::Function* computeFunction, MTL::PipelineOption options, const MTL::AutoreleasedComputePipelineReflection* reflection, NS::Error** error)
{
    return Object::sendMessage<MTL::ComputePipelineState*>(this, _MTL_PRIVATE_SEL(newComputePipelineStateWithFunction_options_reflection_error_), computeFunction, options, reflection, error);
}

_MTL_INLINE void MTL::Device::newComputePipelineState(const MTL::Function* computeFunction, const MTL::NewComputePipelineStateCompletionHandler completionHandler)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(newComputePipelineStateWithFunction_completionHandler_), computeFunction, completionHandler);
}

_MTL_INLINE void MTL::Device::newComputePipelineState(const MTL::Function* computeFunction, MTL::PipelineOption options, const MTL::NewComputePipelineStateWithReflectionCompletionHandler completionHandler)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(newComputePipelineStateWithFunction_options_completionHandler_), computeFunction, options, completionHandler);
}

_MTL_INLINE MTL::ComputePipelineState* MTL::Device::newComputePipelineState(const MTL::ComputePipelineDescriptor* descriptor, MTL::PipelineOption options, const MTL::AutoreleasedComputePipelineReflection* reflection, NS::Error** error)
{
    return Object::sendMessage<MTL::ComputePipelineState*>(this, _MTL_PRIVATE_SEL(newComputePipelineStateWithDescriptor_options_reflection_error_), descriptor, options, reflection, error);
}

_MTL_INLINE void MTL::Device::newComputePipelineState(const MTL::ComputePipelineDescriptor* descriptor, MTL::PipelineOption options, const MTL::NewComputePipelineStateWithReflectionCompletionHandler completionHandler)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(newComputePipelineStateWithDescriptor_options_completionHandler_), descriptor, options, completionHandler);
}

_MTL_INLINE void MTL::Device::newComputePipelineState(const MTL::Function* pFunction, const MTL::NewComputePipelineStateCompletionHandlerFunction& completionHandler)
{
    __block MTL::NewComputePipelineStateCompletionHandlerFunction blockCompletionHandler = completionHandler;
    newComputePipelineState(pFunction, ^(MTL::ComputePipelineState* pPipelineState, NS::Error* pError) { blockCompletionHandler(pPipelineState, pError); });
}

_MTL_INLINE void MTL::Device::newComputePipelineState(const MTL::Function* pFunction, MTL::PipelineOption options, const MTL::NewComputePipelineStateWithReflectionCompletionHandlerFunction& completionHandler)
{
    __block MTL::NewComputePipelineStateWithReflectionCompletionHandlerFunction blockCompletionHandler = completionHandler;
    newComputePipelineState(pFunction, options, ^(MTL::ComputePipelineState* pPipelineState, MTL::ComputePipelineReflection* pReflection, NS::Error* pError) { blockCompletionHandler(pPipelineState, pReflection, pError); });
}

_MTL_INLINE void MTL::Device::newComputePipelineState(const MTL::ComputePipelineDescriptor* pDescriptor, MTL::PipelineOption options, const MTL::NewComputePipelineStateWithReflectionCompletionHandlerFunction& completionHandler)
{
    __block NewComputePipelineStateWithReflectionCompletionHandlerFunction blockCompletionHandler = completionHandler;
    newComputePipelineState(pDescriptor, options, ^(ComputePipelineState* pPipelineState, ComputePipelineReflection* pReflection, NS::Error* pError) { blockCompletionHandler(pPipelineState, pReflection, pError); });
}

_MTL_INLINE MTL4::CounterHeap* MTL::Device::newCounterHeap(const MTL4::CounterHeapDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL4::CounterHeap*>(this, _MTL_PRIVATE_SEL(newCounterHeapWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE MTL::CounterSampleBuffer* MTL::Device::newCounterSampleBuffer(const MTL::CounterSampleBufferDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL::CounterSampleBuffer*>(this, _MTL_PRIVATE_SEL(newCounterSampleBufferWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE MTL::Library* MTL::Device::newDefaultLibrary()
{
    return Object::sendMessage<MTL::Library*>(this, _MTL_PRIVATE_SEL(newDefaultLibrary));
}

_MTL_INLINE MTL::Library* MTL::Device::newDefaultLibrary(const NS::Bundle* bundle, NS::Error** error)
{
    return Object::sendMessage<MTL::Library*>(this, _MTL_PRIVATE_SEL(newDefaultLibraryWithBundle_error_), bundle, error);
}

_MTL_INLINE MTL::DepthStencilState* MTL::Device::newDepthStencilState(const MTL::DepthStencilDescriptor* descriptor)
{
    return Object::sendMessage<MTL::DepthStencilState*>(this, _MTL_PRIVATE_SEL(newDepthStencilStateWithDescriptor_), descriptor);
}

_MTL_INLINE MTL::DynamicLibrary* MTL::Device::newDynamicLibrary(const MTL::Library* library, NS::Error** error)
{
    return Object::sendMessage<MTL::DynamicLibrary*>(this, _MTL_PRIVATE_SEL(newDynamicLibrary_error_), library, error);
}

_MTL_INLINE MTL::DynamicLibrary* MTL::Device::newDynamicLibrary(const NS::URL* url, NS::Error** error)
{
    return Object::sendMessage<MTL::DynamicLibrary*>(this, _MTL_PRIVATE_SEL(newDynamicLibraryWithURL_error_), url, error);
}

_MTL_INLINE MTL::Event* MTL::Device::newEvent()
{
    return Object::sendMessage<MTL::Event*>(this, _MTL_PRIVATE_SEL(newEvent));
}

_MTL_INLINE MTL::Fence* MTL::Device::newFence()
{
    return Object::sendMessage<MTL::Fence*>(this, _MTL_PRIVATE_SEL(newFence));
}

_MTL_INLINE MTL::Heap* MTL::Device::newHeap(const MTL::HeapDescriptor* descriptor)
{
    return Object::sendMessage<MTL::Heap*>(this, _MTL_PRIVATE_SEL(newHeapWithDescriptor_), descriptor);
}

_MTL_INLINE MTL::IOCommandQueue* MTL::Device::newIOCommandQueue(const MTL::IOCommandQueueDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL::IOCommandQueue*>(this, _MTL_PRIVATE_SEL(newIOCommandQueueWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE MTL::IOFileHandle* MTL::Device::newIOFileHandle(const NS::URL* url, NS::Error** error)
{
    return Object::sendMessage<MTL::IOFileHandle*>(this, _MTL_PRIVATE_SEL(newIOFileHandleWithURL_error_), url, error);
}

_MTL_INLINE MTL::IOFileHandle* MTL::Device::newIOFileHandle(const NS::URL* url, MTL::IOCompressionMethod compressionMethod, NS::Error** error)
{
    return Object::sendMessage<MTL::IOFileHandle*>(this, _MTL_PRIVATE_SEL(newIOFileHandleWithURL_compressionMethod_error_), url, compressionMethod, error);
}

_MTL_INLINE MTL::IOFileHandle* MTL::Device::newIOHandle(const NS::URL* url, NS::Error** error)
{
    return Object::sendMessage<MTL::IOFileHandle*>(this, _MTL_PRIVATE_SEL(newIOHandleWithURL_error_), url, error);
}

_MTL_INLINE MTL::IOFileHandle* MTL::Device::newIOHandle(const NS::URL* url, MTL::IOCompressionMethod compressionMethod, NS::Error** error)
{
    return Object::sendMessage<MTL::IOFileHandle*>(this, _MTL_PRIVATE_SEL(newIOHandleWithURL_compressionMethod_error_), url, compressionMethod, error);
}

_MTL_INLINE MTL::IndirectCommandBuffer* MTL::Device::newIndirectCommandBuffer(const MTL::IndirectCommandBufferDescriptor* descriptor, NS::UInteger maxCount, MTL::ResourceOptions options)
{
    return Object::sendMessage<MTL::IndirectCommandBuffer*>(this, _MTL_PRIVATE_SEL(newIndirectCommandBufferWithDescriptor_maxCommandCount_options_), descriptor, maxCount, options);
}

_MTL_INLINE MTL::Library* MTL::Device::newLibrary(const NS::String* filepath, NS::Error** error)
{
    return Object::sendMessage<MTL::Library*>(this, _MTL_PRIVATE_SEL(newLibraryWithFile_error_), filepath, error);
}

_MTL_INLINE MTL::Library* MTL::Device::newLibrary(const NS::URL* url, NS::Error** error)
{
    return Object::sendMessage<MTL::Library*>(this, _MTL_PRIVATE_SEL(newLibraryWithURL_error_), url, error);
}

_MTL_INLINE MTL::Library* MTL::Device::newLibrary(const dispatch_data_t data, NS::Error** error)
{
    return Object::sendMessage<MTL::Library*>(this, _MTL_PRIVATE_SEL(newLibraryWithData_error_), data, error);
}

_MTL_INLINE MTL::Library* MTL::Device::newLibrary(const NS::String* source, const MTL::CompileOptions* options, NS::Error** error)
{
    return Object::sendMessage<MTL::Library*>(this, _MTL_PRIVATE_SEL(newLibraryWithSource_options_error_), source, options, error);
}

_MTL_INLINE void MTL::Device::newLibrary(const NS::String* source, const MTL::CompileOptions* options, const MTL::NewLibraryCompletionHandler completionHandler)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(newLibraryWithSource_options_completionHandler_), source, options, completionHandler);
}

_MTL_INLINE MTL::Library* MTL::Device::newLibrary(const MTL::StitchedLibraryDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL::Library*>(this, _MTL_PRIVATE_SEL(newLibraryWithStitchedDescriptor_error_), descriptor, error);
}

_MTL_INLINE void MTL::Device::newLibrary(const MTL::StitchedLibraryDescriptor* descriptor, const MTL::NewLibraryCompletionHandler completionHandler)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(newLibraryWithStitchedDescriptor_completionHandler_), descriptor, completionHandler);
}

_MTL_INLINE void MTL::Device::newLibrary(const NS::String* pSource, const MTL::CompileOptions* pOptions, const MTL::NewLibraryCompletionHandlerFunction& completionHandler)
{
    __block MTL::NewLibraryCompletionHandlerFunction blockCompletionHandler = completionHandler;
    newLibrary(pSource, pOptions, ^(MTL::Library* pLibrary, NS::Error* pError) { blockCompletionHandler(pLibrary, pError); });
}

_MTL_INLINE void MTL::Device::newLibrary(const MTL::StitchedLibraryDescriptor* pDescriptor, const MTL::NewLibraryCompletionHandlerFunction& completionHandler)
{
    __block MTL::NewLibraryCompletionHandlerFunction blockCompletionHandler = completionHandler;
    newLibrary(pDescriptor, ^(MTL::Library* pLibrary, NS::Error* pError) { blockCompletionHandler(pLibrary, pError); });
}

_MTL_INLINE MTL::LogState* MTL::Device::newLogState(const MTL::LogStateDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL::LogState*>(this, _MTL_PRIVATE_SEL(newLogStateWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE MTL4::CommandQueue* MTL::Device::newMTL4CommandQueue()
{
    return Object::sendMessage<MTL4::CommandQueue*>(this, _MTL_PRIVATE_SEL(newMTL4CommandQueue));
}

_MTL_INLINE MTL4::CommandQueue* MTL::Device::newMTL4CommandQueue(const MTL4::CommandQueueDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL4::CommandQueue*>(this, _MTL_PRIVATE_SEL(newMTL4CommandQueueWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE MTL4::PipelineDataSetSerializer* MTL::Device::newPipelineDataSetSerializer(const MTL4::PipelineDataSetSerializerDescriptor* descriptor)
{
    return Object::sendMessage<MTL4::PipelineDataSetSerializer*>(this, _MTL_PRIVATE_SEL(newPipelineDataSetSerializerWithDescriptor_), descriptor);
}

_MTL_INLINE MTL::RasterizationRateMap* MTL::Device::newRasterizationRateMap(const MTL::RasterizationRateMapDescriptor* descriptor)
{
    return Object::sendMessage<MTL::RasterizationRateMap*>(this, _MTL_PRIVATE_SEL(newRasterizationRateMapWithDescriptor_), descriptor);
}

_MTL_INLINE MTL::RenderPipelineState* MTL::Device::newRenderPipelineState(const MTL::RenderPipelineDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL::RenderPipelineState*>(this, _MTL_PRIVATE_SEL(newRenderPipelineStateWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE MTL::RenderPipelineState* MTL::Device::newRenderPipelineState(const MTL::RenderPipelineDescriptor* descriptor, MTL::PipelineOption options, const MTL::AutoreleasedRenderPipelineReflection* reflection, NS::Error** error)
{
    return Object::sendMessage<MTL::RenderPipelineState*>(this, _MTL_PRIVATE_SEL(newRenderPipelineStateWithDescriptor_options_reflection_error_), descriptor, options, reflection, error);
}

_MTL_INLINE void MTL::Device::newRenderPipelineState(const MTL::RenderPipelineDescriptor* descriptor, const MTL::NewRenderPipelineStateCompletionHandler completionHandler)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(newRenderPipelineStateWithDescriptor_completionHandler_), descriptor, completionHandler);
}

_MTL_INLINE void MTL::Device::newRenderPipelineState(const MTL::RenderPipelineDescriptor* descriptor, MTL::PipelineOption options, const MTL::NewRenderPipelineStateWithReflectionCompletionHandler completionHandler)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(newRenderPipelineStateWithDescriptor_options_completionHandler_), descriptor, options, completionHandler);
}

_MTL_INLINE MTL::RenderPipelineState* MTL::Device::newRenderPipelineState(const MTL::TileRenderPipelineDescriptor* descriptor, MTL::PipelineOption options, const MTL::AutoreleasedRenderPipelineReflection* reflection, NS::Error** error)
{
    return Object::sendMessage<MTL::RenderPipelineState*>(this, _MTL_PRIVATE_SEL(newRenderPipelineStateWithTileDescriptor_options_reflection_error_), descriptor, options, reflection, error);
}

_MTL_INLINE void MTL::Device::newRenderPipelineState(const MTL::TileRenderPipelineDescriptor* descriptor, MTL::PipelineOption options, const MTL::NewRenderPipelineStateWithReflectionCompletionHandler completionHandler)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(newRenderPipelineStateWithTileDescriptor_options_completionHandler_), descriptor, options, completionHandler);
}

_MTL_INLINE MTL::RenderPipelineState* MTL::Device::newRenderPipelineState(const MTL::MeshRenderPipelineDescriptor* descriptor, MTL::PipelineOption options, const MTL::AutoreleasedRenderPipelineReflection* reflection, NS::Error** error)
{
    return Object::sendMessage<MTL::RenderPipelineState*>(this, _MTL_PRIVATE_SEL(newRenderPipelineStateWithMeshDescriptor_options_reflection_error_), descriptor, options, reflection, error);
}

_MTL_INLINE void MTL::Device::newRenderPipelineState(const MTL::MeshRenderPipelineDescriptor* descriptor, MTL::PipelineOption options, const MTL::NewRenderPipelineStateWithReflectionCompletionHandler completionHandler)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(newRenderPipelineStateWithMeshDescriptor_options_completionHandler_), descriptor, options, completionHandler);
}

_MTL_INLINE void MTL::Device::newRenderPipelineState(const MTL::RenderPipelineDescriptor* pDescriptor, const MTL::NewRenderPipelineStateCompletionHandlerFunction& completionHandler)
{
    __block MTL::NewRenderPipelineStateCompletionHandlerFunction blockCompletionHandler = completionHandler;
    newRenderPipelineState(pDescriptor, ^(MTL::RenderPipelineState* pPipelineState, NS::Error* pError) { blockCompletionHandler(pPipelineState, pError); });
}

_MTL_INLINE void MTL::Device::newRenderPipelineState(const MTL::RenderPipelineDescriptor* pDescriptor, MTL::PipelineOption options, const MTL::NewRenderPipelineStateWithReflectionCompletionHandlerFunction& completionHandler)
{
    __block MTL::NewRenderPipelineStateWithReflectionCompletionHandlerFunction blockCompletionHandler = completionHandler;
    newRenderPipelineState(pDescriptor, options, ^(MTL::RenderPipelineState* pPipelineState, MTL::RenderPipelineReflection* pReflection, NS::Error* pError) { blockCompletionHandler(pPipelineState, pReflection, pError); });
}

_MTL_INLINE void MTL::Device::newRenderPipelineState(const MTL::TileRenderPipelineDescriptor* pDescriptor, MTL::PipelineOption options, const MTL::NewRenderPipelineStateWithReflectionCompletionHandlerFunction& completionHandler)
{
    __block MTL::NewRenderPipelineStateWithReflectionCompletionHandlerFunction blockCompletionHandler = completionHandler;
    newRenderPipelineState(pDescriptor, options, ^(MTL::RenderPipelineState* pPipelineState, MTL::RenderPipelineReflection* pReflection, NS::Error* pError) { blockCompletionHandler(pPipelineState, pReflection, pError); });
}

_MTL_INLINE MTL::ResidencySet* MTL::Device::newResidencySet(const MTL::ResidencySetDescriptor* desc, NS::Error** error)
{
    return Object::sendMessage<MTL::ResidencySet*>(this, _MTL_PRIVATE_SEL(newResidencySetWithDescriptor_error_), desc, error);
}

_MTL_INLINE MTL::SamplerState* MTL::Device::newSamplerState(const MTL::SamplerDescriptor* descriptor)
{
    return Object::sendMessage<MTL::SamplerState*>(this, _MTL_PRIVATE_SEL(newSamplerStateWithDescriptor_), descriptor);
}

_MTL_INLINE MTL::SharedEvent* MTL::Device::newSharedEvent()
{
    return Object::sendMessage<MTL::SharedEvent*>(this, _MTL_PRIVATE_SEL(newSharedEvent));
}

_MTL_INLINE MTL::SharedEvent* MTL::Device::newSharedEvent(const MTL::SharedEventHandle* sharedEventHandle)
{
    return Object::sendMessage<MTL::SharedEvent*>(this, _MTL_PRIVATE_SEL(newSharedEventWithHandle_), sharedEventHandle);
}

_MTL_INLINE MTL::Texture* MTL::Device::newSharedTexture(const MTL::TextureDescriptor* descriptor)
{
    return Object::sendMessage<MTL::Texture*>(this, _MTL_PRIVATE_SEL(newSharedTextureWithDescriptor_), descriptor);
}

_MTL_INLINE MTL::Texture* MTL::Device::newSharedTexture(const MTL::SharedTextureHandle* sharedHandle)
{
    return Object::sendMessage<MTL::Texture*>(this, _MTL_PRIVATE_SEL(newSharedTextureWithHandle_), sharedHandle);
}

_MTL_INLINE MTL::Tensor* MTL::Device::newTensor(const MTL::TensorDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL::Tensor*>(this, _MTL_PRIVATE_SEL(newTensorWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE MTL::Texture* MTL::Device::newTexture(const MTL::TextureDescriptor* descriptor)
{
    return Object::sendMessage<MTL::Texture*>(this, _MTL_PRIVATE_SEL(newTextureWithDescriptor_), descriptor);
}

_MTL_INLINE MTL::Texture* MTL::Device::newTexture(const MTL::TextureDescriptor* descriptor, const IOSurfaceRef iosurface, NS::UInteger plane)
{
    return Object::sendMessage<MTL::Texture*>(this, _MTL_PRIVATE_SEL(newTextureWithDescriptor_iosurface_plane_), descriptor, iosurface, plane);
}

_MTL_INLINE MTL::TextureViewPool* MTL::Device::newTextureViewPool(const MTL::ResourceViewPoolDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL::TextureViewPool*>(this, _MTL_PRIVATE_SEL(newTextureViewPoolWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE uint32_t MTL::Device::peerCount() const
{
    return Object::sendMessage<uint32_t>(this, _MTL_PRIVATE_SEL(peerCount));
}

_MTL_INLINE uint64_t MTL::Device::peerGroupID() const
{
    return Object::sendMessage<uint64_t>(this, _MTL_PRIVATE_SEL(peerGroupID));
}

_MTL_INLINE uint32_t MTL::Device::peerIndex() const
{
    return Object::sendMessage<uint32_t>(this, _MTL_PRIVATE_SEL(peerIndex));
}

_MTL_INLINE bool MTL::Device::programmableSamplePositionsSupported() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(areProgrammableSamplePositionsSupported));
}

_MTL_INLINE uint64_t MTL::Device::queryTimestampFrequency()
{
    return Object::sendMessage<uint64_t>(this, _MTL_PRIVATE_SEL(queryTimestampFrequency));
}

_MTL_INLINE bool MTL::Device::rasterOrderGroupsSupported() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(areRasterOrderGroupsSupported));
}

_MTL_INLINE MTL::ReadWriteTextureTier MTL::Device::readWriteTextureSupport() const
{
    return Object::sendMessage<MTL::ReadWriteTextureTier>(this, _MTL_PRIVATE_SEL(readWriteTextureSupport));
}

_MTL_INLINE uint64_t MTL::Device::recommendedMaxWorkingSetSize() const
{
    return Object::sendMessage<uint64_t>(this, _MTL_PRIVATE_SEL(recommendedMaxWorkingSetSize));
}

_MTL_INLINE uint64_t MTL::Device::registryID() const
{
    return Object::sendMessage<uint64_t>(this, _MTL_PRIVATE_SEL(registryID));
}

_MTL_INLINE bool MTL::Device::removable() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isRemovable));
}

_MTL_INLINE void MTL::Device::sampleTimestamps(MTL::Timestamp* cpuTimestamp, MTL::Timestamp* gpuTimestamp)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(sampleTimestamps_gpuTimestamp_), cpuTimestamp, gpuTimestamp);
}

_MTL_INLINE void MTL::Device::setShouldMaximizeConcurrentCompilation(bool shouldMaximizeConcurrentCompilation)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setShouldMaximizeConcurrentCompilation_), shouldMaximizeConcurrentCompilation);
}

_MTL_INLINE bool MTL::Device::shouldMaximizeConcurrentCompilation() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(shouldMaximizeConcurrentCompilation));
}

_MTL_INLINE NS::UInteger MTL::Device::sizeOfCounterHeapEntry(MTL4::CounterHeapType type)
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(sizeOfCounterHeapEntry_), type);
}

_MTL_INLINE MTL::Size MTL::Device::sparseTileSize(MTL::TextureType textureType, MTL::PixelFormat pixelFormat, NS::UInteger sampleCount)
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(sparseTileSizeWithTextureType_pixelFormat_sampleCount_), textureType, pixelFormat, sampleCount);
}

_MTL_INLINE MTL::Size MTL::Device::sparseTileSize(MTL::TextureType textureType, MTL::PixelFormat pixelFormat, NS::UInteger sampleCount, MTL::SparsePageSize sparsePageSize)
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(sparseTileSizeWithTextureType_pixelFormat_sampleCount_sparsePageSize_), textureType, pixelFormat, sampleCount, sparsePageSize);
}

_MTL_INLINE NS::UInteger MTL::Device::sparseTileSizeInBytes() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(sparseTileSizeInBytes));
}

_MTL_INLINE NS::UInteger MTL::Device::sparseTileSizeInBytes(MTL::SparsePageSize sparsePageSize)
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(sparseTileSizeInBytesForSparsePageSize_), sparsePageSize);
}

_MTL_INLINE bool MTL::Device::supports32BitFloatFiltering() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supports32BitFloatFiltering));
}

_MTL_INLINE bool MTL::Device::supports32BitMSAA() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supports32BitMSAA));
}

_MTL_INLINE bool MTL::Device::supportsBCTextureCompression() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportsBCTextureCompression));
}

_MTL_INLINE bool MTL::Device::supportsCounterSampling(MTL::CounterSamplingPoint samplingPoint)
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportsCounterSampling_), samplingPoint);
}

_MTL_INLINE bool MTL::Device::supportsDynamicLibraries() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportsDynamicLibraries));
}

_MTL_INLINE bool MTL::Device::supportsFamily(MTL::GPUFamily gpuFamily)
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportsFamily_), gpuFamily);
}

_MTL_INLINE bool MTL::Device::supportsFeatureSet(MTL::FeatureSet featureSet)
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportsFeatureSet_), featureSet);
}

_MTL_INLINE bool MTL::Device::supportsFunctionPointers() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportsFunctionPointers));
}

_MTL_INLINE bool MTL::Device::supportsFunctionPointersFromRender() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportsFunctionPointersFromRender));
}

_MTL_INLINE bool MTL::Device::supportsPrimitiveMotionBlur() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportsPrimitiveMotionBlur));
}

_MTL_INLINE bool MTL::Device::supportsPullModelInterpolation() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportsPullModelInterpolation));
}

_MTL_INLINE bool MTL::Device::supportsQueryTextureLOD() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportsQueryTextureLOD));
}

_MTL_INLINE bool MTL::Device::supportsRasterizationRateMap(NS::UInteger layerCount)
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportsRasterizationRateMapWithLayerCount_), layerCount);
}

_MTL_INLINE bool MTL::Device::supportsRaytracing() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportsRaytracing));
}

_MTL_INLINE bool MTL::Device::supportsRaytracingFromRender() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportsRaytracingFromRender));
}

_MTL_INLINE bool MTL::Device::supportsRenderDynamicLibraries() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportsRenderDynamicLibraries));
}

_MTL_INLINE bool MTL::Device::supportsShaderBarycentricCoordinates() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportsShaderBarycentricCoordinates));
}

_MTL_INLINE bool MTL::Device::supportsTextureSampleCount(NS::UInteger sampleCount)
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportsTextureSampleCount_), sampleCount);
}

_MTL_INLINE bool MTL::Device::supportsVertexAmplificationCount(NS::UInteger count)
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportsVertexAmplificationCount_), count);
}

_MTL_INLINE MTL::SizeAndAlign MTL::Device::tensorSizeAndAlign(const MTL::TensorDescriptor* descriptor)
{
    return Object::sendMessage<MTL::SizeAndAlign>(this, _MTL_PRIVATE_SEL(tensorSizeAndAlignWithDescriptor_), descriptor);
}

#pragma once

namespace MTL
{
class Device;
_MTL_ENUM(NS::UInteger, DynamicLibraryError) {
    DynamicLibraryErrorNone = 0,
    DynamicLibraryErrorInvalidFile = 1,
    DynamicLibraryErrorCompilationFailure = 2,
    DynamicLibraryErrorUnresolvedInstallName = 3,
    DynamicLibraryErrorDependencyLoadFailure = 4,
    DynamicLibraryErrorUnsupported = 5,
};

class DynamicLibrary : public NS::Referencing<DynamicLibrary>
{
public:
    Device*     device() const;

    NS::String* installName() const;

    NS::String* label() const;

    bool        serializeToURL(const NS::URL* url, NS::Error** error);

    void        setLabel(const NS::String* label);
};

}
_MTL_INLINE MTL::Device* MTL::DynamicLibrary::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE NS::String* MTL::DynamicLibrary::installName() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(installName));
}

_MTL_INLINE NS::String* MTL::DynamicLibrary::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE bool MTL::DynamicLibrary::serializeToURL(const NS::URL* url, NS::Error** error)
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(serializeToURL_error_), url, error);
}

_MTL_INLINE void MTL::DynamicLibrary::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

#pragma once

#include <cstdint>
#include <dispatch/dispatch.h>

#include <cstdint>
#include <functional>

namespace MTL
{
class Device;
class SharedEvent;
class SharedEventHandle;
class SharedEventListener;

using SharedEventNotificationBlock = void (^)(SharedEvent* pEvent, std::uint64_t value);
using SharedEventNotificationFunction = std::function<void(SharedEvent* pEvent, std::uint64_t value)>;

class Event : public NS::Referencing<Event>
{
public:
    Device*     device() const;

    NS::String* label() const;
    void        setLabel(const NS::String* label);
};
class SharedEventListener : public NS::Referencing<SharedEventListener>
{
public:
    static SharedEventListener* alloc();

    dispatch_queue_t            dispatchQueue() const;

    SharedEventListener*        init();
    SharedEventListener*        init(const dispatch_queue_t dispatchQueue);

    static SharedEventListener* sharedListener();
};
class SharedEvent : public NS::Referencing<SharedEvent, Event>
{
public:
    SharedEventHandle* newSharedEventHandle();

    void               notifyListener(const MTL::SharedEventListener* listener, uint64_t value, const MTL::SharedEventNotificationBlock block);
    void               notifyListener(const MTL::SharedEventListener* listener, uint64_t value, const MTL::SharedEventNotificationFunction& function);

    void               setSignaledValue(uint64_t signaledValue);
    uint64_t           signaledValue() const;
    bool               waitUntilSignaledValue(uint64_t value, uint64_t milliseconds);
};
class SharedEventHandle : public NS::SecureCoding<SharedEventHandle>
{
public:
    static SharedEventHandle* alloc();

    SharedEventHandle*        init();

    NS::String*               label() const;
};

}
_MTL_INLINE MTL::Device* MTL::Event::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE NS::String* MTL::Event::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE void MTL::Event::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE MTL::SharedEventListener* MTL::SharedEventListener::alloc()
{
    return NS::Object::alloc<MTL::SharedEventListener>(_MTL_PRIVATE_CLS(MTLSharedEventListener));
}

_MTL_INLINE dispatch_queue_t MTL::SharedEventListener::dispatchQueue() const
{
    return Object::sendMessage<dispatch_queue_t>(this, _MTL_PRIVATE_SEL(dispatchQueue));
}

_MTL_INLINE MTL::SharedEventListener* MTL::SharedEventListener::init()
{
    return NS::Object::init<MTL::SharedEventListener>();
}

_MTL_INLINE MTL::SharedEventListener* MTL::SharedEventListener::init(const dispatch_queue_t dispatchQueue)
{
    return Object::sendMessage<MTL::SharedEventListener*>(this, _MTL_PRIVATE_SEL(initWithDispatchQueue_), dispatchQueue);
}

_MTL_INLINE MTL::SharedEventListener* MTL::SharedEventListener::sharedListener()
{
    return Object::sendMessage<MTL::SharedEventListener*>(_MTL_PRIVATE_CLS(MTLSharedEventListener), _MTL_PRIVATE_SEL(sharedListener));
}

_MTL_INLINE MTL::SharedEventHandle* MTL::SharedEvent::newSharedEventHandle()
{
    return Object::sendMessage<MTL::SharedEventHandle*>(this, _MTL_PRIVATE_SEL(newSharedEventHandle));
}

_MTL_INLINE void MTL::SharedEvent::notifyListener(const MTL::SharedEventListener* listener, uint64_t value, const MTL::SharedEventNotificationBlock block)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(notifyListener_atValue_block_), listener, value, block);
}

_MTL_INLINE void MTL::SharedEvent::notifyListener(const MTL::SharedEventListener* listener, uint64_t value, const MTL::SharedEventNotificationFunction& function)
{
    __block MTL::SharedEventNotificationFunction callback = function;
    notifyListener(listener, value, ^void(SharedEvent* pEvent, std::uint64_t innerValue) { callback(pEvent, innerValue); });
}

_MTL_INLINE void MTL::SharedEvent::setSignaledValue(uint64_t signaledValue)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSignaledValue_), signaledValue);
}

_MTL_INLINE uint64_t MTL::SharedEvent::signaledValue() const
{
    return Object::sendMessage<uint64_t>(this, _MTL_PRIVATE_SEL(signaledValue));
}

_MTL_INLINE bool MTL::SharedEvent::waitUntilSignaledValue(uint64_t value, uint64_t milliseconds)
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(waitUntilSignaledValue_timeoutMS_), value, milliseconds);
}

_MTL_INLINE MTL::SharedEventHandle* MTL::SharedEventHandle::alloc()
{
    return NS::Object::alloc<MTL::SharedEventHandle>(_MTL_PRIVATE_CLS(MTLSharedEventHandle));
}

_MTL_INLINE MTL::SharedEventHandle* MTL::SharedEventHandle::init()
{
    return NS::Object::init<MTL::SharedEventHandle>();
}

_MTL_INLINE NS::String* MTL::SharedEventHandle::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

#pragma once

namespace MTL
{
class Device;

class Fence : public NS::Referencing<Fence>
{
public:
    Device*     device() const;

    NS::String* label() const;
    void        setLabel(const NS::String* label);
};

}
_MTL_INLINE MTL::Device* MTL::Fence::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE NS::String* MTL::Fence::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE void MTL::Fence::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

#pragma once

namespace MTL
{
class FunctionConstantValues;

class FunctionConstantValues : public NS::Copying<FunctionConstantValues>
{
public:
    static FunctionConstantValues* alloc();

    FunctionConstantValues*        init();

    void                           reset();

    void                           setConstantValue(const void* value, MTL::DataType type, NS::UInteger index);
    void                           setConstantValue(const void* value, MTL::DataType type, const NS::String* name);
    void                           setConstantValues(const void* values, MTL::DataType type, NS::Range range);
};

}
_MTL_INLINE MTL::FunctionConstantValues* MTL::FunctionConstantValues::alloc()
{
    return NS::Object::alloc<MTL::FunctionConstantValues>(_MTL_PRIVATE_CLS(MTLFunctionConstantValues));
}

_MTL_INLINE MTL::FunctionConstantValues* MTL::FunctionConstantValues::init()
{
    return NS::Object::init<MTL::FunctionConstantValues>();
}

_MTL_INLINE void MTL::FunctionConstantValues::reset()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(reset));
}

_MTL_INLINE void MTL::FunctionConstantValues::setConstantValue(const void* value, MTL::DataType type, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setConstantValue_type_atIndex_), value, type, index);
}

_MTL_INLINE void MTL::FunctionConstantValues::setConstantValue(const void* value, MTL::DataType type, const NS::String* name)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setConstantValue_type_withName_), value, type, name);
}

_MTL_INLINE void MTL::FunctionConstantValues::setConstantValues(const void* values, MTL::DataType type, NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setConstantValues_type_withRange_), values, type, range);
}

#pragma once

namespace MTL
{
class FunctionConstantValues;
class FunctionDescriptor;
class IntersectionFunctionDescriptor;

_MTL_OPTIONS(NS::UInteger, FunctionOptions) {
    FunctionOptionNone = 0,
    FunctionOptionCompileToBinary = 1,
    FunctionOptionStoreFunctionInMetalPipelinesScript = 1 << 1,
    FunctionOptionStoreFunctionInMetalScript = 1 << 1,
    FunctionOptionFailOnBinaryArchiveMiss = 1 << 2,
    FunctionOptionPipelineIndependent = 1 << 3,
};

class FunctionDescriptor : public NS::Copying<FunctionDescriptor>
{
public:
    static FunctionDescriptor* alloc();

    NS::Array*                 binaryArchives() const;

    FunctionConstantValues*    constantValues() const;

    static FunctionDescriptor* functionDescriptor();

    FunctionDescriptor*        init();

    NS::String*                name() const;

    FunctionOptions            options() const;

    void                       setBinaryArchives(const NS::Array* binaryArchives);

    void                       setConstantValues(const MTL::FunctionConstantValues* constantValues);

    void                       setName(const NS::String* name);

    void                       setOptions(MTL::FunctionOptions options);

    void                       setSpecializedName(const NS::String* specializedName);
    NS::String*                specializedName() const;
};
class IntersectionFunctionDescriptor : public NS::Copying<IntersectionFunctionDescriptor, FunctionDescriptor>
{
public:
    static IntersectionFunctionDescriptor* alloc();

    IntersectionFunctionDescriptor*        init();
};

}
_MTL_INLINE MTL::FunctionDescriptor* MTL::FunctionDescriptor::alloc()
{
    return NS::Object::alloc<MTL::FunctionDescriptor>(_MTL_PRIVATE_CLS(MTLFunctionDescriptor));
}

_MTL_INLINE NS::Array* MTL::FunctionDescriptor::binaryArchives() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(binaryArchives));
}

_MTL_INLINE MTL::FunctionConstantValues* MTL::FunctionDescriptor::constantValues() const
{
    return Object::sendMessage<MTL::FunctionConstantValues*>(this, _MTL_PRIVATE_SEL(constantValues));
}

_MTL_INLINE MTL::FunctionDescriptor* MTL::FunctionDescriptor::functionDescriptor()
{
    return Object::sendMessage<MTL::FunctionDescriptor*>(_MTL_PRIVATE_CLS(MTLFunctionDescriptor), _MTL_PRIVATE_SEL(functionDescriptor));
}

_MTL_INLINE MTL::FunctionDescriptor* MTL::FunctionDescriptor::init()
{
    return NS::Object::init<MTL::FunctionDescriptor>();
}

_MTL_INLINE NS::String* MTL::FunctionDescriptor::name() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(name));
}

_MTL_INLINE MTL::FunctionOptions MTL::FunctionDescriptor::options() const
{
    return Object::sendMessage<MTL::FunctionOptions>(this, _MTL_PRIVATE_SEL(options));
}

_MTL_INLINE void MTL::FunctionDescriptor::setBinaryArchives(const NS::Array* binaryArchives)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBinaryArchives_), binaryArchives);
}

_MTL_INLINE void MTL::FunctionDescriptor::setConstantValues(const MTL::FunctionConstantValues* constantValues)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setConstantValues_), constantValues);
}

_MTL_INLINE void MTL::FunctionDescriptor::setName(const NS::String* name)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setName_), name);
}

_MTL_INLINE void MTL::FunctionDescriptor::setOptions(MTL::FunctionOptions options)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setOptions_), options);
}

_MTL_INLINE void MTL::FunctionDescriptor::setSpecializedName(const NS::String* specializedName)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSpecializedName_), specializedName);
}

_MTL_INLINE NS::String* MTL::FunctionDescriptor::specializedName() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(specializedName));
}

_MTL_INLINE MTL::IntersectionFunctionDescriptor* MTL::IntersectionFunctionDescriptor::alloc()
{
    return NS::Object::alloc<MTL::IntersectionFunctionDescriptor>(_MTL_PRIVATE_CLS(MTLIntersectionFunctionDescriptor));
}

_MTL_INLINE MTL::IntersectionFunctionDescriptor* MTL::IntersectionFunctionDescriptor::init()
{
    return NS::Object::init<MTL::IntersectionFunctionDescriptor>();
}

#pragma once

#pragma once

namespace MTL
{
class Argument;
class ArgumentEncoder;
class Attribute;
class CompileOptions;
class Device;
class Function;
class FunctionConstant;
class FunctionConstantValues;
class FunctionDescriptor;
class FunctionReflection;
class IntersectionFunctionDescriptor;
class VertexAttribute;
_MTL_ENUM(NS::UInteger, PatchType) {
    PatchTypeNone = 0,
    PatchTypeTriangle = 1,
    PatchTypeQuad = 2,
};

_MTL_ENUM(NS::UInteger, FunctionType) {
    FunctionTypeVertex = 1,
    FunctionTypeFragment = 2,
    FunctionTypeKernel = 3,
    FunctionTypeVisible = 5,
    FunctionTypeIntersection = 6,
    FunctionTypeMesh = 7,
    FunctionTypeObject = 8,
};

_MTL_ENUM(NS::UInteger, LanguageVersion) {
    LanguageVersion1_0 = 65536,
    LanguageVersion1_1 = 65537,
    LanguageVersion1_2 = 65538,
    LanguageVersion2_0 = 131072,
    LanguageVersion2_1 = 131073,
    LanguageVersion2_2 = 131074,
    LanguageVersion2_3 = 131075,
    LanguageVersion2_4 = 131076,
    LanguageVersion3_0 = 196608,
    LanguageVersion3_1 = 196609,
    LanguageVersion3_2 = 196610,
    LanguageVersion4_0 = 262144,
};

_MTL_ENUM(NS::Integer, LibraryType) {
    LibraryTypeExecutable = 0,
    LibraryTypeDynamic = 1,
};

_MTL_ENUM(NS::Integer, LibraryOptimizationLevel) {
    LibraryOptimizationLevelDefault = 0,
    LibraryOptimizationLevelSize = 1,
};

_MTL_ENUM(NS::Integer, CompileSymbolVisibility) {
    CompileSymbolVisibilityDefault = 0,
    CompileSymbolVisibilityHidden = 1,
};

_MTL_ENUM(NS::Integer, MathMode) {
    MathModeSafe = 0,
    MathModeRelaxed = 1,
    MathModeFast = 2,
};

_MTL_ENUM(NS::Integer, MathFloatingPointFunctions) {
    MathFloatingPointFunctionsFast = 0,
    MathFloatingPointFunctionsPrecise = 1,
};

_MTL_ENUM(NS::UInteger, LibraryError) {
    LibraryErrorUnsupported = 1,
    LibraryErrorInternal = 2,
    LibraryErrorCompileFailure = 3,
    LibraryErrorCompileWarning = 4,
    LibraryErrorFunctionNotFound = 5,
    LibraryErrorFileNotFound = 6,
};

using AutoreleasedArgument = MTL::Argument*;
using FunctionCompletionHandlerFunction = std::function<void(MTL::Function* pFunction, NS::Error* pError)>;

class VertexAttribute : public NS::Referencing<VertexAttribute>
{
public:
    [[deprecated("please use isActive instead")]]
    bool                    active() const;

    static VertexAttribute* alloc();

    NS::UInteger            attributeIndex() const;

    DataType                attributeType() const;

    VertexAttribute*        init();

    bool                    isActive() const;

    bool                    isPatchControlPointData() const;

    bool                    isPatchData() const;

    NS::String*             name() const;

    [[deprecated("please use isPatchControlPointData instead")]]
    bool patchControlPointData() const;

    [[deprecated("please use isPatchData instead")]]
    bool patchData() const;
};
class Attribute : public NS::Referencing<Attribute>
{
public:
    [[deprecated("please use isActive instead")]]
    bool              active() const;

    static Attribute* alloc();

    NS::UInteger      attributeIndex() const;

    DataType          attributeType() const;

    Attribute*        init();

    bool              isActive() const;

    bool              isPatchControlPointData() const;

    bool              isPatchData() const;

    NS::String*       name() const;

    [[deprecated("please use isPatchControlPointData instead")]]
    bool patchControlPointData() const;

    [[deprecated("please use isPatchData instead")]]
    bool patchData() const;
};
class FunctionConstant : public NS::Referencing<FunctionConstant>
{
public:
    static FunctionConstant* alloc();

    NS::UInteger             index() const;

    FunctionConstant*        init();

    NS::String*              name() const;

    bool                     required() const;

    DataType                 type() const;
};
class Function : public NS::Referencing<Function>
{
public:
    Device*          device() const;

    NS::Dictionary*  functionConstantsDictionary() const;

    FunctionType     functionType() const;

    NS::String*      label() const;

    NS::String*      name() const;

    ArgumentEncoder* newArgumentEncoder(NS::UInteger bufferIndex);
    ArgumentEncoder* newArgumentEncoder(NS::UInteger bufferIndex, const MTL::AutoreleasedArgument* reflection);

    FunctionOptions  options() const;

    NS::Integer      patchControlPointCount() const;

    PatchType        patchType() const;

    void             setLabel(const NS::String* label);

    NS::Array*       stageInputAttributes() const;

    NS::Array*       vertexAttributes() const;
};
class CompileOptions : public NS::Copying<CompileOptions>
{
public:
    static CompileOptions*     alloc();

    bool                       allowReferencingUndefinedSymbols() const;

    CompileSymbolVisibility    compileSymbolVisibility() const;

    bool                       enableLogging() const;

    bool                       fastMathEnabled() const;

    CompileOptions*            init();

    NS::String*                installName() const;

    LanguageVersion            languageVersion() const;

    NS::Array*                 libraries() const;

    LibraryType                libraryType() const;

    MathFloatingPointFunctions mathFloatingPointFunctions() const;

    MathMode                   mathMode() const;

    NS::UInteger               maxTotalThreadsPerThreadgroup() const;

    LibraryOptimizationLevel   optimizationLevel() const;

    NS::Dictionary*            preprocessorMacros() const;

    bool                       preserveInvariance() const;

    Size                       requiredThreadsPerThreadgroup() const;

    void                       setAllowReferencingUndefinedSymbols(bool allowReferencingUndefinedSymbols);

    void                       setCompileSymbolVisibility(MTL::CompileSymbolVisibility compileSymbolVisibility);

    void                       setEnableLogging(bool enableLogging);

    void                       setFastMathEnabled(bool fastMathEnabled);

    void                       setInstallName(const NS::String* installName);

    void                       setLanguageVersion(MTL::LanguageVersion languageVersion);

    void                       setLibraries(const NS::Array* libraries);

    void                       setLibraryType(MTL::LibraryType libraryType);

    void                       setMathFloatingPointFunctions(MTL::MathFloatingPointFunctions mathFloatingPointFunctions);

    void                       setMathMode(MTL::MathMode mathMode);

    void                       setMaxTotalThreadsPerThreadgroup(NS::UInteger maxTotalThreadsPerThreadgroup);

    void                       setOptimizationLevel(MTL::LibraryOptimizationLevel optimizationLevel);

    void                       setPreprocessorMacros(const NS::Dictionary* preprocessorMacros);

    void                       setPreserveInvariance(bool preserveInvariance);

    void                       setRequiredThreadsPerThreadgroup(MTL::Size requiredThreadsPerThreadgroup);
};
class FunctionReflection : public NS::Referencing<FunctionReflection>
{
public:
    static FunctionReflection* alloc();

    NS::Array*                 bindings() const;

    FunctionReflection*        init();
};
class Library : public NS::Referencing<Library>
{
public:
    Device*             device() const;

    NS::Array*          functionNames() const;

    NS::String*         installName() const;

    NS::String*         label() const;

    Function*           newFunction(const NS::String* functionName);
    Function*           newFunction(const NS::String* name, const MTL::FunctionConstantValues* constantValues, NS::Error** error);
    void                newFunction(const NS::String* name, const MTL::FunctionConstantValues* constantValues, void (^completionHandler)(MTL::Function*, NS::Error*));
    void                newFunction(const MTL::FunctionDescriptor* descriptor, void (^completionHandler)(MTL::Function*, NS::Error*));
    Function*           newFunction(const MTL::FunctionDescriptor* descriptor, NS::Error** error);
    void                newFunction(const NS::String* pFunctionName, const MTL::FunctionConstantValues* pConstantValues, const MTL::FunctionCompletionHandlerFunction& completionHandler);
    void                newFunction(const MTL::FunctionDescriptor* pDescriptor, const MTL::FunctionCompletionHandlerFunction& completionHandler);

    void                newIntersectionFunction(const MTL::IntersectionFunctionDescriptor* descriptor, void (^completionHandler)(MTL::Function*, NS::Error*));
    Function*           newIntersectionFunction(const MTL::IntersectionFunctionDescriptor* descriptor, NS::Error** error);
    void                newIntersectionFunction(const MTL::IntersectionFunctionDescriptor* pDescriptor, const MTL::FunctionCompletionHandlerFunction& completionHandler);

    FunctionReflection* reflectionForFunction(const NS::String* functionName);

    void                setLabel(const NS::String* label);

    LibraryType         type() const;
};

}
_MTL_INLINE bool MTL::VertexAttribute::active() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isActive));
}

_MTL_INLINE MTL::VertexAttribute* MTL::VertexAttribute::alloc()
{
    return NS::Object::alloc<MTL::VertexAttribute>(_MTL_PRIVATE_CLS(MTLVertexAttribute));
}

_MTL_INLINE NS::UInteger MTL::VertexAttribute::attributeIndex() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(attributeIndex));
}

_MTL_INLINE MTL::DataType MTL::VertexAttribute::attributeType() const
{
    return Object::sendMessage<MTL::DataType>(this, _MTL_PRIVATE_SEL(attributeType));
}

_MTL_INLINE MTL::VertexAttribute* MTL::VertexAttribute::init()
{
    return NS::Object::init<MTL::VertexAttribute>();
}

_MTL_INLINE bool MTL::VertexAttribute::isActive() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isActive));
}

_MTL_INLINE bool MTL::VertexAttribute::isPatchControlPointData() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isPatchControlPointData));
}

_MTL_INLINE bool MTL::VertexAttribute::isPatchData() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isPatchData));
}

_MTL_INLINE NS::String* MTL::VertexAttribute::name() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(name));
}

_MTL_INLINE bool MTL::VertexAttribute::patchControlPointData() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isPatchControlPointData));
}

_MTL_INLINE bool MTL::VertexAttribute::patchData() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isPatchData));
}

_MTL_INLINE bool MTL::Attribute::active() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isActive));
}

_MTL_INLINE MTL::Attribute* MTL::Attribute::alloc()
{
    return NS::Object::alloc<MTL::Attribute>(_MTL_PRIVATE_CLS(MTLAttribute));
}

_MTL_INLINE NS::UInteger MTL::Attribute::attributeIndex() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(attributeIndex));
}

_MTL_INLINE MTL::DataType MTL::Attribute::attributeType() const
{
    return Object::sendMessage<MTL::DataType>(this, _MTL_PRIVATE_SEL(attributeType));
}

_MTL_INLINE MTL::Attribute* MTL::Attribute::init()
{
    return NS::Object::init<MTL::Attribute>();
}

_MTL_INLINE bool MTL::Attribute::isActive() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isActive));
}

_MTL_INLINE bool MTL::Attribute::isPatchControlPointData() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isPatchControlPointData));
}

_MTL_INLINE bool MTL::Attribute::isPatchData() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isPatchData));
}

_MTL_INLINE NS::String* MTL::Attribute::name() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(name));
}

_MTL_INLINE bool MTL::Attribute::patchControlPointData() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isPatchControlPointData));
}

_MTL_INLINE bool MTL::Attribute::patchData() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isPatchData));
}

_MTL_INLINE MTL::FunctionConstant* MTL::FunctionConstant::alloc()
{
    return NS::Object::alloc<MTL::FunctionConstant>(_MTL_PRIVATE_CLS(MTLFunctionConstant));
}

_MTL_INLINE NS::UInteger MTL::FunctionConstant::index() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(index));
}

_MTL_INLINE MTL::FunctionConstant* MTL::FunctionConstant::init()
{
    return NS::Object::init<MTL::FunctionConstant>();
}

_MTL_INLINE NS::String* MTL::FunctionConstant::name() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(name));
}

_MTL_INLINE bool MTL::FunctionConstant::required() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(required));
}

_MTL_INLINE MTL::DataType MTL::FunctionConstant::type() const
{
    return Object::sendMessage<MTL::DataType>(this, _MTL_PRIVATE_SEL(type));
}

_MTL_INLINE MTL::Device* MTL::Function::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE NS::Dictionary* MTL::Function::functionConstantsDictionary() const
{
    return Object::sendMessage<NS::Dictionary*>(this, _MTL_PRIVATE_SEL(functionConstantsDictionary));
}

_MTL_INLINE MTL::FunctionType MTL::Function::functionType() const
{
    return Object::sendMessage<MTL::FunctionType>(this, _MTL_PRIVATE_SEL(functionType));
}

_MTL_INLINE NS::String* MTL::Function::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE NS::String* MTL::Function::name() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(name));
}

_MTL_INLINE MTL::ArgumentEncoder* MTL::Function::newArgumentEncoder(NS::UInteger bufferIndex)
{
    return Object::sendMessage<MTL::ArgumentEncoder*>(this, _MTL_PRIVATE_SEL(newArgumentEncoderWithBufferIndex_), bufferIndex);
}

_MTL_INLINE MTL::ArgumentEncoder* MTL::Function::newArgumentEncoder(NS::UInteger bufferIndex, const MTL::AutoreleasedArgument* reflection)
{
    return Object::sendMessage<MTL::ArgumentEncoder*>(this, _MTL_PRIVATE_SEL(newArgumentEncoderWithBufferIndex_reflection_), bufferIndex, reflection);
}

_MTL_INLINE MTL::FunctionOptions MTL::Function::options() const
{
    return Object::sendMessage<MTL::FunctionOptions>(this, _MTL_PRIVATE_SEL(options));
}

_MTL_INLINE NS::Integer MTL::Function::patchControlPointCount() const
{
    return Object::sendMessage<NS::Integer>(this, _MTL_PRIVATE_SEL(patchControlPointCount));
}

_MTL_INLINE MTL::PatchType MTL::Function::patchType() const
{
    return Object::sendMessage<MTL::PatchType>(this, _MTL_PRIVATE_SEL(patchType));
}

_MTL_INLINE void MTL::Function::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE NS::Array* MTL::Function::stageInputAttributes() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(stageInputAttributes));
}

_MTL_INLINE NS::Array* MTL::Function::vertexAttributes() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(vertexAttributes));
}

_MTL_INLINE MTL::CompileOptions* MTL::CompileOptions::alloc()
{
    return NS::Object::alloc<MTL::CompileOptions>(_MTL_PRIVATE_CLS(MTLCompileOptions));
}

_MTL_INLINE bool MTL::CompileOptions::allowReferencingUndefinedSymbols() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(allowReferencingUndefinedSymbols));
}

_MTL_INLINE MTL::CompileSymbolVisibility MTL::CompileOptions::compileSymbolVisibility() const
{
    return Object::sendMessage<MTL::CompileSymbolVisibility>(this, _MTL_PRIVATE_SEL(compileSymbolVisibility));
}

_MTL_INLINE bool MTL::CompileOptions::enableLogging() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(enableLogging));
}

_MTL_INLINE bool MTL::CompileOptions::fastMathEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(fastMathEnabled));
}

_MTL_INLINE MTL::CompileOptions* MTL::CompileOptions::init()
{
    return NS::Object::init<MTL::CompileOptions>();
}

_MTL_INLINE NS::String* MTL::CompileOptions::installName() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(installName));
}

_MTL_INLINE MTL::LanguageVersion MTL::CompileOptions::languageVersion() const
{
    return Object::sendMessage<MTL::LanguageVersion>(this, _MTL_PRIVATE_SEL(languageVersion));
}

_MTL_INLINE NS::Array* MTL::CompileOptions::libraries() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(libraries));
}

_MTL_INLINE MTL::LibraryType MTL::CompileOptions::libraryType() const
{
    return Object::sendMessage<MTL::LibraryType>(this, _MTL_PRIVATE_SEL(libraryType));
}

_MTL_INLINE MTL::MathFloatingPointFunctions MTL::CompileOptions::mathFloatingPointFunctions() const
{
    return Object::sendMessage<MTL::MathFloatingPointFunctions>(this, _MTL_PRIVATE_SEL(mathFloatingPointFunctions));
}

_MTL_INLINE MTL::MathMode MTL::CompileOptions::mathMode() const
{
    return Object::sendMessage<MTL::MathMode>(this, _MTL_PRIVATE_SEL(mathMode));
}

_MTL_INLINE NS::UInteger MTL::CompileOptions::maxTotalThreadsPerThreadgroup() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxTotalThreadsPerThreadgroup));
}

_MTL_INLINE MTL::LibraryOptimizationLevel MTL::CompileOptions::optimizationLevel() const
{
    return Object::sendMessage<MTL::LibraryOptimizationLevel>(this, _MTL_PRIVATE_SEL(optimizationLevel));
}

_MTL_INLINE NS::Dictionary* MTL::CompileOptions::preprocessorMacros() const
{
    return Object::sendMessage<NS::Dictionary*>(this, _MTL_PRIVATE_SEL(preprocessorMacros));
}

_MTL_INLINE bool MTL::CompileOptions::preserveInvariance() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(preserveInvariance));
}

_MTL_INLINE MTL::Size MTL::CompileOptions::requiredThreadsPerThreadgroup() const
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(requiredThreadsPerThreadgroup));
}

_MTL_INLINE void MTL::CompileOptions::setAllowReferencingUndefinedSymbols(bool allowReferencingUndefinedSymbols)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setAllowReferencingUndefinedSymbols_), allowReferencingUndefinedSymbols);
}

_MTL_INLINE void MTL::CompileOptions::setCompileSymbolVisibility(MTL::CompileSymbolVisibility compileSymbolVisibility)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setCompileSymbolVisibility_), compileSymbolVisibility);
}

_MTL_INLINE void MTL::CompileOptions::setEnableLogging(bool enableLogging)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setEnableLogging_), enableLogging);
}

_MTL_INLINE void MTL::CompileOptions::setFastMathEnabled(bool fastMathEnabled)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFastMathEnabled_), fastMathEnabled);
}

_MTL_INLINE void MTL::CompileOptions::setInstallName(const NS::String* installName)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInstallName_), installName);
}

_MTL_INLINE void MTL::CompileOptions::setLanguageVersion(MTL::LanguageVersion languageVersion)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLanguageVersion_), languageVersion);
}

_MTL_INLINE void MTL::CompileOptions::setLibraries(const NS::Array* libraries)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLibraries_), libraries);
}

_MTL_INLINE void MTL::CompileOptions::setLibraryType(MTL::LibraryType libraryType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLibraryType_), libraryType);
}

_MTL_INLINE void MTL::CompileOptions::setMathFloatingPointFunctions(MTL::MathFloatingPointFunctions mathFloatingPointFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMathFloatingPointFunctions_), mathFloatingPointFunctions);
}

_MTL_INLINE void MTL::CompileOptions::setMathMode(MTL::MathMode mathMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMathMode_), mathMode);
}

_MTL_INLINE void MTL::CompileOptions::setMaxTotalThreadsPerThreadgroup(NS::UInteger maxTotalThreadsPerThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxTotalThreadsPerThreadgroup_), maxTotalThreadsPerThreadgroup);
}

_MTL_INLINE void MTL::CompileOptions::setOptimizationLevel(MTL::LibraryOptimizationLevel optimizationLevel)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setOptimizationLevel_), optimizationLevel);
}

_MTL_INLINE void MTL::CompileOptions::setPreprocessorMacros(const NS::Dictionary* preprocessorMacros)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPreprocessorMacros_), preprocessorMacros);
}

_MTL_INLINE void MTL::CompileOptions::setPreserveInvariance(bool preserveInvariance)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPreserveInvariance_), preserveInvariance);
}

_MTL_INLINE void MTL::CompileOptions::setRequiredThreadsPerThreadgroup(MTL::Size requiredThreadsPerThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRequiredThreadsPerThreadgroup_), requiredThreadsPerThreadgroup);
}

_MTL_INLINE MTL::FunctionReflection* MTL::FunctionReflection::alloc()
{
    return NS::Object::alloc<MTL::FunctionReflection>(_MTL_PRIVATE_CLS(MTLFunctionReflection));
}

_MTL_INLINE NS::Array* MTL::FunctionReflection::bindings() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(bindings));
}

_MTL_INLINE MTL::FunctionReflection* MTL::FunctionReflection::init()
{
    return NS::Object::init<MTL::FunctionReflection>();
}

_MTL_INLINE MTL::Device* MTL::Library::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE NS::Array* MTL::Library::functionNames() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(functionNames));
}

_MTL_INLINE NS::String* MTL::Library::installName() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(installName));
}

_MTL_INLINE NS::String* MTL::Library::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE MTL::Function* MTL::Library::newFunction(const NS::String* functionName)
{
    return Object::sendMessage<MTL::Function*>(this, _MTL_PRIVATE_SEL(newFunctionWithName_), functionName);
}

_MTL_INLINE MTL::Function* MTL::Library::newFunction(const NS::String* name, const MTL::FunctionConstantValues* constantValues, NS::Error** error)
{
    return Object::sendMessage<MTL::Function*>(this, _MTL_PRIVATE_SEL(newFunctionWithName_constantValues_error_), name, constantValues, error);
}

_MTL_INLINE void MTL::Library::newFunction(const NS::String* name, const MTL::FunctionConstantValues* constantValues, void (^completionHandler)(MTL::Function*, NS::Error*))
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(newFunctionWithName_constantValues_completionHandler_), name, constantValues, completionHandler);
}

_MTL_INLINE void MTL::Library::newFunction(const MTL::FunctionDescriptor* descriptor, void (^completionHandler)(MTL::Function*, NS::Error*))
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(newFunctionWithDescriptor_completionHandler_), descriptor, completionHandler);
}

_MTL_INLINE MTL::Function* MTL::Library::newFunction(const MTL::FunctionDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL::Function*>(this, _MTL_PRIVATE_SEL(newFunctionWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE void MTL::Library::newFunction(const NS::String* pFunctionName, const MTL::FunctionConstantValues* pConstantValues, const MTL::FunctionCompletionHandlerFunction& completionHandler)
{
    __block MTL::FunctionCompletionHandlerFunction blockCompletionHandler = completionHandler;
    newFunction(pFunctionName, pConstantValues, ^(MTL::Function* pFunction, NS::Error* pError) { blockCompletionHandler(pFunction, pError); });
}

_MTL_INLINE void MTL::Library::newFunction(const MTL::FunctionDescriptor* pDescriptor, const MTL::FunctionCompletionHandlerFunction& completionHandler)
{
    __block MTL::FunctionCompletionHandlerFunction blockCompletionHandler = completionHandler;
    newFunction(pDescriptor, ^(MTL::Function* pFunction, NS::Error* pError) { blockCompletionHandler(pFunction, pError); });
}

_MTL_INLINE void MTL::Library::newIntersectionFunction(const MTL::IntersectionFunctionDescriptor* descriptor, void (^completionHandler)(MTL::Function*, NS::Error*))
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(newIntersectionFunctionWithDescriptor_completionHandler_), descriptor, completionHandler);
}

_MTL_INLINE MTL::Function* MTL::Library::newIntersectionFunction(const MTL::IntersectionFunctionDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL::Function*>(this, _MTL_PRIVATE_SEL(newIntersectionFunctionWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE void MTL::Library::newIntersectionFunction(const MTL::IntersectionFunctionDescriptor* pDescriptor, const MTL::FunctionCompletionHandlerFunction& completionHandler)
{
    __block MTL::FunctionCompletionHandlerFunction blockCompletionHandler = completionHandler;
    newIntersectionFunction(pDescriptor, ^(MTL::Function* pFunction, NS::Error* pError) { blockCompletionHandler(pFunction, pError); });
}

_MTL_INLINE MTL::FunctionReflection* MTL::Library::reflectionForFunction(const NS::String* functionName)
{
    return Object::sendMessage<MTL::FunctionReflection*>(this, _MTL_PRIVATE_SEL(reflectionForFunctionWithName_), functionName);
}

_MTL_INLINE void MTL::Library::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE MTL::LibraryType MTL::Library::type() const
{
    return Object::sendMessage<MTL::LibraryType>(this, _MTL_PRIVATE_SEL(type));
}

namespace MTL
{
class Device;

class FunctionHandle : public NS::Referencing<FunctionHandle>
{
public:
    Device*      device() const;

    FunctionType functionType() const;

    ResourceID   gpuResourceID() const;

    NS::String*  name() const;
};

}
_MTL_INLINE MTL::Device* MTL::FunctionHandle::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE MTL::FunctionType MTL::FunctionHandle::functionType() const
{
    return Object::sendMessage<MTL::FunctionType>(this, _MTL_PRIVATE_SEL(functionType));
}

_MTL_INLINE MTL::ResourceID MTL::FunctionHandle::gpuResourceID() const
{
    return Object::sendMessage<MTL::ResourceID>(this, _MTL_PRIVATE_SEL(gpuResourceID));
}

_MTL_INLINE NS::String* MTL::FunctionHandle::name() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(name));
}

#pragma once

namespace MTL
{
class Function;
class FunctionLogDebugLocation;
_MTL_ENUM(NS::UInteger, FunctionLogType) {
    FunctionLogTypeValidation = 0,
};

class LogContainer : public NS::Referencing<LogContainer, NS::FastEnumeration>
{
};
class FunctionLogDebugLocation : public NS::Referencing<FunctionLogDebugLocation>
{
public:
    NS::URL*     URL() const;

    NS::UInteger column() const;

    NS::String*  functionName() const;

    NS::UInteger line() const;
};
class FunctionLog : public NS::Referencing<FunctionLog>
{
public:
    FunctionLogDebugLocation* debugLocation() const;

    NS::String*               encoderLabel() const;

    Function*                 function() const;

    FunctionLogType           type() const;
};

}
_MTL_INLINE NS::URL* MTL::FunctionLogDebugLocation::URL() const
{
    return Object::sendMessage<NS::URL*>(this, _MTL_PRIVATE_SEL(URL));
}

_MTL_INLINE NS::UInteger MTL::FunctionLogDebugLocation::column() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(column));
}

_MTL_INLINE NS::String* MTL::FunctionLogDebugLocation::functionName() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(functionName));
}

_MTL_INLINE NS::UInteger MTL::FunctionLogDebugLocation::line() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(line));
}

_MTL_INLINE MTL::FunctionLogDebugLocation* MTL::FunctionLog::debugLocation() const
{
    return Object::sendMessage<MTL::FunctionLogDebugLocation*>(this, _MTL_PRIVATE_SEL(debugLocation));
}

_MTL_INLINE NS::String* MTL::FunctionLog::encoderLabel() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(encoderLabel));
}

_MTL_INLINE MTL::Function* MTL::FunctionLog::function() const
{
    return Object::sendMessage<MTL::Function*>(this, _MTL_PRIVATE_SEL(function));
}

_MTL_INLINE MTL::FunctionLogType MTL::FunctionLog::type() const
{
    return Object::sendMessage<MTL::FunctionLogType>(this, _MTL_PRIVATE_SEL(type));
}

#pragma once

namespace MTL
{
class FunctionStitchingAttributeAlwaysInline;
class FunctionStitchingFunctionNode;
class FunctionStitchingGraph;
class FunctionStitchingInputNode;
class StitchedLibraryDescriptor;

_MTL_OPTIONS(NS::UInteger, StitchedLibraryOptions) {
    StitchedLibraryOptionNone = 0,
    StitchedLibraryOptionFailOnBinaryArchiveMiss = 1,
    StitchedLibraryOptionStoreLibraryInMetalPipelinesScript = 1 << 1,
};

class FunctionStitchingAttribute : public NS::Referencing<FunctionStitchingAttribute>
{
};
class FunctionStitchingAttributeAlwaysInline : public NS::Referencing<FunctionStitchingAttributeAlwaysInline, FunctionStitchingAttribute>
{
public:
    static FunctionStitchingAttributeAlwaysInline* alloc();

    FunctionStitchingAttributeAlwaysInline*        init();
};
class FunctionStitchingNode : public NS::Copying<FunctionStitchingNode>
{
};
class FunctionStitchingInputNode : public NS::Referencing<FunctionStitchingInputNode, FunctionStitchingNode>
{
public:
    static FunctionStitchingInputNode* alloc();

    NS::UInteger                       argumentIndex() const;

    FunctionStitchingInputNode*        init();
    FunctionStitchingInputNode*        init(NS::UInteger argument);

    void                               setArgumentIndex(NS::UInteger argumentIndex);
};
class FunctionStitchingFunctionNode : public NS::Referencing<FunctionStitchingFunctionNode, FunctionStitchingNode>
{
public:
    static FunctionStitchingFunctionNode* alloc();

    NS::Array*                            arguments() const;

    NS::Array*                            controlDependencies() const;

    FunctionStitchingFunctionNode*        init();
    FunctionStitchingFunctionNode*        init(const NS::String* name, const NS::Array* arguments, const NS::Array* controlDependencies);

    NS::String*                           name() const;

    void                                  setArguments(const NS::Array* arguments);

    void                                  setControlDependencies(const NS::Array* controlDependencies);

    void                                  setName(const NS::String* name);
};
class FunctionStitchingGraph : public NS::Copying<FunctionStitchingGraph>
{
public:
    static FunctionStitchingGraph* alloc();

    NS::Array*                     attributes() const;

    NS::String*                    functionName() const;

    FunctionStitchingGraph*        init();
    FunctionStitchingGraph*        init(const NS::String* functionName, const NS::Array* nodes, const MTL::FunctionStitchingFunctionNode* outputNode, const NS::Array* attributes);

    NS::Array*                     nodes() const;

    FunctionStitchingFunctionNode* outputNode() const;

    void                           setAttributes(const NS::Array* attributes);

    void                           setFunctionName(const NS::String* functionName);

    void                           setNodes(const NS::Array* nodes);

    void                           setOutputNode(const MTL::FunctionStitchingFunctionNode* outputNode);
};
class StitchedLibraryDescriptor : public NS::Copying<StitchedLibraryDescriptor>
{
public:
    static StitchedLibraryDescriptor* alloc();

    NS::Array*                        binaryArchives() const;

    NS::Array*                        functionGraphs() const;

    NS::Array*                        functions() const;

    StitchedLibraryDescriptor*        init();

    StitchedLibraryOptions            options() const;

    void                              setBinaryArchives(const NS::Array* binaryArchives);

    void                              setFunctionGraphs(const NS::Array* functionGraphs);

    void                              setFunctions(const NS::Array* functions);

    void                              setOptions(MTL::StitchedLibraryOptions options);
};

}
_MTL_INLINE MTL::FunctionStitchingAttributeAlwaysInline* MTL::FunctionStitchingAttributeAlwaysInline::alloc()
{
    return NS::Object::alloc<MTL::FunctionStitchingAttributeAlwaysInline>(_MTL_PRIVATE_CLS(MTLFunctionStitchingAttributeAlwaysInline));
}

_MTL_INLINE MTL::FunctionStitchingAttributeAlwaysInline* MTL::FunctionStitchingAttributeAlwaysInline::init()
{
    return NS::Object::init<MTL::FunctionStitchingAttributeAlwaysInline>();
}

_MTL_INLINE MTL::FunctionStitchingInputNode* MTL::FunctionStitchingInputNode::alloc()
{
    return NS::Object::alloc<MTL::FunctionStitchingInputNode>(_MTL_PRIVATE_CLS(MTLFunctionStitchingInputNode));
}

_MTL_INLINE NS::UInteger MTL::FunctionStitchingInputNode::argumentIndex() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(argumentIndex));
}

_MTL_INLINE MTL::FunctionStitchingInputNode* MTL::FunctionStitchingInputNode::init()
{
    return NS::Object::init<MTL::FunctionStitchingInputNode>();
}

_MTL_INLINE MTL::FunctionStitchingInputNode* MTL::FunctionStitchingInputNode::init(NS::UInteger argument)
{
    return Object::sendMessage<MTL::FunctionStitchingInputNode*>(this, _MTL_PRIVATE_SEL(initWithArgumentIndex_), argument);
}

_MTL_INLINE void MTL::FunctionStitchingInputNode::setArgumentIndex(NS::UInteger argumentIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setArgumentIndex_), argumentIndex);
}

_MTL_INLINE MTL::FunctionStitchingFunctionNode* MTL::FunctionStitchingFunctionNode::alloc()
{
    return NS::Object::alloc<MTL::FunctionStitchingFunctionNode>(_MTL_PRIVATE_CLS(MTLFunctionStitchingFunctionNode));
}

_MTL_INLINE NS::Array* MTL::FunctionStitchingFunctionNode::arguments() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(arguments));
}

_MTL_INLINE NS::Array* MTL::FunctionStitchingFunctionNode::controlDependencies() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(controlDependencies));
}

_MTL_INLINE MTL::FunctionStitchingFunctionNode* MTL::FunctionStitchingFunctionNode::init()
{
    return NS::Object::init<MTL::FunctionStitchingFunctionNode>();
}

_MTL_INLINE MTL::FunctionStitchingFunctionNode* MTL::FunctionStitchingFunctionNode::init(const NS::String* name, const NS::Array* arguments, const NS::Array* controlDependencies)
{
    return Object::sendMessage<MTL::FunctionStitchingFunctionNode*>(this, _MTL_PRIVATE_SEL(initWithName_arguments_controlDependencies_), name, arguments, controlDependencies);
}

_MTL_INLINE NS::String* MTL::FunctionStitchingFunctionNode::name() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(name));
}

_MTL_INLINE void MTL::FunctionStitchingFunctionNode::setArguments(const NS::Array* arguments)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setArguments_), arguments);
}

_MTL_INLINE void MTL::FunctionStitchingFunctionNode::setControlDependencies(const NS::Array* controlDependencies)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setControlDependencies_), controlDependencies);
}

_MTL_INLINE void MTL::FunctionStitchingFunctionNode::setName(const NS::String* name)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setName_), name);
}

_MTL_INLINE MTL::FunctionStitchingGraph* MTL::FunctionStitchingGraph::alloc()
{
    return NS::Object::alloc<MTL::FunctionStitchingGraph>(_MTL_PRIVATE_CLS(MTLFunctionStitchingGraph));
}

_MTL_INLINE NS::Array* MTL::FunctionStitchingGraph::attributes() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(attributes));
}

_MTL_INLINE NS::String* MTL::FunctionStitchingGraph::functionName() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(functionName));
}

_MTL_INLINE MTL::FunctionStitchingGraph* MTL::FunctionStitchingGraph::init()
{
    return NS::Object::init<MTL::FunctionStitchingGraph>();
}

_MTL_INLINE MTL::FunctionStitchingGraph* MTL::FunctionStitchingGraph::init(const NS::String* functionName, const NS::Array* nodes, const MTL::FunctionStitchingFunctionNode* outputNode, const NS::Array* attributes)
{
    return Object::sendMessage<MTL::FunctionStitchingGraph*>(this, _MTL_PRIVATE_SEL(initWithFunctionName_nodes_outputNode_attributes_), functionName, nodes, outputNode, attributes);
}

_MTL_INLINE NS::Array* MTL::FunctionStitchingGraph::nodes() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(nodes));
}

_MTL_INLINE MTL::FunctionStitchingFunctionNode* MTL::FunctionStitchingGraph::outputNode() const
{
    return Object::sendMessage<MTL::FunctionStitchingFunctionNode*>(this, _MTL_PRIVATE_SEL(outputNode));
}

_MTL_INLINE void MTL::FunctionStitchingGraph::setAttributes(const NS::Array* attributes)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setAttributes_), attributes);
}

_MTL_INLINE void MTL::FunctionStitchingGraph::setFunctionName(const NS::String* functionName)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFunctionName_), functionName);
}

_MTL_INLINE void MTL::FunctionStitchingGraph::setNodes(const NS::Array* nodes)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setNodes_), nodes);
}

_MTL_INLINE void MTL::FunctionStitchingGraph::setOutputNode(const MTL::FunctionStitchingFunctionNode* outputNode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setOutputNode_), outputNode);
}

_MTL_INLINE MTL::StitchedLibraryDescriptor* MTL::StitchedLibraryDescriptor::alloc()
{
    return NS::Object::alloc<MTL::StitchedLibraryDescriptor>(_MTL_PRIVATE_CLS(MTLStitchedLibraryDescriptor));
}

_MTL_INLINE NS::Array* MTL::StitchedLibraryDescriptor::binaryArchives() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(binaryArchives));
}

_MTL_INLINE NS::Array* MTL::StitchedLibraryDescriptor::functionGraphs() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(functionGraphs));
}

_MTL_INLINE NS::Array* MTL::StitchedLibraryDescriptor::functions() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(functions));
}

_MTL_INLINE MTL::StitchedLibraryDescriptor* MTL::StitchedLibraryDescriptor::init()
{
    return NS::Object::init<MTL::StitchedLibraryDescriptor>();
}

_MTL_INLINE MTL::StitchedLibraryOptions MTL::StitchedLibraryDescriptor::options() const
{
    return Object::sendMessage<MTL::StitchedLibraryOptions>(this, _MTL_PRIVATE_SEL(options));
}

_MTL_INLINE void MTL::StitchedLibraryDescriptor::setBinaryArchives(const NS::Array* binaryArchives)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBinaryArchives_), binaryArchives);
}

_MTL_INLINE void MTL::StitchedLibraryDescriptor::setFunctionGraphs(const NS::Array* functionGraphs)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFunctionGraphs_), functionGraphs);
}

_MTL_INLINE void MTL::StitchedLibraryDescriptor::setFunctions(const NS::Array* functions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFunctions_), functions);
}

_MTL_INLINE void MTL::StitchedLibraryDescriptor::setOptions(MTL::StitchedLibraryOptions options)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setOptions_), options);
}

#pragma once

namespace MTL
{
class AccelerationStructure;
class AccelerationStructureDescriptor;
class Buffer;
class Device;
class HeapDescriptor;
class Texture;
class TextureDescriptor;
_MTL_ENUM(NS::Integer, HeapType) {
    HeapTypeAutomatic = 0,
    HeapTypePlacement = 1,
    HeapTypeSparse = 2,
};

class HeapDescriptor : public NS::Copying<HeapDescriptor>
{
public:
    static HeapDescriptor* alloc();

    CPUCacheMode           cpuCacheMode() const;

    HazardTrackingMode     hazardTrackingMode() const;

    HeapDescriptor*        init();

    SparsePageSize         maxCompatiblePlacementSparsePageSize() const;

    ResourceOptions        resourceOptions() const;

    void                   setCpuCacheMode(MTL::CPUCacheMode cpuCacheMode);

    void                   setHazardTrackingMode(MTL::HazardTrackingMode hazardTrackingMode);

    void                   setMaxCompatiblePlacementSparsePageSize(MTL::SparsePageSize maxCompatiblePlacementSparsePageSize);

    void                   setResourceOptions(MTL::ResourceOptions resourceOptions);

    void                   setSize(NS::UInteger size);

    void                   setSparsePageSize(MTL::SparsePageSize sparsePageSize);

    void                   setStorageMode(MTL::StorageMode storageMode);

    void                   setType(MTL::HeapType type);

    NS::UInteger           size() const;
    SparsePageSize         sparsePageSize() const;

    StorageMode            storageMode() const;

    HeapType               type() const;
};
class Heap : public NS::Referencing<Heap, Allocation>
{
public:
    CPUCacheMode           cpuCacheMode() const;

    NS::UInteger           currentAllocatedSize() const;

    Device*                device() const;

    HazardTrackingMode     hazardTrackingMode() const;

    NS::String*            label() const;

    NS::UInteger           maxAvailableSize(NS::UInteger alignment);

    AccelerationStructure* newAccelerationStructure(NS::UInteger size);
    AccelerationStructure* newAccelerationStructure(const MTL::AccelerationStructureDescriptor* descriptor);
    AccelerationStructure* newAccelerationStructure(NS::UInteger size, NS::UInteger offset);
    AccelerationStructure* newAccelerationStructure(const MTL::AccelerationStructureDescriptor* descriptor, NS::UInteger offset);

    Buffer*                newBuffer(NS::UInteger length, MTL::ResourceOptions options);
    Buffer*                newBuffer(NS::UInteger length, MTL::ResourceOptions options, NS::UInteger offset);

    Texture*               newTexture(const MTL::TextureDescriptor* descriptor);
    Texture*               newTexture(const MTL::TextureDescriptor* descriptor, NS::UInteger offset);

    ResourceOptions        resourceOptions() const;

    void                   setLabel(const NS::String* label);

    PurgeableState         setPurgeableState(MTL::PurgeableState state);

    NS::UInteger           size() const;

    StorageMode            storageMode() const;

    HeapType               type() const;

    NS::UInteger           usedSize() const;
};

}
_MTL_INLINE MTL::HeapDescriptor* MTL::HeapDescriptor::alloc()
{
    return NS::Object::alloc<MTL::HeapDescriptor>(_MTL_PRIVATE_CLS(MTLHeapDescriptor));
}

_MTL_INLINE MTL::CPUCacheMode MTL::HeapDescriptor::cpuCacheMode() const
{
    return Object::sendMessage<MTL::CPUCacheMode>(this, _MTL_PRIVATE_SEL(cpuCacheMode));
}

_MTL_INLINE MTL::HazardTrackingMode MTL::HeapDescriptor::hazardTrackingMode() const
{
    return Object::sendMessage<MTL::HazardTrackingMode>(this, _MTL_PRIVATE_SEL(hazardTrackingMode));
}

_MTL_INLINE MTL::HeapDescriptor* MTL::HeapDescriptor::init()
{
    return NS::Object::init<MTL::HeapDescriptor>();
}

_MTL_INLINE MTL::SparsePageSize MTL::HeapDescriptor::maxCompatiblePlacementSparsePageSize() const
{
    return Object::sendMessage<MTL::SparsePageSize>(this, _MTL_PRIVATE_SEL(maxCompatiblePlacementSparsePageSize));
}

_MTL_INLINE MTL::ResourceOptions MTL::HeapDescriptor::resourceOptions() const
{
    return Object::sendMessage<MTL::ResourceOptions>(this, _MTL_PRIVATE_SEL(resourceOptions));
}

_MTL_INLINE void MTL::HeapDescriptor::setCpuCacheMode(MTL::CPUCacheMode cpuCacheMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setCpuCacheMode_), cpuCacheMode);
}

_MTL_INLINE void MTL::HeapDescriptor::setHazardTrackingMode(MTL::HazardTrackingMode hazardTrackingMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setHazardTrackingMode_), hazardTrackingMode);
}

_MTL_INLINE void MTL::HeapDescriptor::setMaxCompatiblePlacementSparsePageSize(MTL::SparsePageSize maxCompatiblePlacementSparsePageSize)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxCompatiblePlacementSparsePageSize_), maxCompatiblePlacementSparsePageSize);
}

_MTL_INLINE void MTL::HeapDescriptor::setResourceOptions(MTL::ResourceOptions resourceOptions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setResourceOptions_), resourceOptions);
}

_MTL_INLINE void MTL::HeapDescriptor::setSize(NS::UInteger size)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSize_), size);
}

_MTL_INLINE void MTL::HeapDescriptor::setSparsePageSize(MTL::SparsePageSize sparsePageSize)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSparsePageSize_), sparsePageSize);
}

_MTL_INLINE void MTL::HeapDescriptor::setStorageMode(MTL::StorageMode storageMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStorageMode_), storageMode);
}

_MTL_INLINE void MTL::HeapDescriptor::setType(MTL::HeapType type)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setType_), type);
}

_MTL_INLINE NS::UInteger MTL::HeapDescriptor::size() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(size));
}

_MTL_INLINE MTL::SparsePageSize MTL::HeapDescriptor::sparsePageSize() const
{
    return Object::sendMessage<MTL::SparsePageSize>(this, _MTL_PRIVATE_SEL(sparsePageSize));
}

_MTL_INLINE MTL::StorageMode MTL::HeapDescriptor::storageMode() const
{
    return Object::sendMessage<MTL::StorageMode>(this, _MTL_PRIVATE_SEL(storageMode));
}

_MTL_INLINE MTL::HeapType MTL::HeapDescriptor::type() const
{
    return Object::sendMessage<MTL::HeapType>(this, _MTL_PRIVATE_SEL(type));
}

_MTL_INLINE MTL::CPUCacheMode MTL::Heap::cpuCacheMode() const
{
    return Object::sendMessage<MTL::CPUCacheMode>(this, _MTL_PRIVATE_SEL(cpuCacheMode));
}

_MTL_INLINE NS::UInteger MTL::Heap::currentAllocatedSize() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(currentAllocatedSize));
}

_MTL_INLINE MTL::Device* MTL::Heap::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE MTL::HazardTrackingMode MTL::Heap::hazardTrackingMode() const
{
    return Object::sendMessage<MTL::HazardTrackingMode>(this, _MTL_PRIVATE_SEL(hazardTrackingMode));
}

_MTL_INLINE NS::String* MTL::Heap::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE NS::UInteger MTL::Heap::maxAvailableSize(NS::UInteger alignment)
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxAvailableSizeWithAlignment_), alignment);
}

_MTL_INLINE MTL::AccelerationStructure* MTL::Heap::newAccelerationStructure(NS::UInteger size)
{
    return Object::sendMessage<MTL::AccelerationStructure*>(this, _MTL_PRIVATE_SEL(newAccelerationStructureWithSize_), size);
}

_MTL_INLINE MTL::AccelerationStructure* MTL::Heap::newAccelerationStructure(const MTL::AccelerationStructureDescriptor* descriptor)
{
    return Object::sendMessage<MTL::AccelerationStructure*>(this, _MTL_PRIVATE_SEL(newAccelerationStructureWithDescriptor_), descriptor);
}

_MTL_INLINE MTL::AccelerationStructure* MTL::Heap::newAccelerationStructure(NS::UInteger size, NS::UInteger offset)
{
    return Object::sendMessage<MTL::AccelerationStructure*>(this, _MTL_PRIVATE_SEL(newAccelerationStructureWithSize_offset_), size, offset);
}

_MTL_INLINE MTL::AccelerationStructure* MTL::Heap::newAccelerationStructure(const MTL::AccelerationStructureDescriptor* descriptor, NS::UInteger offset)
{
    return Object::sendMessage<MTL::AccelerationStructure*>(this, _MTL_PRIVATE_SEL(newAccelerationStructureWithDescriptor_offset_), descriptor, offset);
}

_MTL_INLINE MTL::Buffer* MTL::Heap::newBuffer(NS::UInteger length, MTL::ResourceOptions options)
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(newBufferWithLength_options_), length, options);
}

_MTL_INLINE MTL::Buffer* MTL::Heap::newBuffer(NS::UInteger length, MTL::ResourceOptions options, NS::UInteger offset)
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(newBufferWithLength_options_offset_), length, options, offset);
}

_MTL_INLINE MTL::Texture* MTL::Heap::newTexture(const MTL::TextureDescriptor* descriptor)
{
    return Object::sendMessage<MTL::Texture*>(this, _MTL_PRIVATE_SEL(newTextureWithDescriptor_), descriptor);
}

_MTL_INLINE MTL::Texture* MTL::Heap::newTexture(const MTL::TextureDescriptor* descriptor, NS::UInteger offset)
{
    return Object::sendMessage<MTL::Texture*>(this, _MTL_PRIVATE_SEL(newTextureWithDescriptor_offset_), descriptor, offset);
}

_MTL_INLINE MTL::ResourceOptions MTL::Heap::resourceOptions() const
{
    return Object::sendMessage<MTL::ResourceOptions>(this, _MTL_PRIVATE_SEL(resourceOptions));
}

_MTL_INLINE void MTL::Heap::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE MTL::PurgeableState MTL::Heap::setPurgeableState(MTL::PurgeableState state)
{
    return Object::sendMessage<MTL::PurgeableState>(this, _MTL_PRIVATE_SEL(setPurgeableState_), state);
}

_MTL_INLINE NS::UInteger MTL::Heap::size() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(size));
}

_MTL_INLINE MTL::StorageMode MTL::Heap::storageMode() const
{
    return Object::sendMessage<MTL::StorageMode>(this, _MTL_PRIVATE_SEL(storageMode));
}

_MTL_INLINE MTL::HeapType MTL::Heap::type() const
{
    return Object::sendMessage<MTL::HeapType>(this, _MTL_PRIVATE_SEL(type));
}

_MTL_INLINE NS::UInteger MTL::Heap::usedSize() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(usedSize));
}

#pragma once

#include <cstdint>

namespace MTL
{
class IndirectCommandBufferDescriptor;
class IndirectComputeCommand;
class IndirectRenderCommand;

_MTL_OPTIONS(NS::UInteger, IndirectCommandType) {
    IndirectCommandTypeDraw = 1,
    IndirectCommandTypeDrawIndexed = 1 << 1,
    IndirectCommandTypeDrawPatches = 1 << 2,
    IndirectCommandTypeDrawIndexedPatches = 1 << 3,
    IndirectCommandTypeConcurrentDispatch = 1 << 5,
    IndirectCommandTypeConcurrentDispatchThreads = 1 << 6,
    IndirectCommandTypeDrawMeshThreadgroups = 1 << 7,
    IndirectCommandTypeDrawMeshThreads = 1 << 8,
};

struct IndirectCommandBufferExecutionRange
{
    uint32_t location;
    uint32_t length;
} _MTL_PACKED;

class IndirectCommandBufferDescriptor : public NS::Copying<IndirectCommandBufferDescriptor>
{
public:
    static IndirectCommandBufferDescriptor* alloc();

    IndirectCommandType                     commandTypes() const;

    bool                                    inheritBuffers() const;

    bool                                    inheritCullMode() const;

    bool                                    inheritDepthBias() const;

    bool                                    inheritDepthClipMode() const;

    bool                                    inheritDepthStencilState() const;

    bool                                    inheritFrontFacingWinding() const;

    bool                                    inheritPipelineState() const;

    bool                                    inheritTriangleFillMode() const;

    IndirectCommandBufferDescriptor*        init();

    NS::UInteger                            maxFragmentBufferBindCount() const;

    NS::UInteger                            maxKernelBufferBindCount() const;

    NS::UInteger                            maxKernelThreadgroupMemoryBindCount() const;

    NS::UInteger                            maxMeshBufferBindCount() const;

    NS::UInteger                            maxObjectBufferBindCount() const;

    NS::UInteger                            maxObjectThreadgroupMemoryBindCount() const;

    NS::UInteger                            maxVertexBufferBindCount() const;

    void                                    setCommandTypes(MTL::IndirectCommandType commandTypes);

    void                                    setInheritBuffers(bool inheritBuffers);

    void                                    setInheritCullMode(bool inheritCullMode);

    void                                    setInheritDepthBias(bool inheritDepthBias);

    void                                    setInheritDepthClipMode(bool inheritDepthClipMode);

    void                                    setInheritDepthStencilState(bool inheritDepthStencilState);

    void                                    setInheritFrontFacingWinding(bool inheritFrontFacingWinding);

    void                                    setInheritPipelineState(bool inheritPipelineState);

    void                                    setInheritTriangleFillMode(bool inheritTriangleFillMode);

    void                                    setMaxFragmentBufferBindCount(NS::UInteger maxFragmentBufferBindCount);

    void                                    setMaxKernelBufferBindCount(NS::UInteger maxKernelBufferBindCount);

    void                                    setMaxKernelThreadgroupMemoryBindCount(NS::UInteger maxKernelThreadgroupMemoryBindCount);

    void                                    setMaxMeshBufferBindCount(NS::UInteger maxMeshBufferBindCount);

    void                                    setMaxObjectBufferBindCount(NS::UInteger maxObjectBufferBindCount);

    void                                    setMaxObjectThreadgroupMemoryBindCount(NS::UInteger maxObjectThreadgroupMemoryBindCount);

    void                                    setMaxVertexBufferBindCount(NS::UInteger maxVertexBufferBindCount);

    void                                    setSupportColorAttachmentMapping(bool supportColorAttachmentMapping);

    void                                    setSupportDynamicAttributeStride(bool supportDynamicAttributeStride);

    void                                    setSupportRayTracing(bool supportRayTracing);

    bool                                    supportColorAttachmentMapping() const;

    bool                                    supportDynamicAttributeStride() const;

    bool                                    supportRayTracing() const;
};
class IndirectCommandBuffer : public NS::Referencing<IndirectCommandBuffer, Resource>
{
public:
    ResourceID              gpuResourceID() const;

    IndirectComputeCommand* indirectComputeCommand(NS::UInteger commandIndex);

    IndirectRenderCommand*  indirectRenderCommand(NS::UInteger commandIndex);

    void                    reset(NS::Range range);

    NS::UInteger            size() const;
};

}

_MTL_INLINE MTL::IndirectCommandBufferDescriptor* MTL::IndirectCommandBufferDescriptor::alloc()
{
    return NS::Object::alloc<MTL::IndirectCommandBufferDescriptor>(_MTL_PRIVATE_CLS(MTLIndirectCommandBufferDescriptor));
}

_MTL_INLINE MTL::IndirectCommandType MTL::IndirectCommandBufferDescriptor::commandTypes() const
{
    return Object::sendMessage<MTL::IndirectCommandType>(this, _MTL_PRIVATE_SEL(commandTypes));
}

_MTL_INLINE bool MTL::IndirectCommandBufferDescriptor::inheritBuffers() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(inheritBuffers));
}

_MTL_INLINE bool MTL::IndirectCommandBufferDescriptor::inheritCullMode() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(inheritCullMode));
}

_MTL_INLINE bool MTL::IndirectCommandBufferDescriptor::inheritDepthBias() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(inheritDepthBias));
}

_MTL_INLINE bool MTL::IndirectCommandBufferDescriptor::inheritDepthClipMode() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(inheritDepthClipMode));
}

_MTL_INLINE bool MTL::IndirectCommandBufferDescriptor::inheritDepthStencilState() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(inheritDepthStencilState));
}

_MTL_INLINE bool MTL::IndirectCommandBufferDescriptor::inheritFrontFacingWinding() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(inheritFrontFacingWinding));
}

_MTL_INLINE bool MTL::IndirectCommandBufferDescriptor::inheritPipelineState() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(inheritPipelineState));
}

_MTL_INLINE bool MTL::IndirectCommandBufferDescriptor::inheritTriangleFillMode() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(inheritTriangleFillMode));
}

_MTL_INLINE MTL::IndirectCommandBufferDescriptor* MTL::IndirectCommandBufferDescriptor::init()
{
    return NS::Object::init<MTL::IndirectCommandBufferDescriptor>();
}

_MTL_INLINE NS::UInteger MTL::IndirectCommandBufferDescriptor::maxFragmentBufferBindCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxFragmentBufferBindCount));
}

_MTL_INLINE NS::UInteger MTL::IndirectCommandBufferDescriptor::maxKernelBufferBindCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxKernelBufferBindCount));
}

_MTL_INLINE NS::UInteger MTL::IndirectCommandBufferDescriptor::maxKernelThreadgroupMemoryBindCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxKernelThreadgroupMemoryBindCount));
}

_MTL_INLINE NS::UInteger MTL::IndirectCommandBufferDescriptor::maxMeshBufferBindCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxMeshBufferBindCount));
}

_MTL_INLINE NS::UInteger MTL::IndirectCommandBufferDescriptor::maxObjectBufferBindCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxObjectBufferBindCount));
}

_MTL_INLINE NS::UInteger MTL::IndirectCommandBufferDescriptor::maxObjectThreadgroupMemoryBindCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxObjectThreadgroupMemoryBindCount));
}

_MTL_INLINE NS::UInteger MTL::IndirectCommandBufferDescriptor::maxVertexBufferBindCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxVertexBufferBindCount));
}

_MTL_INLINE void MTL::IndirectCommandBufferDescriptor::setCommandTypes(MTL::IndirectCommandType commandTypes)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setCommandTypes_), commandTypes);
}

_MTL_INLINE void MTL::IndirectCommandBufferDescriptor::setInheritBuffers(bool inheritBuffers)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInheritBuffers_), inheritBuffers);
}

_MTL_INLINE void MTL::IndirectCommandBufferDescriptor::setInheritCullMode(bool inheritCullMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInheritCullMode_), inheritCullMode);
}

_MTL_INLINE void MTL::IndirectCommandBufferDescriptor::setInheritDepthBias(bool inheritDepthBias)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInheritDepthBias_), inheritDepthBias);
}

_MTL_INLINE void MTL::IndirectCommandBufferDescriptor::setInheritDepthClipMode(bool inheritDepthClipMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInheritDepthClipMode_), inheritDepthClipMode);
}

_MTL_INLINE void MTL::IndirectCommandBufferDescriptor::setInheritDepthStencilState(bool inheritDepthStencilState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInheritDepthStencilState_), inheritDepthStencilState);
}

_MTL_INLINE void MTL::IndirectCommandBufferDescriptor::setInheritFrontFacingWinding(bool inheritFrontFacingWinding)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInheritFrontFacingWinding_), inheritFrontFacingWinding);
}

_MTL_INLINE void MTL::IndirectCommandBufferDescriptor::setInheritPipelineState(bool inheritPipelineState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInheritPipelineState_), inheritPipelineState);
}

_MTL_INLINE void MTL::IndirectCommandBufferDescriptor::setInheritTriangleFillMode(bool inheritTriangleFillMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInheritTriangleFillMode_), inheritTriangleFillMode);
}

_MTL_INLINE void MTL::IndirectCommandBufferDescriptor::setMaxFragmentBufferBindCount(NS::UInteger maxFragmentBufferBindCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxFragmentBufferBindCount_), maxFragmentBufferBindCount);
}

_MTL_INLINE void MTL::IndirectCommandBufferDescriptor::setMaxKernelBufferBindCount(NS::UInteger maxKernelBufferBindCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxKernelBufferBindCount_), maxKernelBufferBindCount);
}

_MTL_INLINE void MTL::IndirectCommandBufferDescriptor::setMaxKernelThreadgroupMemoryBindCount(NS::UInteger maxKernelThreadgroupMemoryBindCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxKernelThreadgroupMemoryBindCount_), maxKernelThreadgroupMemoryBindCount);
}

_MTL_INLINE void MTL::IndirectCommandBufferDescriptor::setMaxMeshBufferBindCount(NS::UInteger maxMeshBufferBindCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxMeshBufferBindCount_), maxMeshBufferBindCount);
}

_MTL_INLINE void MTL::IndirectCommandBufferDescriptor::setMaxObjectBufferBindCount(NS::UInteger maxObjectBufferBindCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxObjectBufferBindCount_), maxObjectBufferBindCount);
}

_MTL_INLINE void MTL::IndirectCommandBufferDescriptor::setMaxObjectThreadgroupMemoryBindCount(NS::UInteger maxObjectThreadgroupMemoryBindCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxObjectThreadgroupMemoryBindCount_), maxObjectThreadgroupMemoryBindCount);
}

_MTL_INLINE void MTL::IndirectCommandBufferDescriptor::setMaxVertexBufferBindCount(NS::UInteger maxVertexBufferBindCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxVertexBufferBindCount_), maxVertexBufferBindCount);
}

_MTL_INLINE void MTL::IndirectCommandBufferDescriptor::setSupportColorAttachmentMapping(bool supportColorAttachmentMapping)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportColorAttachmentMapping_), supportColorAttachmentMapping);
}

_MTL_INLINE void MTL::IndirectCommandBufferDescriptor::setSupportDynamicAttributeStride(bool supportDynamicAttributeStride)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportDynamicAttributeStride_), supportDynamicAttributeStride);
}

_MTL_INLINE void MTL::IndirectCommandBufferDescriptor::setSupportRayTracing(bool supportRayTracing)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportRayTracing_), supportRayTracing);
}

_MTL_INLINE bool MTL::IndirectCommandBufferDescriptor::supportColorAttachmentMapping() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportColorAttachmentMapping));
}

_MTL_INLINE bool MTL::IndirectCommandBufferDescriptor::supportDynamicAttributeStride() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportDynamicAttributeStride));
}

_MTL_INLINE bool MTL::IndirectCommandBufferDescriptor::supportRayTracing() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportRayTracing));
}

_MTL_INLINE MTL::ResourceID MTL::IndirectCommandBuffer::gpuResourceID() const
{
    return Object::sendMessage<MTL::ResourceID>(this, _MTL_PRIVATE_SEL(gpuResourceID));
}

_MTL_INLINE MTL::IndirectComputeCommand* MTL::IndirectCommandBuffer::indirectComputeCommand(NS::UInteger commandIndex)
{
    return Object::sendMessage<MTL::IndirectComputeCommand*>(this, _MTL_PRIVATE_SEL(indirectComputeCommandAtIndex_), commandIndex);
}

_MTL_INLINE MTL::IndirectRenderCommand* MTL::IndirectCommandBuffer::indirectRenderCommand(NS::UInteger commandIndex)
{
    return Object::sendMessage<MTL::IndirectRenderCommand*>(this, _MTL_PRIVATE_SEL(indirectRenderCommandAtIndex_), commandIndex);
}

_MTL_INLINE void MTL::IndirectCommandBuffer::reset(NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(resetWithRange_), range);
}

_MTL_INLINE NS::UInteger MTL::IndirectCommandBuffer::size() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(size));
}

#pragma once

#pragma once

#pragma once

#include <cstdint>

namespace MTL
{
class Buffer;
class CounterSampleBuffer;
class RasterizationRateMap;
class RenderPassAttachmentDescriptor;
class RenderPassColorAttachmentDescriptor;
class RenderPassColorAttachmentDescriptorArray;
class RenderPassDepthAttachmentDescriptor;
class RenderPassDescriptor;
class RenderPassSampleBufferAttachmentDescriptor;
class RenderPassSampleBufferAttachmentDescriptorArray;
class RenderPassStencilAttachmentDescriptor;
struct SamplePosition;
class Texture;
_MTL_ENUM(NS::UInteger, LoadAction) {
    LoadActionDontCare = 0,
    LoadActionLoad = 1,
    LoadActionClear = 2,
};

_MTL_ENUM(NS::UInteger, StoreAction) {
    StoreActionDontCare = 0,
    StoreActionStore = 1,
    StoreActionMultisampleResolve = 2,
    StoreActionStoreAndMultisampleResolve = 3,
    StoreActionUnknown = 4,
    StoreActionCustomSampleDepthStore = 5,
};

_MTL_ENUM(NS::Integer, VisibilityResultType) {
    VisibilityResultTypeReset = 0,
    VisibilityResultTypeAccumulate = 1,
};

_MTL_ENUM(NS::UInteger, MultisampleDepthResolveFilter) {
    MultisampleDepthResolveFilterSample0 = 0,
    MultisampleDepthResolveFilterMin = 1,
    MultisampleDepthResolveFilterMax = 2,
};

_MTL_ENUM(NS::UInteger, MultisampleStencilResolveFilter) {
    MultisampleStencilResolveFilterSample0 = 0,
    MultisampleStencilResolveFilterDepthResolvedSample = 1,
};

_MTL_OPTIONS(NS::UInteger, StoreActionOptions) {
    StoreActionOptionNone = 0,
    StoreActionOptionCustomSamplePositions = 1,
    StoreActionOptionValidMask = 1,
};

struct ClearColor
{
    ClearColor() = default;

    ClearColor(double red, double green, double blue, double alpha);

    static ClearColor Make(double red, double green, double blue, double alpha);

    double            red;
    double            green;
    double            blue;
    double            alpha;
} _MTL_PACKED;

class RenderPassAttachmentDescriptor : public NS::Copying<RenderPassAttachmentDescriptor>
{
public:
    static RenderPassAttachmentDescriptor* alloc();

    NS::UInteger                           depthPlane() const;

    RenderPassAttachmentDescriptor*        init();

    NS::UInteger                           level() const;

    LoadAction                             loadAction() const;

    NS::UInteger                           resolveDepthPlane() const;

    NS::UInteger                           resolveLevel() const;

    NS::UInteger                           resolveSlice() const;

    Texture*                               resolveTexture() const;

    void                                   setDepthPlane(NS::UInteger depthPlane);

    void                                   setLevel(NS::UInteger level);

    void                                   setLoadAction(MTL::LoadAction loadAction);

    void                                   setResolveDepthPlane(NS::UInteger resolveDepthPlane);

    void                                   setResolveLevel(NS::UInteger resolveLevel);

    void                                   setResolveSlice(NS::UInteger resolveSlice);

    void                                   setResolveTexture(const MTL::Texture* resolveTexture);

    void                                   setSlice(NS::UInteger slice);

    void                                   setStoreAction(MTL::StoreAction storeAction);
    void                                   setStoreActionOptions(MTL::StoreActionOptions storeActionOptions);

    void                                   setTexture(const MTL::Texture* texture);

    NS::UInteger                           slice() const;

    StoreAction                            storeAction() const;
    StoreActionOptions                     storeActionOptions() const;

    Texture*                               texture() const;
};
class RenderPassColorAttachmentDescriptor : public NS::Copying<RenderPassColorAttachmentDescriptor, RenderPassAttachmentDescriptor>
{
public:
    static RenderPassColorAttachmentDescriptor* alloc();

    ClearColor                                  clearColor() const;

    RenderPassColorAttachmentDescriptor*        init();

    void                                        setClearColor(MTL::ClearColor clearColor);
};
class RenderPassDepthAttachmentDescriptor : public NS::Copying<RenderPassDepthAttachmentDescriptor, RenderPassAttachmentDescriptor>
{
public:
    static RenderPassDepthAttachmentDescriptor* alloc();

    double                                      clearDepth() const;

    MultisampleDepthResolveFilter               depthResolveFilter() const;

    RenderPassDepthAttachmentDescriptor*        init();

    void                                        setClearDepth(double clearDepth);

    void                                        setDepthResolveFilter(MTL::MultisampleDepthResolveFilter depthResolveFilter);
};
class RenderPassStencilAttachmentDescriptor : public NS::Copying<RenderPassStencilAttachmentDescriptor, RenderPassAttachmentDescriptor>
{
public:
    static RenderPassStencilAttachmentDescriptor* alloc();

    uint32_t                                      clearStencil() const;

    RenderPassStencilAttachmentDescriptor*        init();

    void                                          setClearStencil(uint32_t clearStencil);

    void                                          setStencilResolveFilter(MTL::MultisampleStencilResolveFilter stencilResolveFilter);
    MultisampleStencilResolveFilter               stencilResolveFilter() const;
};
class RenderPassColorAttachmentDescriptorArray : public NS::Referencing<RenderPassColorAttachmentDescriptorArray>
{
public:
    static RenderPassColorAttachmentDescriptorArray* alloc();

    RenderPassColorAttachmentDescriptorArray*        init();

    RenderPassColorAttachmentDescriptor*             object(NS::UInteger attachmentIndex);
    void                                             setObject(const MTL::RenderPassColorAttachmentDescriptor* attachment, NS::UInteger attachmentIndex);
};
class RenderPassSampleBufferAttachmentDescriptor : public NS::Copying<RenderPassSampleBufferAttachmentDescriptor>
{
public:
    static RenderPassSampleBufferAttachmentDescriptor* alloc();

    NS::UInteger                                       endOfFragmentSampleIndex() const;

    NS::UInteger                                       endOfVertexSampleIndex() const;

    RenderPassSampleBufferAttachmentDescriptor*        init();

    CounterSampleBuffer*                               sampleBuffer() const;

    void                                               setEndOfFragmentSampleIndex(NS::UInteger endOfFragmentSampleIndex);

    void                                               setEndOfVertexSampleIndex(NS::UInteger endOfVertexSampleIndex);

    void                                               setSampleBuffer(const MTL::CounterSampleBuffer* sampleBuffer);

    void                                               setStartOfFragmentSampleIndex(NS::UInteger startOfFragmentSampleIndex);

    void                                               setStartOfVertexSampleIndex(NS::UInteger startOfVertexSampleIndex);

    NS::UInteger                                       startOfFragmentSampleIndex() const;

    NS::UInteger                                       startOfVertexSampleIndex() const;
};
class RenderPassSampleBufferAttachmentDescriptorArray : public NS::Referencing<RenderPassSampleBufferAttachmentDescriptorArray>
{
public:
    static RenderPassSampleBufferAttachmentDescriptorArray* alloc();

    RenderPassSampleBufferAttachmentDescriptorArray*        init();

    RenderPassSampleBufferAttachmentDescriptor*             object(NS::UInteger attachmentIndex);
    void                                                    setObject(const MTL::RenderPassSampleBufferAttachmentDescriptor* attachment, NS::UInteger attachmentIndex);
};
class RenderPassDescriptor : public NS::Copying<RenderPassDescriptor>
{
public:
    static RenderPassDescriptor*                     alloc();

    RenderPassColorAttachmentDescriptorArray*        colorAttachments() const;

    NS::UInteger                                     defaultRasterSampleCount() const;

    RenderPassDepthAttachmentDescriptor*             depthAttachment() const;

    NS::UInteger                                     getSamplePositions(MTL::SamplePosition* positions, NS::UInteger count);

    NS::UInteger                                     imageblockSampleLength() const;

    RenderPassDescriptor*                            init();

    RasterizationRateMap*                            rasterizationRateMap() const;

    static RenderPassDescriptor*                     renderPassDescriptor();

    NS::UInteger                                     renderTargetArrayLength() const;

    NS::UInteger                                     renderTargetHeight() const;

    NS::UInteger                                     renderTargetWidth() const;

    RenderPassSampleBufferAttachmentDescriptorArray* sampleBufferAttachments() const;

    void                                             setDefaultRasterSampleCount(NS::UInteger defaultRasterSampleCount);

    void                                             setDepthAttachment(const MTL::RenderPassDepthAttachmentDescriptor* depthAttachment);

    void                                             setImageblockSampleLength(NS::UInteger imageblockSampleLength);

    void                                             setRasterizationRateMap(const MTL::RasterizationRateMap* rasterizationRateMap);

    void                                             setRenderTargetArrayLength(NS::UInteger renderTargetArrayLength);

    void                                             setRenderTargetHeight(NS::UInteger renderTargetHeight);

    void                                             setRenderTargetWidth(NS::UInteger renderTargetWidth);

    void                                             setSamplePositions(const MTL::SamplePosition* positions, NS::UInteger count);

    void                                             setStencilAttachment(const MTL::RenderPassStencilAttachmentDescriptor* stencilAttachment);

    void                                             setSupportColorAttachmentMapping(bool supportColorAttachmentMapping);

    void                                             setThreadgroupMemoryLength(NS::UInteger threadgroupMemoryLength);

    void                                             setTileHeight(NS::UInteger tileHeight);

    void                                             setTileWidth(NS::UInteger tileWidth);

    void                                             setVisibilityResultBuffer(const MTL::Buffer* visibilityResultBuffer);

    void                                             setVisibilityResultType(MTL::VisibilityResultType visibilityResultType);

    RenderPassStencilAttachmentDescriptor*           stencilAttachment() const;

    bool                                             supportColorAttachmentMapping() const;

    NS::UInteger                                     threadgroupMemoryLength() const;

    NS::UInteger                                     tileHeight() const;

    NS::UInteger                                     tileWidth() const;

    Buffer*                                          visibilityResultBuffer() const;

    VisibilityResultType                             visibilityResultType() const;
};

}
_MTL_INLINE MTL::ClearColor::ClearColor(double red, double green, double blue, double alpha)
    : red(red)
    , green(green)
    , blue(blue)
    , alpha(alpha)
{
}

_MTL_INLINE MTL::ClearColor MTL::ClearColor::Make(double red, double green, double blue, double alpha)
{
    return ClearColor(red, green, blue, alpha);
}

_MTL_INLINE MTL::RenderPassAttachmentDescriptor* MTL::RenderPassAttachmentDescriptor::alloc()
{
    return NS::Object::alloc<MTL::RenderPassAttachmentDescriptor>(_MTL_PRIVATE_CLS(MTLRenderPassAttachmentDescriptor));
}

_MTL_INLINE NS::UInteger MTL::RenderPassAttachmentDescriptor::depthPlane() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(depthPlane));
}

_MTL_INLINE MTL::RenderPassAttachmentDescriptor* MTL::RenderPassAttachmentDescriptor::init()
{
    return NS::Object::init<MTL::RenderPassAttachmentDescriptor>();
}

_MTL_INLINE NS::UInteger MTL::RenderPassAttachmentDescriptor::level() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(level));
}

_MTL_INLINE MTL::LoadAction MTL::RenderPassAttachmentDescriptor::loadAction() const
{
    return Object::sendMessage<MTL::LoadAction>(this, _MTL_PRIVATE_SEL(loadAction));
}

_MTL_INLINE NS::UInteger MTL::RenderPassAttachmentDescriptor::resolveDepthPlane() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(resolveDepthPlane));
}

_MTL_INLINE NS::UInteger MTL::RenderPassAttachmentDescriptor::resolveLevel() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(resolveLevel));
}

_MTL_INLINE NS::UInteger MTL::RenderPassAttachmentDescriptor::resolveSlice() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(resolveSlice));
}

_MTL_INLINE MTL::Texture* MTL::RenderPassAttachmentDescriptor::resolveTexture() const
{
    return Object::sendMessage<MTL::Texture*>(this, _MTL_PRIVATE_SEL(resolveTexture));
}

_MTL_INLINE void MTL::RenderPassAttachmentDescriptor::setDepthPlane(NS::UInteger depthPlane)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthPlane_), depthPlane);
}

_MTL_INLINE void MTL::RenderPassAttachmentDescriptor::setLevel(NS::UInteger level)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLevel_), level);
}

_MTL_INLINE void MTL::RenderPassAttachmentDescriptor::setLoadAction(MTL::LoadAction loadAction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLoadAction_), loadAction);
}

_MTL_INLINE void MTL::RenderPassAttachmentDescriptor::setResolveDepthPlane(NS::UInteger resolveDepthPlane)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setResolveDepthPlane_), resolveDepthPlane);
}

_MTL_INLINE void MTL::RenderPassAttachmentDescriptor::setResolveLevel(NS::UInteger resolveLevel)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setResolveLevel_), resolveLevel);
}

_MTL_INLINE void MTL::RenderPassAttachmentDescriptor::setResolveSlice(NS::UInteger resolveSlice)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setResolveSlice_), resolveSlice);
}

_MTL_INLINE void MTL::RenderPassAttachmentDescriptor::setResolveTexture(const MTL::Texture* resolveTexture)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setResolveTexture_), resolveTexture);
}

_MTL_INLINE void MTL::RenderPassAttachmentDescriptor::setSlice(NS::UInteger slice)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSlice_), slice);
}

_MTL_INLINE void MTL::RenderPassAttachmentDescriptor::setStoreAction(MTL::StoreAction storeAction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStoreAction_), storeAction);
}

_MTL_INLINE void MTL::RenderPassAttachmentDescriptor::setStoreActionOptions(MTL::StoreActionOptions storeActionOptions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStoreActionOptions_), storeActionOptions);
}

_MTL_INLINE void MTL::RenderPassAttachmentDescriptor::setTexture(const MTL::Texture* texture)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTexture_), texture);
}

_MTL_INLINE NS::UInteger MTL::RenderPassAttachmentDescriptor::slice() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(slice));
}

_MTL_INLINE MTL::StoreAction MTL::RenderPassAttachmentDescriptor::storeAction() const
{
    return Object::sendMessage<MTL::StoreAction>(this, _MTL_PRIVATE_SEL(storeAction));
}

_MTL_INLINE MTL::StoreActionOptions MTL::RenderPassAttachmentDescriptor::storeActionOptions() const
{
    return Object::sendMessage<MTL::StoreActionOptions>(this, _MTL_PRIVATE_SEL(storeActionOptions));
}

_MTL_INLINE MTL::Texture* MTL::RenderPassAttachmentDescriptor::texture() const
{
    return Object::sendMessage<MTL::Texture*>(this, _MTL_PRIVATE_SEL(texture));
}

_MTL_INLINE MTL::RenderPassColorAttachmentDescriptor* MTL::RenderPassColorAttachmentDescriptor::alloc()
{
    return NS::Object::alloc<MTL::RenderPassColorAttachmentDescriptor>(_MTL_PRIVATE_CLS(MTLRenderPassColorAttachmentDescriptor));
}

_MTL_INLINE MTL::ClearColor MTL::RenderPassColorAttachmentDescriptor::clearColor() const
{
    return Object::sendMessage<MTL::ClearColor>(this, _MTL_PRIVATE_SEL(clearColor));
}

_MTL_INLINE MTL::RenderPassColorAttachmentDescriptor* MTL::RenderPassColorAttachmentDescriptor::init()
{
    return NS::Object::init<MTL::RenderPassColorAttachmentDescriptor>();
}

_MTL_INLINE void MTL::RenderPassColorAttachmentDescriptor::setClearColor(MTL::ClearColor clearColor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setClearColor_), clearColor);
}

_MTL_INLINE MTL::RenderPassDepthAttachmentDescriptor* MTL::RenderPassDepthAttachmentDescriptor::alloc()
{
    return NS::Object::alloc<MTL::RenderPassDepthAttachmentDescriptor>(_MTL_PRIVATE_CLS(MTLRenderPassDepthAttachmentDescriptor));
}

_MTL_INLINE double MTL::RenderPassDepthAttachmentDescriptor::clearDepth() const
{
    return Object::sendMessage<double>(this, _MTL_PRIVATE_SEL(clearDepth));
}

_MTL_INLINE MTL::MultisampleDepthResolveFilter MTL::RenderPassDepthAttachmentDescriptor::depthResolveFilter() const
{
    return Object::sendMessage<MTL::MultisampleDepthResolveFilter>(this, _MTL_PRIVATE_SEL(depthResolveFilter));
}

_MTL_INLINE MTL::RenderPassDepthAttachmentDescriptor* MTL::RenderPassDepthAttachmentDescriptor::init()
{
    return NS::Object::init<MTL::RenderPassDepthAttachmentDescriptor>();
}

_MTL_INLINE void MTL::RenderPassDepthAttachmentDescriptor::setClearDepth(double clearDepth)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setClearDepth_), clearDepth);
}

_MTL_INLINE void MTL::RenderPassDepthAttachmentDescriptor::setDepthResolveFilter(MTL::MultisampleDepthResolveFilter depthResolveFilter)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthResolveFilter_), depthResolveFilter);
}

_MTL_INLINE MTL::RenderPassStencilAttachmentDescriptor* MTL::RenderPassStencilAttachmentDescriptor::alloc()
{
    return NS::Object::alloc<MTL::RenderPassStencilAttachmentDescriptor>(_MTL_PRIVATE_CLS(MTLRenderPassStencilAttachmentDescriptor));
}

_MTL_INLINE uint32_t MTL::RenderPassStencilAttachmentDescriptor::clearStencil() const
{
    return Object::sendMessage<uint32_t>(this, _MTL_PRIVATE_SEL(clearStencil));
}

_MTL_INLINE MTL::RenderPassStencilAttachmentDescriptor* MTL::RenderPassStencilAttachmentDescriptor::init()
{
    return NS::Object::init<MTL::RenderPassStencilAttachmentDescriptor>();
}

_MTL_INLINE void MTL::RenderPassStencilAttachmentDescriptor::setClearStencil(uint32_t clearStencil)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setClearStencil_), clearStencil);
}

_MTL_INLINE void MTL::RenderPassStencilAttachmentDescriptor::setStencilResolveFilter(MTL::MultisampleStencilResolveFilter stencilResolveFilter)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStencilResolveFilter_), stencilResolveFilter);
}

_MTL_INLINE MTL::MultisampleStencilResolveFilter MTL::RenderPassStencilAttachmentDescriptor::stencilResolveFilter() const
{
    return Object::sendMessage<MTL::MultisampleStencilResolveFilter>(this, _MTL_PRIVATE_SEL(stencilResolveFilter));
}

_MTL_INLINE MTL::RenderPassColorAttachmentDescriptorArray* MTL::RenderPassColorAttachmentDescriptorArray::alloc()
{
    return NS::Object::alloc<MTL::RenderPassColorAttachmentDescriptorArray>(_MTL_PRIVATE_CLS(MTLRenderPassColorAttachmentDescriptorArray));
}

_MTL_INLINE MTL::RenderPassColorAttachmentDescriptorArray* MTL::RenderPassColorAttachmentDescriptorArray::init()
{
    return NS::Object::init<MTL::RenderPassColorAttachmentDescriptorArray>();
}

_MTL_INLINE MTL::RenderPassColorAttachmentDescriptor* MTL::RenderPassColorAttachmentDescriptorArray::object(NS::UInteger attachmentIndex)
{
    return Object::sendMessage<MTL::RenderPassColorAttachmentDescriptor*>(this, _MTL_PRIVATE_SEL(objectAtIndexedSubscript_), attachmentIndex);
}

_MTL_INLINE void MTL::RenderPassColorAttachmentDescriptorArray::setObject(const MTL::RenderPassColorAttachmentDescriptor* attachment, NS::UInteger attachmentIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObject_atIndexedSubscript_), attachment, attachmentIndex);
}

_MTL_INLINE MTL::RenderPassSampleBufferAttachmentDescriptor* MTL::RenderPassSampleBufferAttachmentDescriptor::alloc()
{
    return NS::Object::alloc<MTL::RenderPassSampleBufferAttachmentDescriptor>(_MTL_PRIVATE_CLS(MTLRenderPassSampleBufferAttachmentDescriptor));
}

_MTL_INLINE NS::UInteger MTL::RenderPassSampleBufferAttachmentDescriptor::endOfFragmentSampleIndex() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(endOfFragmentSampleIndex));
}

_MTL_INLINE NS::UInteger MTL::RenderPassSampleBufferAttachmentDescriptor::endOfVertexSampleIndex() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(endOfVertexSampleIndex));
}

_MTL_INLINE MTL::RenderPassSampleBufferAttachmentDescriptor* MTL::RenderPassSampleBufferAttachmentDescriptor::init()
{
    return NS::Object::init<MTL::RenderPassSampleBufferAttachmentDescriptor>();
}

_MTL_INLINE MTL::CounterSampleBuffer* MTL::RenderPassSampleBufferAttachmentDescriptor::sampleBuffer() const
{
    return Object::sendMessage<MTL::CounterSampleBuffer*>(this, _MTL_PRIVATE_SEL(sampleBuffer));
}

_MTL_INLINE void MTL::RenderPassSampleBufferAttachmentDescriptor::setEndOfFragmentSampleIndex(NS::UInteger endOfFragmentSampleIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setEndOfFragmentSampleIndex_), endOfFragmentSampleIndex);
}

_MTL_INLINE void MTL::RenderPassSampleBufferAttachmentDescriptor::setEndOfVertexSampleIndex(NS::UInteger endOfVertexSampleIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setEndOfVertexSampleIndex_), endOfVertexSampleIndex);
}

_MTL_INLINE void MTL::RenderPassSampleBufferAttachmentDescriptor::setSampleBuffer(const MTL::CounterSampleBuffer* sampleBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSampleBuffer_), sampleBuffer);
}

_MTL_INLINE void MTL::RenderPassSampleBufferAttachmentDescriptor::setStartOfFragmentSampleIndex(NS::UInteger startOfFragmentSampleIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStartOfFragmentSampleIndex_), startOfFragmentSampleIndex);
}

_MTL_INLINE void MTL::RenderPassSampleBufferAttachmentDescriptor::setStartOfVertexSampleIndex(NS::UInteger startOfVertexSampleIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStartOfVertexSampleIndex_), startOfVertexSampleIndex);
}

_MTL_INLINE NS::UInteger MTL::RenderPassSampleBufferAttachmentDescriptor::startOfFragmentSampleIndex() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(startOfFragmentSampleIndex));
}

_MTL_INLINE NS::UInteger MTL::RenderPassSampleBufferAttachmentDescriptor::startOfVertexSampleIndex() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(startOfVertexSampleIndex));
}

_MTL_INLINE MTL::RenderPassSampleBufferAttachmentDescriptorArray* MTL::RenderPassSampleBufferAttachmentDescriptorArray::alloc()
{
    return NS::Object::alloc<MTL::RenderPassSampleBufferAttachmentDescriptorArray>(_MTL_PRIVATE_CLS(MTLRenderPassSampleBufferAttachmentDescriptorArray));
}

_MTL_INLINE MTL::RenderPassSampleBufferAttachmentDescriptorArray* MTL::RenderPassSampleBufferAttachmentDescriptorArray::init()
{
    return NS::Object::init<MTL::RenderPassSampleBufferAttachmentDescriptorArray>();
}

_MTL_INLINE MTL::RenderPassSampleBufferAttachmentDescriptor* MTL::RenderPassSampleBufferAttachmentDescriptorArray::object(NS::UInteger attachmentIndex)
{
    return Object::sendMessage<MTL::RenderPassSampleBufferAttachmentDescriptor*>(this, _MTL_PRIVATE_SEL(objectAtIndexedSubscript_), attachmentIndex);
}

_MTL_INLINE void MTL::RenderPassSampleBufferAttachmentDescriptorArray::setObject(const MTL::RenderPassSampleBufferAttachmentDescriptor* attachment, NS::UInteger attachmentIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObject_atIndexedSubscript_), attachment, attachmentIndex);
}

_MTL_INLINE MTL::RenderPassDescriptor* MTL::RenderPassDescriptor::alloc()
{
    return NS::Object::alloc<MTL::RenderPassDescriptor>(_MTL_PRIVATE_CLS(MTLRenderPassDescriptor));
}

_MTL_INLINE MTL::RenderPassColorAttachmentDescriptorArray* MTL::RenderPassDescriptor::colorAttachments() const
{
    return Object::sendMessage<MTL::RenderPassColorAttachmentDescriptorArray*>(this, _MTL_PRIVATE_SEL(colorAttachments));
}

_MTL_INLINE NS::UInteger MTL::RenderPassDescriptor::defaultRasterSampleCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(defaultRasterSampleCount));
}

_MTL_INLINE MTL::RenderPassDepthAttachmentDescriptor* MTL::RenderPassDescriptor::depthAttachment() const
{
    return Object::sendMessage<MTL::RenderPassDepthAttachmentDescriptor*>(this, _MTL_PRIVATE_SEL(depthAttachment));
}

_MTL_INLINE NS::UInteger MTL::RenderPassDescriptor::getSamplePositions(MTL::SamplePosition* positions, NS::UInteger count)
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(getSamplePositions_count_), positions, count);
}

_MTL_INLINE NS::UInteger MTL::RenderPassDescriptor::imageblockSampleLength() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(imageblockSampleLength));
}

_MTL_INLINE MTL::RenderPassDescriptor* MTL::RenderPassDescriptor::init()
{
    return NS::Object::init<MTL::RenderPassDescriptor>();
}

_MTL_INLINE MTL::RasterizationRateMap* MTL::RenderPassDescriptor::rasterizationRateMap() const
{
    return Object::sendMessage<MTL::RasterizationRateMap*>(this, _MTL_PRIVATE_SEL(rasterizationRateMap));
}

_MTL_INLINE MTL::RenderPassDescriptor* MTL::RenderPassDescriptor::renderPassDescriptor()
{
    return Object::sendMessage<MTL::RenderPassDescriptor*>(_MTL_PRIVATE_CLS(MTLRenderPassDescriptor), _MTL_PRIVATE_SEL(renderPassDescriptor));
}

_MTL_INLINE NS::UInteger MTL::RenderPassDescriptor::renderTargetArrayLength() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(renderTargetArrayLength));
}

_MTL_INLINE NS::UInteger MTL::RenderPassDescriptor::renderTargetHeight() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(renderTargetHeight));
}

_MTL_INLINE NS::UInteger MTL::RenderPassDescriptor::renderTargetWidth() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(renderTargetWidth));
}

_MTL_INLINE MTL::RenderPassSampleBufferAttachmentDescriptorArray* MTL::RenderPassDescriptor::sampleBufferAttachments() const
{
    return Object::sendMessage<MTL::RenderPassSampleBufferAttachmentDescriptorArray*>(this, _MTL_PRIVATE_SEL(sampleBufferAttachments));
}

_MTL_INLINE void MTL::RenderPassDescriptor::setDefaultRasterSampleCount(NS::UInteger defaultRasterSampleCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDefaultRasterSampleCount_), defaultRasterSampleCount);
}

_MTL_INLINE void MTL::RenderPassDescriptor::setDepthAttachment(const MTL::RenderPassDepthAttachmentDescriptor* depthAttachment)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthAttachment_), depthAttachment);
}

_MTL_INLINE void MTL::RenderPassDescriptor::setImageblockSampleLength(NS::UInteger imageblockSampleLength)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setImageblockSampleLength_), imageblockSampleLength);
}

_MTL_INLINE void MTL::RenderPassDescriptor::setRasterizationRateMap(const MTL::RasterizationRateMap* rasterizationRateMap)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRasterizationRateMap_), rasterizationRateMap);
}

_MTL_INLINE void MTL::RenderPassDescriptor::setRenderTargetArrayLength(NS::UInteger renderTargetArrayLength)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRenderTargetArrayLength_), renderTargetArrayLength);
}

_MTL_INLINE void MTL::RenderPassDescriptor::setRenderTargetHeight(NS::UInteger renderTargetHeight)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRenderTargetHeight_), renderTargetHeight);
}

_MTL_INLINE void MTL::RenderPassDescriptor::setRenderTargetWidth(NS::UInteger renderTargetWidth)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRenderTargetWidth_), renderTargetWidth);
}

_MTL_INLINE void MTL::RenderPassDescriptor::setSamplePositions(const MTL::SamplePosition* positions, NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSamplePositions_count_), positions, count);
}

_MTL_INLINE void MTL::RenderPassDescriptor::setStencilAttachment(const MTL::RenderPassStencilAttachmentDescriptor* stencilAttachment)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStencilAttachment_), stencilAttachment);
}

_MTL_INLINE void MTL::RenderPassDescriptor::setSupportColorAttachmentMapping(bool supportColorAttachmentMapping)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportColorAttachmentMapping_), supportColorAttachmentMapping);
}

_MTL_INLINE void MTL::RenderPassDescriptor::setThreadgroupMemoryLength(NS::UInteger threadgroupMemoryLength)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setThreadgroupMemoryLength_), threadgroupMemoryLength);
}

_MTL_INLINE void MTL::RenderPassDescriptor::setTileHeight(NS::UInteger tileHeight)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileHeight_), tileHeight);
}

_MTL_INLINE void MTL::RenderPassDescriptor::setTileWidth(NS::UInteger tileWidth)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileWidth_), tileWidth);
}

_MTL_INLINE void MTL::RenderPassDescriptor::setVisibilityResultBuffer(const MTL::Buffer* visibilityResultBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVisibilityResultBuffer_), visibilityResultBuffer);
}

_MTL_INLINE void MTL::RenderPassDescriptor::setVisibilityResultType(MTL::VisibilityResultType visibilityResultType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVisibilityResultType_), visibilityResultType);
}

_MTL_INLINE MTL::RenderPassStencilAttachmentDescriptor* MTL::RenderPassDescriptor::stencilAttachment() const
{
    return Object::sendMessage<MTL::RenderPassStencilAttachmentDescriptor*>(this, _MTL_PRIVATE_SEL(stencilAttachment));
}

_MTL_INLINE bool MTL::RenderPassDescriptor::supportColorAttachmentMapping() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportColorAttachmentMapping));
}

_MTL_INLINE NS::UInteger MTL::RenderPassDescriptor::threadgroupMemoryLength() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(threadgroupMemoryLength));
}

_MTL_INLINE NS::UInteger MTL::RenderPassDescriptor::tileHeight() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(tileHeight));
}

_MTL_INLINE NS::UInteger MTL::RenderPassDescriptor::tileWidth() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(tileWidth));
}

_MTL_INLINE MTL::Buffer* MTL::RenderPassDescriptor::visibilityResultBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(visibilityResultBuffer));
}

_MTL_INLINE MTL::VisibilityResultType MTL::RenderPassDescriptor::visibilityResultType() const
{
    return Object::sendMessage<MTL::VisibilityResultType>(this, _MTL_PRIVATE_SEL(visibilityResultType));
}

#include <cstdint>

namespace MTL
{
class AccelerationStructure;
class Buffer;
class CounterSampleBuffer;
class DepthStencilState;
class Fence;
class Heap;
class IndirectCommandBuffer;
class IntersectionFunctionTable;
class LogicalToPhysicalColorAttachmentMap;
class RenderPipelineState;
class Resource;
class SamplerState;
struct ScissorRect;
class Texture;
struct VertexAmplificationViewMapping;
struct Viewport;
class VisibleFunctionTable;
_MTL_ENUM(NS::UInteger, PrimitiveType) {
    PrimitiveTypePoint = 0,
    PrimitiveTypeLine = 1,
    PrimitiveTypeLineStrip = 2,
    PrimitiveTypeTriangle = 3,
    PrimitiveTypeTriangleStrip = 4,
};

_MTL_ENUM(NS::UInteger, VisibilityResultMode) {
    VisibilityResultModeDisabled = 0,
    VisibilityResultModeBoolean = 1,
    VisibilityResultModeCounting = 2,
};

_MTL_ENUM(NS::UInteger, CullMode) {
    CullModeNone = 0,
    CullModeFront = 1,
    CullModeBack = 2,
};

_MTL_ENUM(NS::UInteger, Winding) {
    WindingClockwise = 0,
    WindingCounterClockwise = 1,
};

_MTL_ENUM(NS::UInteger, DepthClipMode) {
    DepthClipModeClip = 0,
    DepthClipModeClamp = 1,
};

_MTL_ENUM(NS::UInteger, TriangleFillMode) {
    TriangleFillModeFill = 0,
    TriangleFillModeLines = 1,
};

_MTL_OPTIONS(NS::UInteger, RenderStages) {
    RenderStageVertex = 1,
    RenderStageFragment = 1 << 1,
    RenderStageTile = 1 << 2,
    RenderStageObject = 1 << 3,
    RenderStageMesh = 1 << 4,
};

struct ScissorRect
{
    NS::UInteger x;
    NS::UInteger y;
    NS::UInteger width;
    NS::UInteger height;
} _MTL_PACKED;

struct Viewport
{
    double originX;
    double originY;
    double width;
    double height;
    double znear;
    double zfar;
} _MTL_PACKED;

struct DrawPrimitivesIndirectArguments
{
    uint32_t vertexCount;
    uint32_t instanceCount;
    uint32_t vertexStart;
    uint32_t baseInstance;
} _MTL_PACKED;

struct DrawIndexedPrimitivesIndirectArguments
{
    uint32_t indexCount;
    uint32_t instanceCount;
    uint32_t indexStart;
    int32_t  baseVertex;
    uint32_t baseInstance;
} _MTL_PACKED;

struct VertexAmplificationViewMapping
{
    uint32_t viewportArrayIndexOffset;
    uint32_t renderTargetArrayIndexOffset;
} _MTL_PACKED;

struct DrawPatchIndirectArguments
{
    uint32_t patchCount;
    uint32_t instanceCount;
    uint32_t patchStart;
    uint32_t baseInstance;
} _MTL_PACKED;

struct QuadTessellationFactorsHalf
{
    uint16_t edgeTessellationFactor[4];
    uint16_t insideTessellationFactor[2];
} _MTL_PACKED;

struct TriangleTessellationFactorsHalf
{
    uint16_t edgeTessellationFactor[3];
    uint16_t insideTessellationFactor;
} _MTL_PACKED;

class RenderCommandEncoder : public NS::Referencing<RenderCommandEncoder, CommandEncoder>
{
public:
    void         dispatchThreadsPerTile(MTL::Size threadsPerTile);

    void         drawIndexedPatches(NS::UInteger numberOfPatchControlPoints, NS::UInteger patchStart, NS::UInteger patchCount, const MTL::Buffer* patchIndexBuffer, NS::UInteger patchIndexBufferOffset, const MTL::Buffer* controlPointIndexBuffer, NS::UInteger controlPointIndexBufferOffset, NS::UInteger instanceCount, NS::UInteger baseInstance);
    void         drawIndexedPatches(NS::UInteger numberOfPatchControlPoints, const MTL::Buffer* patchIndexBuffer, NS::UInteger patchIndexBufferOffset, const MTL::Buffer* controlPointIndexBuffer, NS::UInteger controlPointIndexBufferOffset, const MTL::Buffer* indirectBuffer, NS::UInteger indirectBufferOffset);

    void         drawIndexedPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger indexCount, MTL::IndexType indexType, const MTL::Buffer* indexBuffer, NS::UInteger indexBufferOffset, NS::UInteger instanceCount);
    void         drawIndexedPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger indexCount, MTL::IndexType indexType, const MTL::Buffer* indexBuffer, NS::UInteger indexBufferOffset);
    void         drawIndexedPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger indexCount, MTL::IndexType indexType, const MTL::Buffer* indexBuffer, NS::UInteger indexBufferOffset, NS::UInteger instanceCount, NS::Integer baseVertex, NS::UInteger baseInstance);
    void         drawIndexedPrimitives(MTL::PrimitiveType primitiveType, MTL::IndexType indexType, const MTL::Buffer* indexBuffer, NS::UInteger indexBufferOffset, const MTL::Buffer* indirectBuffer, NS::UInteger indirectBufferOffset);

    void         drawMeshThreadgroups(MTL::Size threadgroupsPerGrid, MTL::Size threadsPerObjectThreadgroup, MTL::Size threadsPerMeshThreadgroup);
    void         drawMeshThreadgroups(const MTL::Buffer* indirectBuffer, NS::UInteger indirectBufferOffset, MTL::Size threadsPerObjectThreadgroup, MTL::Size threadsPerMeshThreadgroup);

    void         drawMeshThreads(MTL::Size threadsPerGrid, MTL::Size threadsPerObjectThreadgroup, MTL::Size threadsPerMeshThreadgroup);

    void         drawPatches(NS::UInteger numberOfPatchControlPoints, NS::UInteger patchStart, NS::UInteger patchCount, const MTL::Buffer* patchIndexBuffer, NS::UInteger patchIndexBufferOffset, NS::UInteger instanceCount, NS::UInteger baseInstance);
    void         drawPatches(NS::UInteger numberOfPatchControlPoints, const MTL::Buffer* patchIndexBuffer, NS::UInteger patchIndexBufferOffset, const MTL::Buffer* indirectBuffer, NS::UInteger indirectBufferOffset);

    void         drawPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger vertexStart, NS::UInteger vertexCount, NS::UInteger instanceCount);
    void         drawPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger vertexStart, NS::UInteger vertexCount);
    void         drawPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger vertexStart, NS::UInteger vertexCount, NS::UInteger instanceCount, NS::UInteger baseInstance);
    void         drawPrimitives(MTL::PrimitiveType primitiveType, const MTL::Buffer* indirectBuffer, NS::UInteger indirectBufferOffset);

    void         executeCommandsInBuffer(const MTL::IndirectCommandBuffer* indirectCommandBuffer, NS::Range executionRange);
    void         executeCommandsInBuffer(const MTL::IndirectCommandBuffer* indirectCommandbuffer, const MTL::Buffer* indirectRangeBuffer, NS::UInteger indirectBufferOffset);

    void         memoryBarrier(MTL::BarrierScope scope, MTL::RenderStages after, MTL::RenderStages before);
    void         memoryBarrier(const MTL::Resource* const resources[], NS::UInteger count, MTL::RenderStages after, MTL::RenderStages before);

    void         sampleCountersInBuffer(const MTL::CounterSampleBuffer* sampleBuffer, NS::UInteger sampleIndex, bool barrier);

    void         setBlendColor(float red, float green, float blue, float alpha);

    void         setColorAttachmentMap(const MTL::LogicalToPhysicalColorAttachmentMap* mapping);

    void         setColorStoreAction(MTL::StoreAction storeAction, NS::UInteger colorAttachmentIndex);
    void         setColorStoreActionOptions(MTL::StoreActionOptions storeActionOptions, NS::UInteger colorAttachmentIndex);

    void         setCullMode(MTL::CullMode cullMode);

    void         setDepthBias(float depthBias, float slopeScale, float clamp);

    void         setDepthClipMode(MTL::DepthClipMode depthClipMode);

    void         setDepthStencilState(const MTL::DepthStencilState* depthStencilState);

    void         setDepthStoreAction(MTL::StoreAction storeAction);
    void         setDepthStoreActionOptions(MTL::StoreActionOptions storeActionOptions);

    void         setDepthTestBounds(float minBound, float maxBound);

    void         setFragmentAccelerationStructure(const MTL::AccelerationStructure* accelerationStructure, NS::UInteger bufferIndex);

    void         setFragmentBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index);
    void         setFragmentBufferOffset(NS::UInteger offset, NS::UInteger index);

    void         setFragmentBuffers(const MTL::Buffer* const buffers[], const NS::UInteger offsets[], NS::Range range);

    void         setFragmentBytes(const void* bytes, NS::UInteger length, NS::UInteger index);

    void         setFragmentIntersectionFunctionTable(const MTL::IntersectionFunctionTable* intersectionFunctionTable, NS::UInteger bufferIndex);
    void         setFragmentIntersectionFunctionTables(const MTL::IntersectionFunctionTable* const intersectionFunctionTables[], NS::Range range);

    void         setFragmentSamplerState(const MTL::SamplerState* sampler, NS::UInteger index);
    void         setFragmentSamplerState(const MTL::SamplerState* sampler, float lodMinClamp, float lodMaxClamp, NS::UInteger index);
    void         setFragmentSamplerStates(const MTL::SamplerState* const samplers[], NS::Range range);
    void         setFragmentSamplerStates(const MTL::SamplerState* const samplers[], const float lodMinClamps[], const float lodMaxClamps[], NS::Range range);

    void         setFragmentTexture(const MTL::Texture* texture, NS::UInteger index);
    void         setFragmentTextures(const MTL::Texture* const textures[], NS::Range range);

    void         setFragmentVisibleFunctionTable(const MTL::VisibleFunctionTable* functionTable, NS::UInteger bufferIndex);
    void         setFragmentVisibleFunctionTables(const MTL::VisibleFunctionTable* const functionTables[], NS::Range range);

    void         setFrontFacingWinding(MTL::Winding frontFacingWinding);

    void         setMeshBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index);
    void         setMeshBufferOffset(NS::UInteger offset, NS::UInteger index);

    void         setMeshBuffers(const MTL::Buffer* const buffers[], const NS::UInteger* offsets, NS::Range range);

    void         setMeshBytes(const void* bytes, NS::UInteger length, NS::UInteger index);

    void         setMeshSamplerState(const MTL::SamplerState* sampler, NS::UInteger index);
    void         setMeshSamplerState(const MTL::SamplerState* sampler, float lodMinClamp, float lodMaxClamp, NS::UInteger index);
    void         setMeshSamplerStates(const MTL::SamplerState* const samplers[], NS::Range range);
    void         setMeshSamplerStates(const MTL::SamplerState* const samplers[], const float* lodMinClamps, const float* lodMaxClamps, NS::Range range);

    void         setMeshTexture(const MTL::Texture* texture, NS::UInteger index);
    void         setMeshTextures(const MTL::Texture* const textures[], NS::Range range);

    void         setObjectBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index);
    void         setObjectBufferOffset(NS::UInteger offset, NS::UInteger index);

    void         setObjectBuffers(const MTL::Buffer* const buffers[], const NS::UInteger* offsets, NS::Range range);

    void         setObjectBytes(const void* bytes, NS::UInteger length, NS::UInteger index);

    void         setObjectSamplerState(const MTL::SamplerState* sampler, NS::UInteger index);
    void         setObjectSamplerState(const MTL::SamplerState* sampler, float lodMinClamp, float lodMaxClamp, NS::UInteger index);
    void         setObjectSamplerStates(const MTL::SamplerState* const samplers[], NS::Range range);
    void         setObjectSamplerStates(const MTL::SamplerState* const samplers[], const float* lodMinClamps, const float* lodMaxClamps, NS::Range range);

    void         setObjectTexture(const MTL::Texture* texture, NS::UInteger index);
    void         setObjectTextures(const MTL::Texture* const textures[], NS::Range range);

    void         setObjectThreadgroupMemoryLength(NS::UInteger length, NS::UInteger index);

    void         setRenderPipelineState(const MTL::RenderPipelineState* pipelineState);

    void         setScissorRect(MTL::ScissorRect rect);
    void         setScissorRects(const MTL::ScissorRect* scissorRects, NS::UInteger count);

    void         setStencilReferenceValue(uint32_t referenceValue);
    void         setStencilReferenceValues(uint32_t frontReferenceValue, uint32_t backReferenceValue);

    void         setStencilStoreAction(MTL::StoreAction storeAction);
    void         setStencilStoreActionOptions(MTL::StoreActionOptions storeActionOptions);

    void         setTessellationFactorBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger instanceStride);

    void         setTessellationFactorScale(float scale);

    void         setThreadgroupMemoryLength(NS::UInteger length, NS::UInteger offset, NS::UInteger index);

    void         setTileAccelerationStructure(const MTL::AccelerationStructure* accelerationStructure, NS::UInteger bufferIndex);

    void         setTileBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index);
    void         setTileBufferOffset(NS::UInteger offset, NS::UInteger index);

    void         setTileBuffers(const MTL::Buffer* const buffers[], const NS::UInteger* offsets, NS::Range range);

    void         setTileBytes(const void* bytes, NS::UInteger length, NS::UInteger index);

    void         setTileIntersectionFunctionTable(const MTL::IntersectionFunctionTable* intersectionFunctionTable, NS::UInteger bufferIndex);
    void         setTileIntersectionFunctionTables(const MTL::IntersectionFunctionTable* const intersectionFunctionTables[], NS::Range range);

    void         setTileSamplerState(const MTL::SamplerState* sampler, NS::UInteger index);
    void         setTileSamplerState(const MTL::SamplerState* sampler, float lodMinClamp, float lodMaxClamp, NS::UInteger index);
    void         setTileSamplerStates(const MTL::SamplerState* const samplers[], NS::Range range);
    void         setTileSamplerStates(const MTL::SamplerState* const samplers[], const float lodMinClamps[], const float lodMaxClamps[], NS::Range range);

    void         setTileTexture(const MTL::Texture* texture, NS::UInteger index);
    void         setTileTextures(const MTL::Texture* const textures[], NS::Range range);

    void         setTileVisibleFunctionTable(const MTL::VisibleFunctionTable* functionTable, NS::UInteger bufferIndex);
    void         setTileVisibleFunctionTables(const MTL::VisibleFunctionTable* const functionTables[], NS::Range range);

    void         setTriangleFillMode(MTL::TriangleFillMode fillMode);

    void         setVertexAccelerationStructure(const MTL::AccelerationStructure* accelerationStructure, NS::UInteger bufferIndex);

    void         setVertexAmplificationCount(NS::UInteger count, const MTL::VertexAmplificationViewMapping* viewMappings);

    void         setVertexBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index);
    void         setVertexBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger stride, NS::UInteger index);
    void         setVertexBufferOffset(NS::UInteger offset, NS::UInteger index);
    void         setVertexBufferOffset(NS::UInteger offset, NS::UInteger stride, NS::UInteger index);

    void         setVertexBuffers(const MTL::Buffer* const buffers[], const NS::UInteger offsets[], NS::Range range);
    void         setVertexBuffers(const MTL::Buffer* const buffers[], const NS::UInteger* offsets, const NS::UInteger* strides, NS::Range range);

    void         setVertexBytes(const void* bytes, NS::UInteger length, NS::UInteger index);
    void         setVertexBytes(const void* bytes, NS::UInteger length, NS::UInteger stride, NS::UInteger index);

    void         setVertexIntersectionFunctionTable(const MTL::IntersectionFunctionTable* intersectionFunctionTable, NS::UInteger bufferIndex);
    void         setVertexIntersectionFunctionTables(const MTL::IntersectionFunctionTable* const intersectionFunctionTables[], NS::Range range);

    void         setVertexSamplerState(const MTL::SamplerState* sampler, NS::UInteger index);
    void         setVertexSamplerState(const MTL::SamplerState* sampler, float lodMinClamp, float lodMaxClamp, NS::UInteger index);
    void         setVertexSamplerStates(const MTL::SamplerState* const samplers[], NS::Range range);
    void         setVertexSamplerStates(const MTL::SamplerState* const samplers[], const float lodMinClamps[], const float lodMaxClamps[], NS::Range range);

    void         setVertexTexture(const MTL::Texture* texture, NS::UInteger index);
    void         setVertexTextures(const MTL::Texture* const textures[], NS::Range range);

    void         setVertexVisibleFunctionTable(const MTL::VisibleFunctionTable* functionTable, NS::UInteger bufferIndex);
    void         setVertexVisibleFunctionTables(const MTL::VisibleFunctionTable* const functionTables[], NS::Range range);

    void         setViewport(MTL::Viewport viewport);
    void         setViewports(const MTL::Viewport* viewports, NS::UInteger count);

    void         setVisibilityResultMode(MTL::VisibilityResultMode mode, NS::UInteger offset);

    void         textureBarrier();

    NS::UInteger tileHeight() const;

    NS::UInteger tileWidth() const;

    void         updateFence(const MTL::Fence* fence, MTL::RenderStages stages);

    void         useHeap(const MTL::Heap* heap);
    void         useHeap(const MTL::Heap* heap, MTL::RenderStages stages);
    void         useHeaps(const MTL::Heap* const heaps[], NS::UInteger count);
    void         useHeaps(const MTL::Heap* const heaps[], NS::UInteger count, MTL::RenderStages stages);

    void         useResource(const MTL::Resource* resource, MTL::ResourceUsage usage);
    void         useResource(const MTL::Resource* resource, MTL::ResourceUsage usage, MTL::RenderStages stages);
    void         useResources(const MTL::Resource* const resources[], NS::UInteger count, MTL::ResourceUsage usage);
    void         useResources(const MTL::Resource* const resources[], NS::UInteger count, MTL::ResourceUsage usage, MTL::RenderStages stages);

    void         waitForFence(const MTL::Fence* fence, MTL::RenderStages stages);
};

}

_MTL_INLINE void MTL::RenderCommandEncoder::dispatchThreadsPerTile(MTL::Size threadsPerTile)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(dispatchThreadsPerTile_), threadsPerTile);
}

_MTL_INLINE void MTL::RenderCommandEncoder::drawIndexedPatches(NS::UInteger numberOfPatchControlPoints, NS::UInteger patchStart, NS::UInteger patchCount, const MTL::Buffer* patchIndexBuffer, NS::UInteger patchIndexBufferOffset, const MTL::Buffer* controlPointIndexBuffer, NS::UInteger controlPointIndexBufferOffset, NS::UInteger instanceCount, NS::UInteger baseInstance)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawIndexedPatches_patchStart_patchCount_patchIndexBuffer_patchIndexBufferOffset_controlPointIndexBuffer_controlPointIndexBufferOffset_instanceCount_baseInstance_), numberOfPatchControlPoints, patchStart, patchCount, patchIndexBuffer, patchIndexBufferOffset, controlPointIndexBuffer, controlPointIndexBufferOffset, instanceCount, baseInstance);
}

_MTL_INLINE void MTL::RenderCommandEncoder::drawIndexedPatches(NS::UInteger numberOfPatchControlPoints, const MTL::Buffer* patchIndexBuffer, NS::UInteger patchIndexBufferOffset, const MTL::Buffer* controlPointIndexBuffer, NS::UInteger controlPointIndexBufferOffset, const MTL::Buffer* indirectBuffer, NS::UInteger indirectBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawIndexedPatches_patchIndexBuffer_patchIndexBufferOffset_controlPointIndexBuffer_controlPointIndexBufferOffset_indirectBuffer_indirectBufferOffset_), numberOfPatchControlPoints, patchIndexBuffer, patchIndexBufferOffset, controlPointIndexBuffer, controlPointIndexBufferOffset, indirectBuffer, indirectBufferOffset);
}

_MTL_INLINE void MTL::RenderCommandEncoder::drawIndexedPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger indexCount, MTL::IndexType indexType, const MTL::Buffer* indexBuffer, NS::UInteger indexBufferOffset, NS::UInteger instanceCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferOffset_instanceCount_), primitiveType, indexCount, indexType, indexBuffer, indexBufferOffset, instanceCount);
}

_MTL_INLINE void MTL::RenderCommandEncoder::drawIndexedPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger indexCount, MTL::IndexType indexType, const MTL::Buffer* indexBuffer, NS::UInteger indexBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferOffset_), primitiveType, indexCount, indexType, indexBuffer, indexBufferOffset);
}

_MTL_INLINE void MTL::RenderCommandEncoder::drawIndexedPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger indexCount, MTL::IndexType indexType, const MTL::Buffer* indexBuffer, NS::UInteger indexBufferOffset, NS::UInteger instanceCount, NS::Integer baseVertex, NS::UInteger baseInstance)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferOffset_instanceCount_baseVertex_baseInstance_), primitiveType, indexCount, indexType, indexBuffer, indexBufferOffset, instanceCount, baseVertex, baseInstance);
}

_MTL_INLINE void MTL::RenderCommandEncoder::drawIndexedPrimitives(MTL::PrimitiveType primitiveType, MTL::IndexType indexType, const MTL::Buffer* indexBuffer, NS::UInteger indexBufferOffset, const MTL::Buffer* indirectBuffer, NS::UInteger indirectBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawIndexedPrimitives_indexType_indexBuffer_indexBufferOffset_indirectBuffer_indirectBufferOffset_), primitiveType, indexType, indexBuffer, indexBufferOffset, indirectBuffer, indirectBufferOffset);
}

_MTL_INLINE void MTL::RenderCommandEncoder::drawMeshThreadgroups(MTL::Size threadgroupsPerGrid, MTL::Size threadsPerObjectThreadgroup, MTL::Size threadsPerMeshThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawMeshThreadgroups_threadsPerObjectThreadgroup_threadsPerMeshThreadgroup_), threadgroupsPerGrid, threadsPerObjectThreadgroup, threadsPerMeshThreadgroup);
}

_MTL_INLINE void MTL::RenderCommandEncoder::drawMeshThreadgroups(const MTL::Buffer* indirectBuffer, NS::UInteger indirectBufferOffset, MTL::Size threadsPerObjectThreadgroup, MTL::Size threadsPerMeshThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawMeshThreadgroupsWithIndirectBuffer_indirectBufferOffset_threadsPerObjectThreadgroup_threadsPerMeshThreadgroup_), indirectBuffer, indirectBufferOffset, threadsPerObjectThreadgroup, threadsPerMeshThreadgroup);
}

_MTL_INLINE void MTL::RenderCommandEncoder::drawMeshThreads(MTL::Size threadsPerGrid, MTL::Size threadsPerObjectThreadgroup, MTL::Size threadsPerMeshThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawMeshThreads_threadsPerObjectThreadgroup_threadsPerMeshThreadgroup_), threadsPerGrid, threadsPerObjectThreadgroup, threadsPerMeshThreadgroup);
}

_MTL_INLINE void MTL::RenderCommandEncoder::drawPatches(NS::UInteger numberOfPatchControlPoints, NS::UInteger patchStart, NS::UInteger patchCount, const MTL::Buffer* patchIndexBuffer, NS::UInteger patchIndexBufferOffset, NS::UInteger instanceCount, NS::UInteger baseInstance)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawPatches_patchStart_patchCount_patchIndexBuffer_patchIndexBufferOffset_instanceCount_baseInstance_), numberOfPatchControlPoints, patchStart, patchCount, patchIndexBuffer, patchIndexBufferOffset, instanceCount, baseInstance);
}

_MTL_INLINE void MTL::RenderCommandEncoder::drawPatches(NS::UInteger numberOfPatchControlPoints, const MTL::Buffer* patchIndexBuffer, NS::UInteger patchIndexBufferOffset, const MTL::Buffer* indirectBuffer, NS::UInteger indirectBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawPatches_patchIndexBuffer_patchIndexBufferOffset_indirectBuffer_indirectBufferOffset_), numberOfPatchControlPoints, patchIndexBuffer, patchIndexBufferOffset, indirectBuffer, indirectBufferOffset);
}

_MTL_INLINE void MTL::RenderCommandEncoder::drawPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger vertexStart, NS::UInteger vertexCount, NS::UInteger instanceCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawPrimitives_vertexStart_vertexCount_instanceCount_), primitiveType, vertexStart, vertexCount, instanceCount);
}

_MTL_INLINE void MTL::RenderCommandEncoder::drawPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger vertexStart, NS::UInteger vertexCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawPrimitives_vertexStart_vertexCount_), primitiveType, vertexStart, vertexCount);
}

_MTL_INLINE void MTL::RenderCommandEncoder::drawPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger vertexStart, NS::UInteger vertexCount, NS::UInteger instanceCount, NS::UInteger baseInstance)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawPrimitives_vertexStart_vertexCount_instanceCount_baseInstance_), primitiveType, vertexStart, vertexCount, instanceCount, baseInstance);
}

_MTL_INLINE void MTL::RenderCommandEncoder::drawPrimitives(MTL::PrimitiveType primitiveType, const MTL::Buffer* indirectBuffer, NS::UInteger indirectBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawPrimitives_indirectBuffer_indirectBufferOffset_), primitiveType, indirectBuffer, indirectBufferOffset);
}

_MTL_INLINE void MTL::RenderCommandEncoder::executeCommandsInBuffer(const MTL::IndirectCommandBuffer* indirectCommandBuffer, NS::Range executionRange)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(executeCommandsInBuffer_withRange_), indirectCommandBuffer, executionRange);
}

_MTL_INLINE void MTL::RenderCommandEncoder::executeCommandsInBuffer(const MTL::IndirectCommandBuffer* indirectCommandbuffer, const MTL::Buffer* indirectRangeBuffer, NS::UInteger indirectBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(executeCommandsInBuffer_indirectBuffer_indirectBufferOffset_), indirectCommandbuffer, indirectRangeBuffer, indirectBufferOffset);
}

_MTL_INLINE void MTL::RenderCommandEncoder::memoryBarrier(MTL::BarrierScope scope, MTL::RenderStages after, MTL::RenderStages before)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(memoryBarrierWithScope_afterStages_beforeStages_), scope, after, before);
}

_MTL_INLINE void MTL::RenderCommandEncoder::memoryBarrier(const MTL::Resource* const resources[], NS::UInteger count, MTL::RenderStages after, MTL::RenderStages before)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(memoryBarrierWithResources_count_afterStages_beforeStages_), resources, count, after, before);
}

_MTL_INLINE void MTL::RenderCommandEncoder::sampleCountersInBuffer(const MTL::CounterSampleBuffer* sampleBuffer, NS::UInteger sampleIndex, bool barrier)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(sampleCountersInBuffer_atSampleIndex_withBarrier_), sampleBuffer, sampleIndex, barrier);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setBlendColor(float red, float green, float blue, float alpha)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBlendColorRed_green_blue_alpha_), red, green, blue, alpha);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setColorAttachmentMap(const MTL::LogicalToPhysicalColorAttachmentMap* mapping)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setColorAttachmentMap_), mapping);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setColorStoreAction(MTL::StoreAction storeAction, NS::UInteger colorAttachmentIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setColorStoreAction_atIndex_), storeAction, colorAttachmentIndex);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setColorStoreActionOptions(MTL::StoreActionOptions storeActionOptions, NS::UInteger colorAttachmentIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setColorStoreActionOptions_atIndex_), storeActionOptions, colorAttachmentIndex);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setCullMode(MTL::CullMode cullMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setCullMode_), cullMode);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setDepthBias(float depthBias, float slopeScale, float clamp)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthBias_slopeScale_clamp_), depthBias, slopeScale, clamp);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setDepthClipMode(MTL::DepthClipMode depthClipMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthClipMode_), depthClipMode);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setDepthStencilState(const MTL::DepthStencilState* depthStencilState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthStencilState_), depthStencilState);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setDepthStoreAction(MTL::StoreAction storeAction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthStoreAction_), storeAction);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setDepthStoreActionOptions(MTL::StoreActionOptions storeActionOptions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthStoreActionOptions_), storeActionOptions);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setDepthTestBounds(float minBound, float maxBound)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthTestMinBound_maxBound_), minBound, maxBound);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setFragmentAccelerationStructure(const MTL::AccelerationStructure* accelerationStructure, NS::UInteger bufferIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentAccelerationStructure_atBufferIndex_), accelerationStructure, bufferIndex);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setFragmentBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentBuffer_offset_atIndex_), buffer, offset, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setFragmentBufferOffset(NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentBufferOffset_atIndex_), offset, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setFragmentBuffers(const MTL::Buffer* const buffers[], const NS::UInteger offsets[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentBuffers_offsets_withRange_), buffers, offsets, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setFragmentBytes(const void* bytes, NS::UInteger length, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentBytes_length_atIndex_), bytes, length, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setFragmentIntersectionFunctionTable(const MTL::IntersectionFunctionTable* intersectionFunctionTable, NS::UInteger bufferIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentIntersectionFunctionTable_atBufferIndex_), intersectionFunctionTable, bufferIndex);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setFragmentIntersectionFunctionTables(const MTL::IntersectionFunctionTable* const intersectionFunctionTables[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentIntersectionFunctionTables_withBufferRange_), intersectionFunctionTables, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setFragmentSamplerState(const MTL::SamplerState* sampler, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentSamplerState_atIndex_), sampler, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setFragmentSamplerState(const MTL::SamplerState* sampler, float lodMinClamp, float lodMaxClamp, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentSamplerState_lodMinClamp_lodMaxClamp_atIndex_), sampler, lodMinClamp, lodMaxClamp, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setFragmentSamplerStates(const MTL::SamplerState* const samplers[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentSamplerStates_withRange_), samplers, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setFragmentSamplerStates(const MTL::SamplerState* const samplers[], const float lodMinClamps[], const float lodMaxClamps[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentSamplerStates_lodMinClamps_lodMaxClamps_withRange_), samplers, lodMinClamps, lodMaxClamps, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setFragmentTexture(const MTL::Texture* texture, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentTexture_atIndex_), texture, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setFragmentTextures(const MTL::Texture* const textures[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentTextures_withRange_), textures, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setFragmentVisibleFunctionTable(const MTL::VisibleFunctionTable* functionTable, NS::UInteger bufferIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentVisibleFunctionTable_atBufferIndex_), functionTable, bufferIndex);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setFragmentVisibleFunctionTables(const MTL::VisibleFunctionTable* const functionTables[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentVisibleFunctionTables_withBufferRange_), functionTables, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setFrontFacingWinding(MTL::Winding frontFacingWinding)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFrontFacingWinding_), frontFacingWinding);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setMeshBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMeshBuffer_offset_atIndex_), buffer, offset, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setMeshBufferOffset(NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMeshBufferOffset_atIndex_), offset, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setMeshBuffers(const MTL::Buffer* const buffers[], const NS::UInteger* offsets, NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMeshBuffers_offsets_withRange_), buffers, offsets, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setMeshBytes(const void* bytes, NS::UInteger length, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMeshBytes_length_atIndex_), bytes, length, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setMeshSamplerState(const MTL::SamplerState* sampler, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMeshSamplerState_atIndex_), sampler, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setMeshSamplerState(const MTL::SamplerState* sampler, float lodMinClamp, float lodMaxClamp, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMeshSamplerState_lodMinClamp_lodMaxClamp_atIndex_), sampler, lodMinClamp, lodMaxClamp, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setMeshSamplerStates(const MTL::SamplerState* const samplers[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMeshSamplerStates_withRange_), samplers, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setMeshSamplerStates(const MTL::SamplerState* const samplers[], const float* lodMinClamps, const float* lodMaxClamps, NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMeshSamplerStates_lodMinClamps_lodMaxClamps_withRange_), samplers, lodMinClamps, lodMaxClamps, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setMeshTexture(const MTL::Texture* texture, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMeshTexture_atIndex_), texture, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setMeshTextures(const MTL::Texture* const textures[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMeshTextures_withRange_), textures, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setObjectBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectBuffer_offset_atIndex_), buffer, offset, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setObjectBufferOffset(NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectBufferOffset_atIndex_), offset, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setObjectBuffers(const MTL::Buffer* const buffers[], const NS::UInteger* offsets, NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectBuffers_offsets_withRange_), buffers, offsets, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setObjectBytes(const void* bytes, NS::UInteger length, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectBytes_length_atIndex_), bytes, length, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setObjectSamplerState(const MTL::SamplerState* sampler, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectSamplerState_atIndex_), sampler, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setObjectSamplerState(const MTL::SamplerState* sampler, float lodMinClamp, float lodMaxClamp, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectSamplerState_lodMinClamp_lodMaxClamp_atIndex_), sampler, lodMinClamp, lodMaxClamp, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setObjectSamplerStates(const MTL::SamplerState* const samplers[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectSamplerStates_withRange_), samplers, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setObjectSamplerStates(const MTL::SamplerState* const samplers[], const float* lodMinClamps, const float* lodMaxClamps, NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectSamplerStates_lodMinClamps_lodMaxClamps_withRange_), samplers, lodMinClamps, lodMaxClamps, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setObjectTexture(const MTL::Texture* texture, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectTexture_atIndex_), texture, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setObjectTextures(const MTL::Texture* const textures[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectTextures_withRange_), textures, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setObjectThreadgroupMemoryLength(NS::UInteger length, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectThreadgroupMemoryLength_atIndex_), length, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setRenderPipelineState(const MTL::RenderPipelineState* pipelineState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRenderPipelineState_), pipelineState);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setScissorRect(MTL::ScissorRect rect)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setScissorRect_), rect);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setScissorRects(const MTL::ScissorRect* scissorRects, NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setScissorRects_count_), scissorRects, count);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setStencilReferenceValue(uint32_t referenceValue)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStencilReferenceValue_), referenceValue);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setStencilReferenceValues(uint32_t frontReferenceValue, uint32_t backReferenceValue)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStencilFrontReferenceValue_backReferenceValue_), frontReferenceValue, backReferenceValue);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setStencilStoreAction(MTL::StoreAction storeAction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStencilStoreAction_), storeAction);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setStencilStoreActionOptions(MTL::StoreActionOptions storeActionOptions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStencilStoreActionOptions_), storeActionOptions);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setTessellationFactorBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger instanceStride)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTessellationFactorBuffer_offset_instanceStride_), buffer, offset, instanceStride);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setTessellationFactorScale(float scale)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTessellationFactorScale_), scale);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setThreadgroupMemoryLength(NS::UInteger length, NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setThreadgroupMemoryLength_offset_atIndex_), length, offset, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setTileAccelerationStructure(const MTL::AccelerationStructure* accelerationStructure, NS::UInteger bufferIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileAccelerationStructure_atBufferIndex_), accelerationStructure, bufferIndex);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setTileBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileBuffer_offset_atIndex_), buffer, offset, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setTileBufferOffset(NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileBufferOffset_atIndex_), offset, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setTileBuffers(const MTL::Buffer* const buffers[], const NS::UInteger* offsets, NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileBuffers_offsets_withRange_), buffers, offsets, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setTileBytes(const void* bytes, NS::UInteger length, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileBytes_length_atIndex_), bytes, length, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setTileIntersectionFunctionTable(const MTL::IntersectionFunctionTable* intersectionFunctionTable, NS::UInteger bufferIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileIntersectionFunctionTable_atBufferIndex_), intersectionFunctionTable, bufferIndex);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setTileIntersectionFunctionTables(const MTL::IntersectionFunctionTable* const intersectionFunctionTables[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileIntersectionFunctionTables_withBufferRange_), intersectionFunctionTables, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setTileSamplerState(const MTL::SamplerState* sampler, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileSamplerState_atIndex_), sampler, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setTileSamplerState(const MTL::SamplerState* sampler, float lodMinClamp, float lodMaxClamp, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileSamplerState_lodMinClamp_lodMaxClamp_atIndex_), sampler, lodMinClamp, lodMaxClamp, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setTileSamplerStates(const MTL::SamplerState* const samplers[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileSamplerStates_withRange_), samplers, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setTileSamplerStates(const MTL::SamplerState* const samplers[], const float lodMinClamps[], const float lodMaxClamps[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileSamplerStates_lodMinClamps_lodMaxClamps_withRange_), samplers, lodMinClamps, lodMaxClamps, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setTileTexture(const MTL::Texture* texture, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileTexture_atIndex_), texture, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setTileTextures(const MTL::Texture* const textures[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileTextures_withRange_), textures, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setTileVisibleFunctionTable(const MTL::VisibleFunctionTable* functionTable, NS::UInteger bufferIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileVisibleFunctionTable_atBufferIndex_), functionTable, bufferIndex);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setTileVisibleFunctionTables(const MTL::VisibleFunctionTable* const functionTables[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileVisibleFunctionTables_withBufferRange_), functionTables, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setTriangleFillMode(MTL::TriangleFillMode fillMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTriangleFillMode_), fillMode);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexAccelerationStructure(const MTL::AccelerationStructure* accelerationStructure, NS::UInteger bufferIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexAccelerationStructure_atBufferIndex_), accelerationStructure, bufferIndex);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexAmplificationCount(NS::UInteger count, const MTL::VertexAmplificationViewMapping* viewMappings)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexAmplificationCount_viewMappings_), count, viewMappings);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexBuffer_offset_atIndex_), buffer, offset, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger stride, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexBuffer_offset_attributeStride_atIndex_), buffer, offset, stride, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexBufferOffset(NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexBufferOffset_atIndex_), offset, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexBufferOffset(NS::UInteger offset, NS::UInteger stride, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexBufferOffset_attributeStride_atIndex_), offset, stride, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexBuffers(const MTL::Buffer* const buffers[], const NS::UInteger offsets[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexBuffers_offsets_withRange_), buffers, offsets, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexBuffers(const MTL::Buffer* const buffers[], const NS::UInteger* offsets, const NS::UInteger* strides, NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexBuffers_offsets_attributeStrides_withRange_), buffers, offsets, strides, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexBytes(const void* bytes, NS::UInteger length, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexBytes_length_atIndex_), bytes, length, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexBytes(const void* bytes, NS::UInteger length, NS::UInteger stride, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexBytes_length_attributeStride_atIndex_), bytes, length, stride, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexIntersectionFunctionTable(const MTL::IntersectionFunctionTable* intersectionFunctionTable, NS::UInteger bufferIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexIntersectionFunctionTable_atBufferIndex_), intersectionFunctionTable, bufferIndex);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexIntersectionFunctionTables(const MTL::IntersectionFunctionTable* const intersectionFunctionTables[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexIntersectionFunctionTables_withBufferRange_), intersectionFunctionTables, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexSamplerState(const MTL::SamplerState* sampler, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexSamplerState_atIndex_), sampler, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexSamplerState(const MTL::SamplerState* sampler, float lodMinClamp, float lodMaxClamp, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexSamplerState_lodMinClamp_lodMaxClamp_atIndex_), sampler, lodMinClamp, lodMaxClamp, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexSamplerStates(const MTL::SamplerState* const samplers[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexSamplerStates_withRange_), samplers, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexSamplerStates(const MTL::SamplerState* const samplers[], const float lodMinClamps[], const float lodMaxClamps[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexSamplerStates_lodMinClamps_lodMaxClamps_withRange_), samplers, lodMinClamps, lodMaxClamps, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexTexture(const MTL::Texture* texture, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexTexture_atIndex_), texture, index);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexTextures(const MTL::Texture* const textures[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexTextures_withRange_), textures, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexVisibleFunctionTable(const MTL::VisibleFunctionTable* functionTable, NS::UInteger bufferIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexVisibleFunctionTable_atBufferIndex_), functionTable, bufferIndex);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVertexVisibleFunctionTables(const MTL::VisibleFunctionTable* const functionTables[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexVisibleFunctionTables_withBufferRange_), functionTables, range);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setViewport(MTL::Viewport viewport)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setViewport_), viewport);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setViewports(const MTL::Viewport* viewports, NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setViewports_count_), viewports, count);
}

_MTL_INLINE void MTL::RenderCommandEncoder::setVisibilityResultMode(MTL::VisibilityResultMode mode, NS::UInteger offset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVisibilityResultMode_offset_), mode, offset);
}

_MTL_INLINE void MTL::RenderCommandEncoder::textureBarrier()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(textureBarrier));
}

_MTL_INLINE NS::UInteger MTL::RenderCommandEncoder::tileHeight() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(tileHeight));
}

_MTL_INLINE NS::UInteger MTL::RenderCommandEncoder::tileWidth() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(tileWidth));
}

_MTL_INLINE void MTL::RenderCommandEncoder::updateFence(const MTL::Fence* fence, MTL::RenderStages stages)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(updateFence_afterStages_), fence, stages);
}

_MTL_INLINE void MTL::RenderCommandEncoder::useHeap(const MTL::Heap* heap)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useHeap_), heap);
}

_MTL_INLINE void MTL::RenderCommandEncoder::useHeap(const MTL::Heap* heap, MTL::RenderStages stages)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useHeap_stages_), heap, stages);
}

_MTL_INLINE void MTL::RenderCommandEncoder::useHeaps(const MTL::Heap* const heaps[], NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useHeaps_count_), heaps, count);
}

_MTL_INLINE void MTL::RenderCommandEncoder::useHeaps(const MTL::Heap* const heaps[], NS::UInteger count, MTL::RenderStages stages)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useHeaps_count_stages_), heaps, count, stages);
}

_MTL_INLINE void MTL::RenderCommandEncoder::useResource(const MTL::Resource* resource, MTL::ResourceUsage usage)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useResource_usage_), resource, usage);
}

_MTL_INLINE void MTL::RenderCommandEncoder::useResource(const MTL::Resource* resource, MTL::ResourceUsage usage, MTL::RenderStages stages)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useResource_usage_stages_), resource, usage, stages);
}

_MTL_INLINE void MTL::RenderCommandEncoder::useResources(const MTL::Resource* const resources[], NS::UInteger count, MTL::ResourceUsage usage)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useResources_count_usage_), resources, count, usage);
}

_MTL_INLINE void MTL::RenderCommandEncoder::useResources(const MTL::Resource* const resources[], NS::UInteger count, MTL::ResourceUsage usage, MTL::RenderStages stages)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useResources_count_usage_stages_), resources, count, usage, stages);
}

_MTL_INLINE void MTL::RenderCommandEncoder::waitForFence(const MTL::Fence* fence, MTL::RenderStages stages)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(waitForFence_beforeStages_), fence, stages);
}

namespace MTL
{
class Buffer;
class ComputePipelineState;
class RenderPipelineState;

class IndirectRenderCommand : public NS::Referencing<IndirectRenderCommand>
{
public:
    void clearBarrier();

    void drawIndexedPatches(NS::UInteger numberOfPatchControlPoints, NS::UInteger patchStart, NS::UInteger patchCount, const MTL::Buffer* patchIndexBuffer, NS::UInteger patchIndexBufferOffset, const MTL::Buffer* controlPointIndexBuffer, NS::UInteger controlPointIndexBufferOffset, NS::UInteger instanceCount, NS::UInteger baseInstance, const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger instanceStride);

    void drawIndexedPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger indexCount, MTL::IndexType indexType, const MTL::Buffer* indexBuffer, NS::UInteger indexBufferOffset, NS::UInteger instanceCount, NS::Integer baseVertex, NS::UInteger baseInstance);

    void drawMeshThreadgroups(MTL::Size threadgroupsPerGrid, MTL::Size threadsPerObjectThreadgroup, MTL::Size threadsPerMeshThreadgroup);

    void drawMeshThreads(MTL::Size threadsPerGrid, MTL::Size threadsPerObjectThreadgroup, MTL::Size threadsPerMeshThreadgroup);

    void drawPatches(NS::UInteger numberOfPatchControlPoints, NS::UInteger patchStart, NS::UInteger patchCount, const MTL::Buffer* patchIndexBuffer, NS::UInteger patchIndexBufferOffset, NS::UInteger instanceCount, NS::UInteger baseInstance, const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger instanceStride);

    void drawPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger vertexStart, NS::UInteger vertexCount, NS::UInteger instanceCount, NS::UInteger baseInstance);

    void reset();

    void setBarrier();

    void setCullMode(MTL::CullMode cullMode);

    void setDepthBias(float depthBias, float slopeScale, float clamp);

    void setDepthClipMode(MTL::DepthClipMode depthClipMode);

    void setDepthStencilState(const MTL::DepthStencilState* depthStencilState);

    void setFragmentBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index);

    void setFrontFacingWinding(MTL::Winding frontFacingWindning);

    void setMeshBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index);

    void setObjectBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index);

    void setObjectThreadgroupMemoryLength(NS::UInteger length, NS::UInteger index);

    void setRenderPipelineState(const MTL::RenderPipelineState* pipelineState);

    void setTriangleFillMode(MTL::TriangleFillMode fillMode);

    void setVertexBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index);
    void setVertexBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger stride, NS::UInteger index);
};
class IndirectComputeCommand : public NS::Referencing<IndirectComputeCommand>
{
public:
    void clearBarrier();

    void concurrentDispatchThreadgroups(MTL::Size threadgroupsPerGrid, MTL::Size threadsPerThreadgroup);

    void concurrentDispatchThreads(MTL::Size threadsPerGrid, MTL::Size threadsPerThreadgroup);

    void reset();

    void setBarrier();

    void setComputePipelineState(const MTL::ComputePipelineState* pipelineState);

    void setImageblockWidth(NS::UInteger width, NS::UInteger height);

    void setKernelBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index);
    void setKernelBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger stride, NS::UInteger index);

    void setStageInRegion(MTL::Region region);

    void setThreadgroupMemoryLength(NS::UInteger length, NS::UInteger index);
};

}
_MTL_INLINE void MTL::IndirectRenderCommand::clearBarrier()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(clearBarrier));
}

_MTL_INLINE void MTL::IndirectRenderCommand::drawIndexedPatches(NS::UInteger numberOfPatchControlPoints, NS::UInteger patchStart, NS::UInteger patchCount, const MTL::Buffer* patchIndexBuffer, NS::UInteger patchIndexBufferOffset, const MTL::Buffer* controlPointIndexBuffer, NS::UInteger controlPointIndexBufferOffset, NS::UInteger instanceCount, NS::UInteger baseInstance, const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger instanceStride)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawIndexedPatches_patchStart_patchCount_patchIndexBuffer_patchIndexBufferOffset_controlPointIndexBuffer_controlPointIndexBufferOffset_instanceCount_baseInstance_tessellationFactorBuffer_tessellationFactorBufferOffset_tessellationFactorBufferInstanceStride_), numberOfPatchControlPoints, patchStart, patchCount, patchIndexBuffer, patchIndexBufferOffset, controlPointIndexBuffer, controlPointIndexBufferOffset, instanceCount, baseInstance, buffer, offset, instanceStride);
}

_MTL_INLINE void MTL::IndirectRenderCommand::drawIndexedPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger indexCount, MTL::IndexType indexType, const MTL::Buffer* indexBuffer, NS::UInteger indexBufferOffset, NS::UInteger instanceCount, NS::Integer baseVertex, NS::UInteger baseInstance)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferOffset_instanceCount_baseVertex_baseInstance_), primitiveType, indexCount, indexType, indexBuffer, indexBufferOffset, instanceCount, baseVertex, baseInstance);
}

_MTL_INLINE void MTL::IndirectRenderCommand::drawMeshThreadgroups(MTL::Size threadgroupsPerGrid, MTL::Size threadsPerObjectThreadgroup, MTL::Size threadsPerMeshThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawMeshThreadgroups_threadsPerObjectThreadgroup_threadsPerMeshThreadgroup_), threadgroupsPerGrid, threadsPerObjectThreadgroup, threadsPerMeshThreadgroup);
}

_MTL_INLINE void MTL::IndirectRenderCommand::drawMeshThreads(MTL::Size threadsPerGrid, MTL::Size threadsPerObjectThreadgroup, MTL::Size threadsPerMeshThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawMeshThreads_threadsPerObjectThreadgroup_threadsPerMeshThreadgroup_), threadsPerGrid, threadsPerObjectThreadgroup, threadsPerMeshThreadgroup);
}

_MTL_INLINE void MTL::IndirectRenderCommand::drawPatches(NS::UInteger numberOfPatchControlPoints, NS::UInteger patchStart, NS::UInteger patchCount, const MTL::Buffer* patchIndexBuffer, NS::UInteger patchIndexBufferOffset, NS::UInteger instanceCount, NS::UInteger baseInstance, const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger instanceStride)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawPatches_patchStart_patchCount_patchIndexBuffer_patchIndexBufferOffset_instanceCount_baseInstance_tessellationFactorBuffer_tessellationFactorBufferOffset_tessellationFactorBufferInstanceStride_), numberOfPatchControlPoints, patchStart, patchCount, patchIndexBuffer, patchIndexBufferOffset, instanceCount, baseInstance, buffer, offset, instanceStride);
}

_MTL_INLINE void MTL::IndirectRenderCommand::drawPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger vertexStart, NS::UInteger vertexCount, NS::UInteger instanceCount, NS::UInteger baseInstance)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawPrimitives_vertexStart_vertexCount_instanceCount_baseInstance_), primitiveType, vertexStart, vertexCount, instanceCount, baseInstance);
}

_MTL_INLINE void MTL::IndirectRenderCommand::reset()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(reset));
}

_MTL_INLINE void MTL::IndirectRenderCommand::setBarrier()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBarrier));
}

_MTL_INLINE void MTL::IndirectRenderCommand::setCullMode(MTL::CullMode cullMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setCullMode_), cullMode);
}

_MTL_INLINE void MTL::IndirectRenderCommand::setDepthBias(float depthBias, float slopeScale, float clamp)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthBias_slopeScale_clamp_), depthBias, slopeScale, clamp);
}

_MTL_INLINE void MTL::IndirectRenderCommand::setDepthClipMode(MTL::DepthClipMode depthClipMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthClipMode_), depthClipMode);
}

_MTL_INLINE void MTL::IndirectRenderCommand::setDepthStencilState(const MTL::DepthStencilState* depthStencilState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthStencilState_), depthStencilState);
}

_MTL_INLINE void MTL::IndirectRenderCommand::setFragmentBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentBuffer_offset_atIndex_), buffer, offset, index);
}

_MTL_INLINE void MTL::IndirectRenderCommand::setFrontFacingWinding(MTL::Winding frontFacingWindning)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFrontFacingWinding_), frontFacingWindning);
}

_MTL_INLINE void MTL::IndirectRenderCommand::setMeshBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMeshBuffer_offset_atIndex_), buffer, offset, index);
}

_MTL_INLINE void MTL::IndirectRenderCommand::setObjectBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectBuffer_offset_atIndex_), buffer, offset, index);
}

_MTL_INLINE void MTL::IndirectRenderCommand::setObjectThreadgroupMemoryLength(NS::UInteger length, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectThreadgroupMemoryLength_atIndex_), length, index);
}

_MTL_INLINE void MTL::IndirectRenderCommand::setRenderPipelineState(const MTL::RenderPipelineState* pipelineState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRenderPipelineState_), pipelineState);
}

_MTL_INLINE void MTL::IndirectRenderCommand::setTriangleFillMode(MTL::TriangleFillMode fillMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTriangleFillMode_), fillMode);
}

_MTL_INLINE void MTL::IndirectRenderCommand::setVertexBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexBuffer_offset_atIndex_), buffer, offset, index);
}

_MTL_INLINE void MTL::IndirectRenderCommand::setVertexBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger stride, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexBuffer_offset_attributeStride_atIndex_), buffer, offset, stride, index);
}

_MTL_INLINE void MTL::IndirectComputeCommand::clearBarrier()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(clearBarrier));
}

_MTL_INLINE void MTL::IndirectComputeCommand::concurrentDispatchThreadgroups(MTL::Size threadgroupsPerGrid, MTL::Size threadsPerThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(concurrentDispatchThreadgroups_threadsPerThreadgroup_), threadgroupsPerGrid, threadsPerThreadgroup);
}

_MTL_INLINE void MTL::IndirectComputeCommand::concurrentDispatchThreads(MTL::Size threadsPerGrid, MTL::Size threadsPerThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(concurrentDispatchThreads_threadsPerThreadgroup_), threadsPerGrid, threadsPerThreadgroup);
}

_MTL_INLINE void MTL::IndirectComputeCommand::reset()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(reset));
}

_MTL_INLINE void MTL::IndirectComputeCommand::setBarrier()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBarrier));
}

_MTL_INLINE void MTL::IndirectComputeCommand::setComputePipelineState(const MTL::ComputePipelineState* pipelineState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setComputePipelineState_), pipelineState);
}

_MTL_INLINE void MTL::IndirectComputeCommand::setImageblockWidth(NS::UInteger width, NS::UInteger height)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setImageblockWidth_height_), width, height);
}

_MTL_INLINE void MTL::IndirectComputeCommand::setKernelBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setKernelBuffer_offset_atIndex_), buffer, offset, index);
}

_MTL_INLINE void MTL::IndirectComputeCommand::setKernelBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger stride, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setKernelBuffer_offset_attributeStride_atIndex_), buffer, offset, stride, index);
}

_MTL_INLINE void MTL::IndirectComputeCommand::setStageInRegion(MTL::Region region)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStageInRegion_), region);
}

_MTL_INLINE void MTL::IndirectComputeCommand::setThreadgroupMemoryLength(NS::UInteger length, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setThreadgroupMemoryLength_atIndex_), length, index);
}

#pragma once

#include <cstdint>

namespace MTL
{
class Buffer;
class FunctionHandle;
class IntersectionFunctionTableDescriptor;
class VisibleFunctionTable;

_MTL_OPTIONS(NS::UInteger, IntersectionFunctionSignature) {
    IntersectionFunctionSignatureNone = 0,
    IntersectionFunctionSignatureInstancing = 1,
    IntersectionFunctionSignatureTriangleData = 1 << 1,
    IntersectionFunctionSignatureWorldSpaceData = 1 << 2,
    IntersectionFunctionSignatureInstanceMotion = 1 << 3,
    IntersectionFunctionSignaturePrimitiveMotion = 1 << 4,
    IntersectionFunctionSignatureExtendedLimits = 1 << 5,
    IntersectionFunctionSignatureMaxLevels = 1 << 6,
    IntersectionFunctionSignatureCurveData = 1 << 7,
    IntersectionFunctionSignatureIntersectionFunctionBuffer = 1 << 8,
    IntersectionFunctionSignatureUserData = 1 << 9,
};

struct IntersectionFunctionBufferArguments
{
    uint64_t intersectionFunctionBuffer;
    uint64_t intersectionFunctionBufferSize;
    uint64_t intersectionFunctionStride;
} _MTL_PACKED;

class IntersectionFunctionTableDescriptor : public NS::Copying<IntersectionFunctionTableDescriptor>
{
public:
    static IntersectionFunctionTableDescriptor* alloc();

    NS::UInteger                                functionCount() const;

    IntersectionFunctionTableDescriptor*        init();

    static IntersectionFunctionTableDescriptor* intersectionFunctionTableDescriptor();

    void                                        setFunctionCount(NS::UInteger functionCount);
};
class IntersectionFunctionTable : public NS::Referencing<IntersectionFunctionTable, Resource>
{
public:
    ResourceID gpuResourceID() const;

    void       setBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index);
    void       setBuffers(const MTL::Buffer* const buffers[], const NS::UInteger offsets[], NS::Range range);

    void       setFunction(const MTL::FunctionHandle* function, NS::UInteger index);
    void       setFunctions(const MTL::FunctionHandle* const functions[], NS::Range range);

    void       setOpaqueCurveIntersectionFunction(MTL::IntersectionFunctionSignature signature, NS::UInteger index);
    void       setOpaqueCurveIntersectionFunction(MTL::IntersectionFunctionSignature signature, NS::Range range);

    void       setOpaqueTriangleIntersectionFunction(MTL::IntersectionFunctionSignature signature, NS::UInteger index);
    void       setOpaqueTriangleIntersectionFunction(MTL::IntersectionFunctionSignature signature, NS::Range range);

    void       setVisibleFunctionTable(const MTL::VisibleFunctionTable* functionTable, NS::UInteger bufferIndex);
    void       setVisibleFunctionTables(const MTL::VisibleFunctionTable* const functionTables[], NS::Range bufferRange);
};

}

_MTL_INLINE MTL::IntersectionFunctionTableDescriptor* MTL::IntersectionFunctionTableDescriptor::alloc()
{
    return NS::Object::alloc<MTL::IntersectionFunctionTableDescriptor>(_MTL_PRIVATE_CLS(MTLIntersectionFunctionTableDescriptor));
}

_MTL_INLINE NS::UInteger MTL::IntersectionFunctionTableDescriptor::functionCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(functionCount));
}

_MTL_INLINE MTL::IntersectionFunctionTableDescriptor* MTL::IntersectionFunctionTableDescriptor::init()
{
    return NS::Object::init<MTL::IntersectionFunctionTableDescriptor>();
}

_MTL_INLINE MTL::IntersectionFunctionTableDescriptor* MTL::IntersectionFunctionTableDescriptor::intersectionFunctionTableDescriptor()
{
    return Object::sendMessage<MTL::IntersectionFunctionTableDescriptor*>(_MTL_PRIVATE_CLS(MTLIntersectionFunctionTableDescriptor), _MTL_PRIVATE_SEL(intersectionFunctionTableDescriptor));
}

_MTL_INLINE void MTL::IntersectionFunctionTableDescriptor::setFunctionCount(NS::UInteger functionCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFunctionCount_), functionCount);
}

_MTL_INLINE MTL::ResourceID MTL::IntersectionFunctionTable::gpuResourceID() const
{
    return Object::sendMessage<MTL::ResourceID>(this, _MTL_PRIVATE_SEL(gpuResourceID));
}

_MTL_INLINE void MTL::IntersectionFunctionTable::setBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBuffer_offset_atIndex_), buffer, offset, index);
}

_MTL_INLINE void MTL::IntersectionFunctionTable::setBuffers(const MTL::Buffer* const buffers[], const NS::UInteger offsets[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBuffers_offsets_withRange_), buffers, offsets, range);
}

_MTL_INLINE void MTL::IntersectionFunctionTable::setFunction(const MTL::FunctionHandle* function, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFunction_atIndex_), function, index);
}

_MTL_INLINE void MTL::IntersectionFunctionTable::setFunctions(const MTL::FunctionHandle* const functions[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFunctions_withRange_), functions, range);
}

_MTL_INLINE void MTL::IntersectionFunctionTable::setOpaqueCurveIntersectionFunction(MTL::IntersectionFunctionSignature signature, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setOpaqueCurveIntersectionFunctionWithSignature_atIndex_), signature, index);
}

_MTL_INLINE void MTL::IntersectionFunctionTable::setOpaqueCurveIntersectionFunction(MTL::IntersectionFunctionSignature signature, NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setOpaqueCurveIntersectionFunctionWithSignature_withRange_), signature, range);
}

_MTL_INLINE void MTL::IntersectionFunctionTable::setOpaqueTriangleIntersectionFunction(MTL::IntersectionFunctionSignature signature, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setOpaqueTriangleIntersectionFunctionWithSignature_atIndex_), signature, index);
}

_MTL_INLINE void MTL::IntersectionFunctionTable::setOpaqueTriangleIntersectionFunction(MTL::IntersectionFunctionSignature signature, NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setOpaqueTriangleIntersectionFunctionWithSignature_withRange_), signature, range);
}

_MTL_INLINE void MTL::IntersectionFunctionTable::setVisibleFunctionTable(const MTL::VisibleFunctionTable* functionTable, NS::UInteger bufferIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVisibleFunctionTable_atBufferIndex_), functionTable, bufferIndex);
}

_MTL_INLINE void MTL::IntersectionFunctionTable::setVisibleFunctionTables(const MTL::VisibleFunctionTable* const functionTables[], NS::Range bufferRange)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVisibleFunctionTables_withBufferRange_), functionTables, bufferRange);
}

#pragma once

#include <cstdint>

namespace MTL
{
class Buffer;
class IOCommandBuffer;
class IOFileHandle;
class SharedEvent;
class Texture;
_MTL_ENUM(NS::Integer, IOStatus) {
    IOStatusPending = 0,
    IOStatusCancelled = 1,
    IOStatusError = 2,
    IOStatusComplete = 3,
};

using IOCommandBufferHandler = void (^)(MTL::IOCommandBuffer*);
using IOCommandBufferHandlerFunction = std::function<void(MTL::IOCommandBuffer*)>;

class IOCommandBuffer : public NS::Referencing<IOCommandBuffer>
{
public:
    void        addBarrier();

    void        addCompletedHandler(const MTL::IOCommandBufferHandler block);
    void        addCompletedHandler(const MTL::IOCommandBufferHandlerFunction& function);

    void        commit();

    void        copyStatusToBuffer(const MTL::Buffer* buffer, NS::UInteger offset);

    void        enqueue();

    NS::Error*  error() const;

    NS::String* label() const;

    void        loadBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger size, const MTL::IOFileHandle* sourceHandle, NS::UInteger sourceHandleOffset);

    void        loadBytes(const void* pointer, NS::UInteger size, const MTL::IOFileHandle* sourceHandle, NS::UInteger sourceHandleOffset);

    void        loadTexture(const MTL::Texture* texture, NS::UInteger slice, NS::UInteger level, MTL::Size size, NS::UInteger sourceBytesPerRow, NS::UInteger sourceBytesPerImage, MTL::Origin destinationOrigin, const MTL::IOFileHandle* sourceHandle, NS::UInteger sourceHandleOffset);

    void        popDebugGroup();

    void        pushDebugGroup(const NS::String* string);

    void        setLabel(const NS::String* label);

    void        signalEvent(const MTL::SharedEvent* event, uint64_t value);

    IOStatus    status() const;

    void        tryCancel();

    void        wait(const MTL::SharedEvent* event, uint64_t value);
    void        waitUntilCompleted();
};

}
_MTL_INLINE void MTL::IOCommandBuffer::addBarrier()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(addBarrier));
}

_MTL_INLINE void MTL::IOCommandBuffer::addCompletedHandler(const MTL::IOCommandBufferHandler block)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(addCompletedHandler_), block);
}

_MTL_INLINE void MTL::IOCommandBuffer::addCompletedHandler(const MTL::IOCommandBufferHandlerFunction& function)
{
    __block MTL::IOCommandBufferHandlerFunction blockFunction = function;
    addCompletedHandler(^(MTL::IOCommandBuffer* pCommandBuffer) { blockFunction(pCommandBuffer); });
}

_MTL_INLINE void MTL::IOCommandBuffer::commit()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(commit));
}

_MTL_INLINE void MTL::IOCommandBuffer::copyStatusToBuffer(const MTL::Buffer* buffer, NS::UInteger offset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyStatusToBuffer_offset_), buffer, offset);
}

_MTL_INLINE void MTL::IOCommandBuffer::enqueue()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(enqueue));
}

_MTL_INLINE NS::Error* MTL::IOCommandBuffer::error() const
{
    return Object::sendMessage<NS::Error*>(this, _MTL_PRIVATE_SEL(error));
}

_MTL_INLINE NS::String* MTL::IOCommandBuffer::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE void MTL::IOCommandBuffer::loadBuffer(const MTL::Buffer* buffer, NS::UInteger offset, NS::UInteger size, const MTL::IOFileHandle* sourceHandle, NS::UInteger sourceHandleOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(loadBuffer_offset_size_sourceHandle_sourceHandleOffset_), buffer, offset, size, sourceHandle, sourceHandleOffset);
}

_MTL_INLINE void MTL::IOCommandBuffer::loadBytes(const void* pointer, NS::UInteger size, const MTL::IOFileHandle* sourceHandle, NS::UInteger sourceHandleOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(loadBytes_size_sourceHandle_sourceHandleOffset_), pointer, size, sourceHandle, sourceHandleOffset);
}

_MTL_INLINE void MTL::IOCommandBuffer::loadTexture(const MTL::Texture* texture, NS::UInteger slice, NS::UInteger level, MTL::Size size, NS::UInteger sourceBytesPerRow, NS::UInteger sourceBytesPerImage, MTL::Origin destinationOrigin, const MTL::IOFileHandle* sourceHandle, NS::UInteger sourceHandleOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(loadTexture_slice_level_size_sourceBytesPerRow_sourceBytesPerImage_destinationOrigin_sourceHandle_sourceHandleOffset_), texture, slice, level, size, sourceBytesPerRow, sourceBytesPerImage, destinationOrigin, sourceHandle, sourceHandleOffset);
}

_MTL_INLINE void MTL::IOCommandBuffer::popDebugGroup()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(popDebugGroup));
}

_MTL_INLINE void MTL::IOCommandBuffer::pushDebugGroup(const NS::String* string)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(pushDebugGroup_), string);
}

_MTL_INLINE void MTL::IOCommandBuffer::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE void MTL::IOCommandBuffer::signalEvent(const MTL::SharedEvent* event, uint64_t value)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(signalEvent_value_), event, value);
}

_MTL_INLINE MTL::IOStatus MTL::IOCommandBuffer::status() const
{
    return Object::sendMessage<MTL::IOStatus>(this, _MTL_PRIVATE_SEL(status));
}

_MTL_INLINE void MTL::IOCommandBuffer::tryCancel()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(tryCancel));
}

_MTL_INLINE void MTL::IOCommandBuffer::wait(const MTL::SharedEvent* event, uint64_t value)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(waitForEvent_value_), event, value);
}

_MTL_INLINE void MTL::IOCommandBuffer::waitUntilCompleted()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(waitUntilCompleted));
}

#pragma once

namespace MTL
{
class Buffer;
class IOCommandBuffer;
class IOCommandQueueDescriptor;
class IOScratchBuffer;
class IOScratchBufferAllocator;
_MTL_ENUM(NS::Integer, IOPriority) {
    IOPriorityHigh = 0,
    IOPriorityNormal = 1,
    IOPriorityLow = 2,
};

_MTL_ENUM(NS::Integer, IOCommandQueueType) {
    IOCommandQueueTypeConcurrent = 0,
    IOCommandQueueTypeSerial = 1,
};

_MTL_ENUM(NS::Integer, IOError) {
    IOErrorURLInvalid = 1,
    IOErrorInternal = 2,
};

_MTL_CONST(NS::ErrorDomain, IOErrorDomain);
class IOCommandQueue : public NS::Referencing<IOCommandQueue>
{
public:
    IOCommandBuffer* commandBuffer();
    IOCommandBuffer* commandBufferWithUnretainedReferences();

    void             enqueueBarrier();

    NS::String*      label() const;
    void             setLabel(const NS::String* label);
};
class IOScratchBuffer : public NS::Referencing<IOScratchBuffer>
{
public:
    Buffer* buffer() const;
};
class IOScratchBufferAllocator : public NS::Referencing<IOScratchBufferAllocator>
{
public:
    IOScratchBuffer* newScratchBuffer(NS::UInteger minimumSize);
};
class IOCommandQueueDescriptor : public NS::Copying<IOCommandQueueDescriptor>
{
public:
    static IOCommandQueueDescriptor* alloc();

    IOCommandQueueDescriptor*        init();

    NS::UInteger                     maxCommandBufferCount() const;

    NS::UInteger                     maxCommandsInFlight() const;

    IOPriority                       priority() const;

    IOScratchBufferAllocator*        scratchBufferAllocator() const;

    void                             setMaxCommandBufferCount(NS::UInteger maxCommandBufferCount);

    void                             setMaxCommandsInFlight(NS::UInteger maxCommandsInFlight);

    void                             setPriority(MTL::IOPriority priority);

    void                             setScratchBufferAllocator(const MTL::IOScratchBufferAllocator* scratchBufferAllocator);

    void                             setType(MTL::IOCommandQueueType type);
    IOCommandQueueType               type() const;
};
class IOFileHandle : public NS::Referencing<IOFileHandle>
{
public:
    NS::String* label() const;
    void        setLabel(const NS::String* label);
};

}
_MTL_PRIVATE_DEF_WEAK_CONST(NS::ErrorDomain, IOErrorDomain);
_MTL_INLINE MTL::IOCommandBuffer* MTL::IOCommandQueue::commandBuffer()
{
    return Object::sendMessage<MTL::IOCommandBuffer*>(this, _MTL_PRIVATE_SEL(commandBuffer));
}

_MTL_INLINE MTL::IOCommandBuffer* MTL::IOCommandQueue::commandBufferWithUnretainedReferences()
{
    return Object::sendMessage<MTL::IOCommandBuffer*>(this, _MTL_PRIVATE_SEL(commandBufferWithUnretainedReferences));
}

_MTL_INLINE void MTL::IOCommandQueue::enqueueBarrier()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(enqueueBarrier));
}

_MTL_INLINE NS::String* MTL::IOCommandQueue::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE void MTL::IOCommandQueue::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE MTL::Buffer* MTL::IOScratchBuffer::buffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(buffer));
}

_MTL_INLINE MTL::IOScratchBuffer* MTL::IOScratchBufferAllocator::newScratchBuffer(NS::UInteger minimumSize)
{
    return Object::sendMessage<MTL::IOScratchBuffer*>(this, _MTL_PRIVATE_SEL(newScratchBufferWithMinimumSize_), minimumSize);
}

_MTL_INLINE MTL::IOCommandQueueDescriptor* MTL::IOCommandQueueDescriptor::alloc()
{
    return NS::Object::alloc<MTL::IOCommandQueueDescriptor>(_MTL_PRIVATE_CLS(MTLIOCommandQueueDescriptor));
}

_MTL_INLINE MTL::IOCommandQueueDescriptor* MTL::IOCommandQueueDescriptor::init()
{
    return NS::Object::init<MTL::IOCommandQueueDescriptor>();
}

_MTL_INLINE NS::UInteger MTL::IOCommandQueueDescriptor::maxCommandBufferCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxCommandBufferCount));
}

_MTL_INLINE NS::UInteger MTL::IOCommandQueueDescriptor::maxCommandsInFlight() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxCommandsInFlight));
}

_MTL_INLINE MTL::IOPriority MTL::IOCommandQueueDescriptor::priority() const
{
    return Object::sendMessage<MTL::IOPriority>(this, _MTL_PRIVATE_SEL(priority));
}

_MTL_INLINE MTL::IOScratchBufferAllocator* MTL::IOCommandQueueDescriptor::scratchBufferAllocator() const
{
    return Object::sendMessage<MTL::IOScratchBufferAllocator*>(this, _MTL_PRIVATE_SEL(scratchBufferAllocator));
}

_MTL_INLINE void MTL::IOCommandQueueDescriptor::setMaxCommandBufferCount(NS::UInteger maxCommandBufferCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxCommandBufferCount_), maxCommandBufferCount);
}

_MTL_INLINE void MTL::IOCommandQueueDescriptor::setMaxCommandsInFlight(NS::UInteger maxCommandsInFlight)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxCommandsInFlight_), maxCommandsInFlight);
}

_MTL_INLINE void MTL::IOCommandQueueDescriptor::setPriority(MTL::IOPriority priority)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPriority_), priority);
}

_MTL_INLINE void MTL::IOCommandQueueDescriptor::setScratchBufferAllocator(const MTL::IOScratchBufferAllocator* scratchBufferAllocator)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setScratchBufferAllocator_), scratchBufferAllocator);
}

_MTL_INLINE void MTL::IOCommandQueueDescriptor::setType(MTL::IOCommandQueueType type)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setType_), type);
}

_MTL_INLINE MTL::IOCommandQueueType MTL::IOCommandQueueDescriptor::type() const
{
    return Object::sendMessage<MTL::IOCommandQueueType>(this, _MTL_PRIVATE_SEL(type));
}

_MTL_INLINE NS::String* MTL::IOFileHandle::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE void MTL::IOFileHandle::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

#pragma once

namespace MTL
{
using IOCompressionContext=void*;

_MTL_ENUM(NS::Integer, IOCompressionStatus) {
    IOCompressionStatusComplete = 0,
    IOCompressionStatusError = 1,
};

size_t IOCompressionContextDefaultChunkSize();

IOCompressionContext IOCreateCompressionContext(const char* path, IOCompressionMethod type, size_t chunkSize);

void IOCompressionContextAppendData(IOCompressionContext context, const void* data, size_t size);

IOCompressionStatus IOFlushAndDestroyCompressionContext(IOCompressionContext context);

}

#if defined(MTL_PRIVATE_IMPLEMENTATION)

namespace MTL::Private {

MTL_DEF_FUNC(MTLIOCompressionContextDefaultChunkSize, size_t (*)(void));

MTL_DEF_FUNC( MTLIOCreateCompressionContext, void* (*)(const char*, MTL::IOCompressionMethod, size_t) );

MTL_DEF_FUNC( MTLIOCompressionContextAppendData, void (*)(void*, const void*, size_t) );

MTL_DEF_FUNC( MTLIOFlushAndDestroyCompressionContext, MTL::IOCompressionStatus (*)(void*) );

}

_NS_EXPORT size_t MTL::IOCompressionContextDefaultChunkSize()
{
    return MTL::Private::MTLIOCompressionContextDefaultChunkSize();
}

_NS_EXPORT void* MTL::IOCreateCompressionContext(const char* path, IOCompressionMethod type, size_t chunkSize)
{
    if ( MTL::Private::MTLIOCreateCompressionContext )
    {
        return MTL::Private::MTLIOCreateCompressionContext( path, type, chunkSize );
    }
    return nullptr;
}

_NS_EXPORT void MTL::IOCompressionContextAppendData(void* context, const void* data, size_t size)
{
    if ( MTL::Private::MTLIOCompressionContextAppendData )
    {
        MTL::Private::MTLIOCompressionContextAppendData( context, data, size );
    }
}

_NS_EXPORT MTL::IOCompressionStatus MTL::IOFlushAndDestroyCompressionContext(void* context)
{
    if ( MTL::Private::MTLIOFlushAndDestroyCompressionContext )
    {
        return MTL::Private::MTLIOFlushAndDestroyCompressionContext( context );
    }
    return MTL::IOCompressionStatusError;
}

#endif

#pragma once

namespace MTL
{

class LinkedFunctions : public NS::Copying<LinkedFunctions>
{
public:
    static LinkedFunctions* alloc();

    NS::Array*              binaryFunctions() const;
    NS::Array*              functions() const;

    NS::Dictionary*         groups() const;

    LinkedFunctions*        init();

    static LinkedFunctions* linkedFunctions();

    NS::Array*              privateFunctions() const;

    void                    setBinaryFunctions(const NS::Array* binaryFunctions);

    void                    setFunctions(const NS::Array* functions);

    void                    setGroups(const NS::Dictionary* groups);

    void                    setPrivateFunctions(const NS::Array* privateFunctions);
};

}
_MTL_INLINE MTL::LinkedFunctions* MTL::LinkedFunctions::alloc()
{
    return NS::Object::alloc<MTL::LinkedFunctions>(_MTL_PRIVATE_CLS(MTLLinkedFunctions));
}

_MTL_INLINE NS::Array* MTL::LinkedFunctions::binaryFunctions() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(binaryFunctions));
}

_MTL_INLINE NS::Array* MTL::LinkedFunctions::functions() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(functions));
}

_MTL_INLINE NS::Dictionary* MTL::LinkedFunctions::groups() const
{
    return Object::sendMessage<NS::Dictionary*>(this, _MTL_PRIVATE_SEL(groups));
}

_MTL_INLINE MTL::LinkedFunctions* MTL::LinkedFunctions::init()
{
    return NS::Object::init<MTL::LinkedFunctions>();
}

_MTL_INLINE MTL::LinkedFunctions* MTL::LinkedFunctions::linkedFunctions()
{
    return Object::sendMessage<MTL::LinkedFunctions*>(_MTL_PRIVATE_CLS(MTLLinkedFunctions), _MTL_PRIVATE_SEL(linkedFunctions));
}

_MTL_INLINE NS::Array* MTL::LinkedFunctions::privateFunctions() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(privateFunctions));
}

_MTL_INLINE void MTL::LinkedFunctions::setBinaryFunctions(const NS::Array* binaryFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBinaryFunctions_), binaryFunctions);
}

_MTL_INLINE void MTL::LinkedFunctions::setFunctions(const NS::Array* functions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFunctions_), functions);
}

_MTL_INLINE void MTL::LinkedFunctions::setGroups(const NS::Dictionary* groups)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setGroups_), groups);
}

_MTL_INLINE void MTL::LinkedFunctions::setPrivateFunctions(const NS::Array* privateFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPrivateFunctions_), privateFunctions);
}

#pragma once

namespace MTL
{
class LogStateDescriptor;
_MTL_ENUM(NS::Integer, LogLevel) {
    LogLevelUndefined = 0,
    LogLevelDebug = 1,
    LogLevelInfo = 2,
    LogLevelNotice = 3,
    LogLevelError = 4,
    LogLevelFault = 5,
};

_MTL_ENUM(NS::UInteger, LogStateError) {
    LogStateErrorInvalidSize = 1,
    LogStateErrorInvalid = 2,
};

using LogHandlerFunction = std::function<void(NS::String* subsystem, NS::String* category, MTL::LogLevel logLevel, NS::String* message)>;

_MTL_CONST(NS::ErrorDomain, LogStateErrorDomain);
class LogState : public NS::Referencing<LogState>
{
public:
    void addLogHandler(void (^block)(NS::String*, NS::String*, MTL::LogLevel, NS::String*));
    void addLogHandler(const MTL::LogHandlerFunction& handler);
};
class LogStateDescriptor : public NS::Copying<LogStateDescriptor>
{
public:
    static LogStateDescriptor* alloc();

    NS::Integer                bufferSize() const;

    LogStateDescriptor*        init();

    LogLevel                   level() const;

    void                       setBufferSize(NS::Integer bufferSize);

    void                       setLevel(MTL::LogLevel level);
};

}
_MTL_PRIVATE_DEF_CONST(NS::ErrorDomain, LogStateErrorDomain);
_MTL_INLINE void MTL::LogState::addLogHandler(void (^block)(NS::String*, NS::String*, MTL::LogLevel, NS::String*))
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(addLogHandler_), block);
}

_MTL_INLINE void MTL::LogState::addLogHandler(const MTL::LogHandlerFunction& handler)
{
    __block LogHandlerFunction function = handler;
    addLogHandler(^void(NS::String* subsystem, NS::String* category, MTL::LogLevel logLevel, NS::String* message) { function(subsystem, category, logLevel, message); });
}

_MTL_INLINE MTL::LogStateDescriptor* MTL::LogStateDescriptor::alloc()
{
    return NS::Object::alloc<MTL::LogStateDescriptor>(_MTL_PRIVATE_CLS(MTLLogStateDescriptor));
}

_MTL_INLINE NS::Integer MTL::LogStateDescriptor::bufferSize() const
{
    return Object::sendMessage<NS::Integer>(this, _MTL_PRIVATE_SEL(bufferSize));
}

_MTL_INLINE MTL::LogStateDescriptor* MTL::LogStateDescriptor::init()
{
    return NS::Object::init<MTL::LogStateDescriptor>();
}

_MTL_INLINE MTL::LogLevel MTL::LogStateDescriptor::level() const
{
    return Object::sendMessage<MTL::LogLevel>(this, _MTL_PRIVATE_SEL(level));
}

_MTL_INLINE void MTL::LogStateDescriptor::setBufferSize(NS::Integer bufferSize)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBufferSize_), bufferSize);
}

_MTL_INLINE void MTL::LogStateDescriptor::setLevel(MTL::LogLevel level)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLevel_), level);
}

#pragma once

namespace MTL
{
class RenderCommandEncoder;

class ParallelRenderCommandEncoder : public NS::Referencing<ParallelRenderCommandEncoder, CommandEncoder>
{
public:
    RenderCommandEncoder* renderCommandEncoder();

    void                  setColorStoreAction(MTL::StoreAction storeAction, NS::UInteger colorAttachmentIndex);
    void                  setColorStoreActionOptions(MTL::StoreActionOptions storeActionOptions, NS::UInteger colorAttachmentIndex);

    void                  setDepthStoreAction(MTL::StoreAction storeAction);
    void                  setDepthStoreActionOptions(MTL::StoreActionOptions storeActionOptions);

    void                  setStencilStoreAction(MTL::StoreAction storeAction);
    void                  setStencilStoreActionOptions(MTL::StoreActionOptions storeActionOptions);
};

}
_MTL_INLINE MTL::RenderCommandEncoder* MTL::ParallelRenderCommandEncoder::renderCommandEncoder()
{
    return Object::sendMessage<MTL::RenderCommandEncoder*>(this, _MTL_PRIVATE_SEL(renderCommandEncoder));
}

_MTL_INLINE void MTL::ParallelRenderCommandEncoder::setColorStoreAction(MTL::StoreAction storeAction, NS::UInteger colorAttachmentIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setColorStoreAction_atIndex_), storeAction, colorAttachmentIndex);
}

_MTL_INLINE void MTL::ParallelRenderCommandEncoder::setColorStoreActionOptions(MTL::StoreActionOptions storeActionOptions, NS::UInteger colorAttachmentIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setColorStoreActionOptions_atIndex_), storeActionOptions, colorAttachmentIndex);
}

_MTL_INLINE void MTL::ParallelRenderCommandEncoder::setDepthStoreAction(MTL::StoreAction storeAction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthStoreAction_), storeAction);
}

_MTL_INLINE void MTL::ParallelRenderCommandEncoder::setDepthStoreActionOptions(MTL::StoreActionOptions storeActionOptions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthStoreActionOptions_), storeActionOptions);
}

_MTL_INLINE void MTL::ParallelRenderCommandEncoder::setStencilStoreAction(MTL::StoreAction storeAction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStencilStoreAction_), storeAction);
}

_MTL_INLINE void MTL::ParallelRenderCommandEncoder::setStencilStoreActionOptions(MTL::StoreActionOptions storeActionOptions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStencilStoreActionOptions_), storeActionOptions);
}

#pragma once

namespace MTL
{
class Buffer;
class Device;
class RasterizationRateLayerArray;
class RasterizationRateLayerDescriptor;
class RasterizationRateMapDescriptor;
class RasterizationRateSampleArray;

class RasterizationRateSampleArray : public NS::Referencing<RasterizationRateSampleArray>
{
public:
    static RasterizationRateSampleArray* alloc();

    RasterizationRateSampleArray*        init();

    NS::Number*                          object(NS::UInteger index);
    void                                 setObject(const NS::Number* value, NS::UInteger index);
};
class RasterizationRateLayerDescriptor : public NS::Copying<RasterizationRateLayerDescriptor>
{
public:
    static RasterizationRateLayerDescriptor* alloc();

    RasterizationRateSampleArray*            horizontal() const;
    float*                                   horizontalSampleStorage() const;

    RasterizationRateLayerDescriptor*        init();
    RasterizationRateLayerDescriptor*        init(MTL::Size sampleCount);
    RasterizationRateLayerDescriptor*        init(MTL::Size sampleCount, const float* horizontal, const float* vertical);

    Size                                     maxSampleCount() const;
    Size                                     sampleCount() const;
    void                                     setSampleCount(MTL::Size sampleCount);

    RasterizationRateSampleArray*            vertical() const;
    float*                                   verticalSampleStorage() const;
};
class RasterizationRateLayerArray : public NS::Referencing<RasterizationRateLayerArray>
{
public:
    static RasterizationRateLayerArray* alloc();

    RasterizationRateLayerArray*        init();

    RasterizationRateLayerDescriptor*   object(NS::UInteger layerIndex);
    void                                setObject(const MTL::RasterizationRateLayerDescriptor* layer, NS::UInteger layerIndex);
};
class RasterizationRateMapDescriptor : public NS::Copying<RasterizationRateMapDescriptor>
{
public:
    static RasterizationRateMapDescriptor* alloc();

    RasterizationRateMapDescriptor*        init();

    NS::String*                            label() const;

    RasterizationRateLayerDescriptor*      layer(NS::UInteger layerIndex);
    NS::UInteger                           layerCount() const;

    RasterizationRateLayerArray*           layers() const;

    static RasterizationRateMapDescriptor* rasterizationRateMapDescriptor(MTL::Size screenSize);
    static RasterizationRateMapDescriptor* rasterizationRateMapDescriptor(MTL::Size screenSize, const MTL::RasterizationRateLayerDescriptor* layer);
    static RasterizationRateMapDescriptor* rasterizationRateMapDescriptor(MTL::Size screenSize, NS::UInteger layerCount, const MTL::RasterizationRateLayerDescriptor* const* layers);

    Size                                   screenSize() const;

    void                                   setLabel(const NS::String* label);

    void                                   setLayer(const MTL::RasterizationRateLayerDescriptor* layer, NS::UInteger layerIndex);

    void                                   setScreenSize(MTL::Size screenSize);
};
class RasterizationRateMap : public NS::Referencing<RasterizationRateMap>
{
public:
    void         copyParameterDataToBuffer(const MTL::Buffer* buffer, NS::UInteger offset);

    Device*      device() const;

    NS::String*  label() const;

    NS::UInteger layerCount() const;

    Coordinate2D mapPhysicalToScreenCoordinates(MTL::Coordinate2D physicalCoordinates, NS::UInteger layerIndex);

    Coordinate2D mapScreenToPhysicalCoordinates(MTL::Coordinate2D screenCoordinates, NS::UInteger layerIndex);

    SizeAndAlign parameterBufferSizeAndAlign() const;

    Size         physicalGranularity() const;

    Size         physicalSize(NS::UInteger layerIndex);

    Size         screenSize() const;
};

}
_MTL_INLINE MTL::RasterizationRateSampleArray* MTL::RasterizationRateSampleArray::alloc()
{
    return NS::Object::alloc<MTL::RasterizationRateSampleArray>(_MTL_PRIVATE_CLS(MTLRasterizationRateSampleArray));
}

_MTL_INLINE MTL::RasterizationRateSampleArray* MTL::RasterizationRateSampleArray::init()
{
    return NS::Object::init<MTL::RasterizationRateSampleArray>();
}

_MTL_INLINE NS::Number* MTL::RasterizationRateSampleArray::object(NS::UInteger index)
{
    return Object::sendMessage<NS::Number*>(this, _MTL_PRIVATE_SEL(objectAtIndexedSubscript_), index);
}

_MTL_INLINE void MTL::RasterizationRateSampleArray::setObject(const NS::Number* value, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObject_atIndexedSubscript_), value, index);
}

_MTL_INLINE MTL::RasterizationRateLayerDescriptor* MTL::RasterizationRateLayerDescriptor::alloc()
{
    return NS::Object::alloc<MTL::RasterizationRateLayerDescriptor>(_MTL_PRIVATE_CLS(MTLRasterizationRateLayerDescriptor));
}

_MTL_INLINE MTL::RasterizationRateSampleArray* MTL::RasterizationRateLayerDescriptor::horizontal() const
{
    return Object::sendMessage<MTL::RasterizationRateSampleArray*>(this, _MTL_PRIVATE_SEL(horizontal));
}

_MTL_INLINE float* MTL::RasterizationRateLayerDescriptor::horizontalSampleStorage() const
{
    return Object::sendMessage<float*>(this, _MTL_PRIVATE_SEL(horizontalSampleStorage));
}

_MTL_INLINE MTL::RasterizationRateLayerDescriptor* MTL::RasterizationRateLayerDescriptor::init()
{
    return NS::Object::init<MTL::RasterizationRateLayerDescriptor>();
}

_MTL_INLINE MTL::RasterizationRateLayerDescriptor* MTL::RasterizationRateLayerDescriptor::init(MTL::Size sampleCount)
{
    return Object::sendMessage<MTL::RasterizationRateLayerDescriptor*>(this, _MTL_PRIVATE_SEL(initWithSampleCount_), sampleCount);
}

_MTL_INLINE MTL::RasterizationRateLayerDescriptor* MTL::RasterizationRateLayerDescriptor::init(MTL::Size sampleCount, const float* horizontal, const float* vertical)
{
    return Object::sendMessage<MTL::RasterizationRateLayerDescriptor*>(this, _MTL_PRIVATE_SEL(initWithSampleCount_horizontal_vertical_), sampleCount, horizontal, vertical);
}

_MTL_INLINE MTL::Size MTL::RasterizationRateLayerDescriptor::maxSampleCount() const
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(maxSampleCount));
}

_MTL_INLINE MTL::Size MTL::RasterizationRateLayerDescriptor::sampleCount() const
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(sampleCount));
}

_MTL_INLINE void MTL::RasterizationRateLayerDescriptor::setSampleCount(MTL::Size sampleCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSampleCount_), sampleCount);
}

_MTL_INLINE MTL::RasterizationRateSampleArray* MTL::RasterizationRateLayerDescriptor::vertical() const
{
    return Object::sendMessage<MTL::RasterizationRateSampleArray*>(this, _MTL_PRIVATE_SEL(vertical));
}

_MTL_INLINE float* MTL::RasterizationRateLayerDescriptor::verticalSampleStorage() const
{
    return Object::sendMessage<float*>(this, _MTL_PRIVATE_SEL(verticalSampleStorage));
}

_MTL_INLINE MTL::RasterizationRateLayerArray* MTL::RasterizationRateLayerArray::alloc()
{
    return NS::Object::alloc<MTL::RasterizationRateLayerArray>(_MTL_PRIVATE_CLS(MTLRasterizationRateLayerArray));
}

_MTL_INLINE MTL::RasterizationRateLayerArray* MTL::RasterizationRateLayerArray::init()
{
    return NS::Object::init<MTL::RasterizationRateLayerArray>();
}

_MTL_INLINE MTL::RasterizationRateLayerDescriptor* MTL::RasterizationRateLayerArray::object(NS::UInteger layerIndex)
{
    return Object::sendMessage<MTL::RasterizationRateLayerDescriptor*>(this, _MTL_PRIVATE_SEL(objectAtIndexedSubscript_), layerIndex);
}

_MTL_INLINE void MTL::RasterizationRateLayerArray::setObject(const MTL::RasterizationRateLayerDescriptor* layer, NS::UInteger layerIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObject_atIndexedSubscript_), layer, layerIndex);
}

_MTL_INLINE MTL::RasterizationRateMapDescriptor* MTL::RasterizationRateMapDescriptor::alloc()
{
    return NS::Object::alloc<MTL::RasterizationRateMapDescriptor>(_MTL_PRIVATE_CLS(MTLRasterizationRateMapDescriptor));
}

_MTL_INLINE MTL::RasterizationRateMapDescriptor* MTL::RasterizationRateMapDescriptor::init()
{
    return NS::Object::init<MTL::RasterizationRateMapDescriptor>();
}

_MTL_INLINE NS::String* MTL::RasterizationRateMapDescriptor::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE MTL::RasterizationRateLayerDescriptor* MTL::RasterizationRateMapDescriptor::layer(NS::UInteger layerIndex)
{
    return Object::sendMessage<MTL::RasterizationRateLayerDescriptor*>(this, _MTL_PRIVATE_SEL(layerAtIndex_), layerIndex);
}

_MTL_INLINE NS::UInteger MTL::RasterizationRateMapDescriptor::layerCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(layerCount));
}

_MTL_INLINE MTL::RasterizationRateLayerArray* MTL::RasterizationRateMapDescriptor::layers() const
{
    return Object::sendMessage<MTL::RasterizationRateLayerArray*>(this, _MTL_PRIVATE_SEL(layers));
}

_MTL_INLINE MTL::RasterizationRateMapDescriptor* MTL::RasterizationRateMapDescriptor::rasterizationRateMapDescriptor(MTL::Size screenSize)
{
    return Object::sendMessage<MTL::RasterizationRateMapDescriptor*>(_MTL_PRIVATE_CLS(MTLRasterizationRateMapDescriptor), _MTL_PRIVATE_SEL(rasterizationRateMapDescriptorWithScreenSize_), screenSize);
}

_MTL_INLINE MTL::RasterizationRateMapDescriptor* MTL::RasterizationRateMapDescriptor::rasterizationRateMapDescriptor(MTL::Size screenSize, const MTL::RasterizationRateLayerDescriptor* layer)
{
    return Object::sendMessage<MTL::RasterizationRateMapDescriptor*>(_MTL_PRIVATE_CLS(MTLRasterizationRateMapDescriptor), _MTL_PRIVATE_SEL(rasterizationRateMapDescriptorWithScreenSize_layer_), screenSize, layer);
}

_MTL_INLINE MTL::RasterizationRateMapDescriptor* MTL::RasterizationRateMapDescriptor::rasterizationRateMapDescriptor(MTL::Size screenSize, NS::UInteger layerCount, const MTL::RasterizationRateLayerDescriptor* const* layers)
{
    return Object::sendMessage<MTL::RasterizationRateMapDescriptor*>(_MTL_PRIVATE_CLS(MTLRasterizationRateMapDescriptor), _MTL_PRIVATE_SEL(rasterizationRateMapDescriptorWithScreenSize_layerCount_layers_), screenSize, layerCount, layers);
}

_MTL_INLINE MTL::Size MTL::RasterizationRateMapDescriptor::screenSize() const
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(screenSize));
}

_MTL_INLINE void MTL::RasterizationRateMapDescriptor::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE void MTL::RasterizationRateMapDescriptor::setLayer(const MTL::RasterizationRateLayerDescriptor* layer, NS::UInteger layerIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLayer_atIndex_), layer, layerIndex);
}

_MTL_INLINE void MTL::RasterizationRateMapDescriptor::setScreenSize(MTL::Size screenSize)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setScreenSize_), screenSize);
}

_MTL_INLINE void MTL::RasterizationRateMap::copyParameterDataToBuffer(const MTL::Buffer* buffer, NS::UInteger offset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyParameterDataToBuffer_offset_), buffer, offset);
}

_MTL_INLINE MTL::Device* MTL::RasterizationRateMap::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE NS::String* MTL::RasterizationRateMap::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE NS::UInteger MTL::RasterizationRateMap::layerCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(layerCount));
}

_MTL_INLINE MTL::Coordinate2D MTL::RasterizationRateMap::mapPhysicalToScreenCoordinates(MTL::Coordinate2D physicalCoordinates, NS::UInteger layerIndex)
{
    return Object::sendMessage<MTL::Coordinate2D>(this, _MTL_PRIVATE_SEL(mapPhysicalToScreenCoordinates_forLayer_), physicalCoordinates, layerIndex);
}

_MTL_INLINE MTL::Coordinate2D MTL::RasterizationRateMap::mapScreenToPhysicalCoordinates(MTL::Coordinate2D screenCoordinates, NS::UInteger layerIndex)
{
    return Object::sendMessage<MTL::Coordinate2D>(this, _MTL_PRIVATE_SEL(mapScreenToPhysicalCoordinates_forLayer_), screenCoordinates, layerIndex);
}

_MTL_INLINE MTL::SizeAndAlign MTL::RasterizationRateMap::parameterBufferSizeAndAlign() const
{
    return Object::sendMessage<MTL::SizeAndAlign>(this, _MTL_PRIVATE_SEL(parameterBufferSizeAndAlign));
}

_MTL_INLINE MTL::Size MTL::RasterizationRateMap::physicalGranularity() const
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(physicalGranularity));
}

_MTL_INLINE MTL::Size MTL::RasterizationRateMap::physicalSize(NS::UInteger layerIndex)
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(physicalSizeForLayer_), layerIndex);
}

_MTL_INLINE MTL::Size MTL::RasterizationRateMap::screenSize() const
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(screenSize));
}

#pragma once

namespace MTL
{
class Device;
class Function;
class FunctionHandle;
class IntersectionFunctionTable;
class IntersectionFunctionTableDescriptor;
class LinkedFunctions;
class LogicalToPhysicalColorAttachmentMap;
class MeshRenderPipelineDescriptor;
class PipelineBufferDescriptorArray;
class RenderPipelineColorAttachmentDescriptor;
class RenderPipelineColorAttachmentDescriptorArray;
class RenderPipelineDescriptor;
class RenderPipelineFunctionsDescriptor;
class RenderPipelineReflection;
class RenderPipelineState;
class TileRenderPipelineColorAttachmentDescriptor;
class TileRenderPipelineColorAttachmentDescriptorArray;
class TileRenderPipelineDescriptor;
class VertexDescriptor;
class VisibleFunctionTable;
class VisibleFunctionTableDescriptor;

}
namespace MTL4
{
class BinaryFunction;
class PipelineDescriptor;
class RenderPipelineBinaryFunctionsDescriptor;

}
namespace MTL
{
_MTL_ENUM(NS::UInteger, BlendFactor) {
    BlendFactorZero = 0,
    BlendFactorOne = 1,
    BlendFactorSourceColor = 2,
    BlendFactorOneMinusSourceColor = 3,
    BlendFactorSourceAlpha = 4,
    BlendFactorOneMinusSourceAlpha = 5,
    BlendFactorDestinationColor = 6,
    BlendFactorOneMinusDestinationColor = 7,
    BlendFactorDestinationAlpha = 8,
    BlendFactorOneMinusDestinationAlpha = 9,
    BlendFactorSourceAlphaSaturated = 10,
    BlendFactorBlendColor = 11,
    BlendFactorOneMinusBlendColor = 12,
    BlendFactorBlendAlpha = 13,
    BlendFactorOneMinusBlendAlpha = 14,
    BlendFactorSource1Color = 15,
    BlendFactorOneMinusSource1Color = 16,
    BlendFactorSource1Alpha = 17,
    BlendFactorOneMinusSource1Alpha = 18,
    BlendFactorUnspecialized = 19,
};

_MTL_ENUM(NS::UInteger, BlendOperation) {
    BlendOperationAdd = 0,
    BlendOperationSubtract = 1,
    BlendOperationReverseSubtract = 2,
    BlendOperationMin = 3,
    BlendOperationMax = 4,
    BlendOperationUnspecialized = 5,
};

_MTL_ENUM(NS::UInteger, PrimitiveTopologyClass) {
    PrimitiveTopologyClassUnspecified = 0,
    PrimitiveTopologyClassPoint = 1,
    PrimitiveTopologyClassLine = 2,
    PrimitiveTopologyClassTriangle = 3,
};

_MTL_ENUM(NS::UInteger, TessellationPartitionMode) {
    TessellationPartitionModePow2 = 0,
    TessellationPartitionModeInteger = 1,
    TessellationPartitionModeFractionalOdd = 2,
    TessellationPartitionModeFractionalEven = 3,
};

_MTL_ENUM(NS::UInteger, TessellationFactorStepFunction) {
    TessellationFactorStepFunctionConstant = 0,
    TessellationFactorStepFunctionPerPatch = 1,
    TessellationFactorStepFunctionPerInstance = 2,
    TessellationFactorStepFunctionPerPatchAndPerInstance = 3,
};

_MTL_ENUM(NS::UInteger, TessellationFactorFormat) {
    TessellationFactorFormatHalf = 0,
};

_MTL_ENUM(NS::UInteger, TessellationControlPointIndexType) {
    TessellationControlPointIndexTypeNone = 0,
    TessellationControlPointIndexTypeUInt16 = 1,
    TessellationControlPointIndexTypeUInt32 = 2,
};

_MTL_OPTIONS(NS::UInteger, ColorWriteMask) {
    ColorWriteMaskNone = 0,
    ColorWriteMaskRed = 1 << 3,
    ColorWriteMaskGreen = 1 << 2,
    ColorWriteMaskBlue = 1 << 1,
    ColorWriteMaskAlpha = 1,
    ColorWriteMaskAll = 15,
    ColorWriteMaskUnspecialized = 1 << 4,
};

class RenderPipelineColorAttachmentDescriptor : public NS::Copying<RenderPipelineColorAttachmentDescriptor>
{
public:
    static RenderPipelineColorAttachmentDescriptor* alloc();

    BlendOperation                                  alphaBlendOperation() const;

    [[deprecated("please use isBlendingEnabled instead")]]
    bool                                     blendingEnabled() const;

    BlendFactor                              destinationAlphaBlendFactor() const;

    BlendFactor                              destinationRGBBlendFactor() const;

    RenderPipelineColorAttachmentDescriptor* init();

    bool                                     isBlendingEnabled() const;

    PixelFormat                              pixelFormat() const;

    BlendOperation                           rgbBlendOperation() const;

    void                                     setAlphaBlendOperation(MTL::BlendOperation alphaBlendOperation);

    void                                     setBlendingEnabled(bool blendingEnabled);

    void                                     setDestinationAlphaBlendFactor(MTL::BlendFactor destinationAlphaBlendFactor);

    void                                     setDestinationRGBBlendFactor(MTL::BlendFactor destinationRGBBlendFactor);

    void                                     setPixelFormat(MTL::PixelFormat pixelFormat);

    void                                     setRgbBlendOperation(MTL::BlendOperation rgbBlendOperation);

    void                                     setSourceAlphaBlendFactor(MTL::BlendFactor sourceAlphaBlendFactor);

    void                                     setSourceRGBBlendFactor(MTL::BlendFactor sourceRGBBlendFactor);

    void                                     setWriteMask(MTL::ColorWriteMask writeMask);

    BlendFactor                              sourceAlphaBlendFactor() const;

    BlendFactor                              sourceRGBBlendFactor() const;

    ColorWriteMask                           writeMask() const;
};
class LogicalToPhysicalColorAttachmentMap : public NS::Copying<LogicalToPhysicalColorAttachmentMap>
{
public:
    static LogicalToPhysicalColorAttachmentMap* alloc();

    NS::UInteger                                getPhysicalIndex(NS::UInteger logicalIndex);

    LogicalToPhysicalColorAttachmentMap*        init();

    void                                        reset();

    void                                        setPhysicalIndex(NS::UInteger physicalIndex, NS::UInteger logicalIndex);
};
class RenderPipelineReflection : public NS::Referencing<RenderPipelineReflection>
{
public:
    static RenderPipelineReflection* alloc();

    NS::Array*                       fragmentArguments() const;

    NS::Array*                       fragmentBindings() const;

    RenderPipelineReflection*        init();

    NS::Array*                       meshBindings() const;

    NS::Array*                       objectBindings() const;

    NS::Array*                       tileArguments() const;

    NS::Array*                       tileBindings() const;

    NS::Array*                       vertexArguments() const;

    NS::Array*                       vertexBindings() const;
};
class RenderPipelineDescriptor : public NS::Copying<RenderPipelineDescriptor>
{
public:
    static RenderPipelineDescriptor* alloc();

    [[deprecated("please use isAlphaToCoverageEnabled instead")]]
    bool alphaToCoverageEnabled() const;

    [[deprecated("please use isAlphaToOneEnabled instead")]]
    bool                                          alphaToOneEnabled() const;

    NS::Array*                                    binaryArchives() const;

    RenderPipelineColorAttachmentDescriptorArray* colorAttachments() const;

    PixelFormat                                   depthAttachmentPixelFormat() const;

    PipelineBufferDescriptorArray*                fragmentBuffers() const;

    Function*                                     fragmentFunction() const;

    LinkedFunctions*                              fragmentLinkedFunctions() const;

    NS::Array*                                    fragmentPreloadedLibraries() const;

    RenderPipelineDescriptor*                     init();

    PrimitiveTopologyClass                        inputPrimitiveTopology() const;

    bool                                          isAlphaToCoverageEnabled() const;

    bool                                          isAlphaToOneEnabled() const;

    bool                                          isRasterizationEnabled() const;

    bool                                          isTessellationFactorScaleEnabled() const;

    NS::String*                                   label() const;

    NS::UInteger                                  maxFragmentCallStackDepth() const;

    NS::UInteger                                  maxTessellationFactor() const;

    NS::UInteger                                  maxVertexAmplificationCount() const;

    NS::UInteger                                  maxVertexCallStackDepth() const;

    NS::UInteger                                  rasterSampleCount() const;

    [[deprecated("please use isRasterizationEnabled instead")]]
    bool                              rasterizationEnabled() const;

    void                              reset();

    NS::UInteger                      sampleCount() const;

    void                              setAlphaToCoverageEnabled(bool alphaToCoverageEnabled);

    void                              setAlphaToOneEnabled(bool alphaToOneEnabled);

    void                              setBinaryArchives(const NS::Array* binaryArchives);

    void                              setDepthAttachmentPixelFormat(MTL::PixelFormat depthAttachmentPixelFormat);

    void                              setFragmentFunction(const MTL::Function* fragmentFunction);

    void                              setFragmentLinkedFunctions(const MTL::LinkedFunctions* fragmentLinkedFunctions);

    void                              setFragmentPreloadedLibraries(const NS::Array* fragmentPreloadedLibraries);

    void                              setInputPrimitiveTopology(MTL::PrimitiveTopologyClass inputPrimitiveTopology);

    void                              setLabel(const NS::String* label);

    void                              setMaxFragmentCallStackDepth(NS::UInteger maxFragmentCallStackDepth);

    void                              setMaxTessellationFactor(NS::UInteger maxTessellationFactor);

    void                              setMaxVertexAmplificationCount(NS::UInteger maxVertexAmplificationCount);

    void                              setMaxVertexCallStackDepth(NS::UInteger maxVertexCallStackDepth);

    void                              setRasterSampleCount(NS::UInteger rasterSampleCount);

    void                              setRasterizationEnabled(bool rasterizationEnabled);

    void                              setSampleCount(NS::UInteger sampleCount);

    void                              setShaderValidation(MTL::ShaderValidation shaderValidation);

    void                              setStencilAttachmentPixelFormat(MTL::PixelFormat stencilAttachmentPixelFormat);

    void                              setSupportAddingFragmentBinaryFunctions(bool supportAddingFragmentBinaryFunctions);

    void                              setSupportAddingVertexBinaryFunctions(bool supportAddingVertexBinaryFunctions);

    void                              setSupportIndirectCommandBuffers(bool supportIndirectCommandBuffers);

    void                              setTessellationControlPointIndexType(MTL::TessellationControlPointIndexType tessellationControlPointIndexType);

    void                              setTessellationFactorFormat(MTL::TessellationFactorFormat tessellationFactorFormat);

    void                              setTessellationFactorScaleEnabled(bool tessellationFactorScaleEnabled);

    void                              setTessellationFactorStepFunction(MTL::TessellationFactorStepFunction tessellationFactorStepFunction);

    void                              setTessellationOutputWindingOrder(MTL::Winding tessellationOutputWindingOrder);

    void                              setTessellationPartitionMode(MTL::TessellationPartitionMode tessellationPartitionMode);

    void                              setVertexDescriptor(const MTL::VertexDescriptor* vertexDescriptor);

    void                              setVertexFunction(const MTL::Function* vertexFunction);

    void                              setVertexLinkedFunctions(const MTL::LinkedFunctions* vertexLinkedFunctions);

    void                              setVertexPreloadedLibraries(const NS::Array* vertexPreloadedLibraries);

    ShaderValidation                  shaderValidation() const;

    PixelFormat                       stencilAttachmentPixelFormat() const;

    bool                              supportAddingFragmentBinaryFunctions() const;

    bool                              supportAddingVertexBinaryFunctions() const;

    bool                              supportIndirectCommandBuffers() const;

    TessellationControlPointIndexType tessellationControlPointIndexType() const;

    TessellationFactorFormat          tessellationFactorFormat() const;

    [[deprecated("please use isTessellationFactorScaleEnabled instead")]]
    bool                           tessellationFactorScaleEnabled() const;

    TessellationFactorStepFunction tessellationFactorStepFunction() const;

    Winding                        tessellationOutputWindingOrder() const;

    TessellationPartitionMode      tessellationPartitionMode() const;

    PipelineBufferDescriptorArray* vertexBuffers() const;

    VertexDescriptor*              vertexDescriptor() const;

    Function*                      vertexFunction() const;

    LinkedFunctions*               vertexLinkedFunctions() const;

    NS::Array*                     vertexPreloadedLibraries() const;
};
class RenderPipelineFunctionsDescriptor : public NS::Copying<RenderPipelineFunctionsDescriptor>
{
public:
    static RenderPipelineFunctionsDescriptor* alloc();

    NS::Array*                                fragmentAdditionalBinaryFunctions() const;

    RenderPipelineFunctionsDescriptor*        init();

    void                                      setFragmentAdditionalBinaryFunctions(const NS::Array* fragmentAdditionalBinaryFunctions);

    void                                      setTileAdditionalBinaryFunctions(const NS::Array* tileAdditionalBinaryFunctions);

    void                                      setVertexAdditionalBinaryFunctions(const NS::Array* vertexAdditionalBinaryFunctions);

    NS::Array*                                tileAdditionalBinaryFunctions() const;

    NS::Array*                                vertexAdditionalBinaryFunctions() const;
};
class RenderPipelineState : public NS::Referencing<RenderPipelineState, Allocation>
{
public:
    Device*                    device() const;

    FunctionHandle*            functionHandle(const NS::String* name, MTL::RenderStages stage);
    FunctionHandle*            functionHandle(const MTL4::BinaryFunction* function, MTL::RenderStages stage);
    FunctionHandle*            functionHandle(const MTL::Function* function, MTL::RenderStages stage);

    ResourceID                 gpuResourceID() const;

    NS::UInteger               imageblockMemoryLength(MTL::Size imageblockDimensions);

    NS::UInteger               imageblockSampleLength() const;

    NS::String*                label() const;

    NS::UInteger               maxTotalThreadgroupsPerMeshGrid() const;

    NS::UInteger               maxTotalThreadsPerMeshThreadgroup() const;

    NS::UInteger               maxTotalThreadsPerObjectThreadgroup() const;

    NS::UInteger               maxTotalThreadsPerThreadgroup() const;

    NS::UInteger               meshThreadExecutionWidth() const;

    IntersectionFunctionTable* newIntersectionFunctionTable(const MTL::IntersectionFunctionTableDescriptor* descriptor, MTL::RenderStages stage);

    MTL4::PipelineDescriptor*  newRenderPipelineDescriptor();

    RenderPipelineState*       newRenderPipelineState(const MTL4::RenderPipelineBinaryFunctionsDescriptor* binaryFunctionsDescriptor, NS::Error** error);
    RenderPipelineState*       newRenderPipelineState(const MTL::RenderPipelineFunctionsDescriptor* additionalBinaryFunctions, NS::Error** error);

    VisibleFunctionTable*      newVisibleFunctionTable(const MTL::VisibleFunctionTableDescriptor* descriptor, MTL::RenderStages stage);

    NS::UInteger               objectThreadExecutionWidth() const;

    RenderPipelineReflection*  reflection() const;

    Size                       requiredThreadsPerMeshThreadgroup() const;

    Size                       requiredThreadsPerObjectThreadgroup() const;

    Size                       requiredThreadsPerTileThreadgroup() const;

    ShaderValidation           shaderValidation() const;

    bool                       supportIndirectCommandBuffers() const;

    bool                       threadgroupSizeMatchesTileSize() const;
};
class RenderPipelineColorAttachmentDescriptorArray : public NS::Referencing<RenderPipelineColorAttachmentDescriptorArray>
{
public:
    static RenderPipelineColorAttachmentDescriptorArray* alloc();

    RenderPipelineColorAttachmentDescriptorArray*        init();

    RenderPipelineColorAttachmentDescriptor*             object(NS::UInteger attachmentIndex);
    void                                                 setObject(const MTL::RenderPipelineColorAttachmentDescriptor* attachment, NS::UInteger attachmentIndex);
};
class TileRenderPipelineColorAttachmentDescriptor : public NS::Copying<TileRenderPipelineColorAttachmentDescriptor>
{
public:
    static TileRenderPipelineColorAttachmentDescriptor* alloc();

    TileRenderPipelineColorAttachmentDescriptor*        init();

    PixelFormat                                         pixelFormat() const;
    void                                                setPixelFormat(MTL::PixelFormat pixelFormat);
};
class TileRenderPipelineColorAttachmentDescriptorArray : public NS::Referencing<TileRenderPipelineColorAttachmentDescriptorArray>
{
public:
    static TileRenderPipelineColorAttachmentDescriptorArray* alloc();

    TileRenderPipelineColorAttachmentDescriptorArray*        init();

    TileRenderPipelineColorAttachmentDescriptor*             object(NS::UInteger attachmentIndex);
    void                                                     setObject(const MTL::TileRenderPipelineColorAttachmentDescriptor* attachment, NS::UInteger attachmentIndex);
};
class TileRenderPipelineDescriptor : public NS::Copying<TileRenderPipelineDescriptor>
{
public:
    static TileRenderPipelineDescriptor*              alloc();

    NS::Array*                                        binaryArchives() const;

    TileRenderPipelineColorAttachmentDescriptorArray* colorAttachments() const;

    TileRenderPipelineDescriptor*                     init();

    NS::String*                                       label() const;

    LinkedFunctions*                                  linkedFunctions() const;

    NS::UInteger                                      maxCallStackDepth() const;

    NS::UInteger                                      maxTotalThreadsPerThreadgroup() const;

    NS::Array*                                        preloadedLibraries() const;

    NS::UInteger                                      rasterSampleCount() const;

    Size                                              requiredThreadsPerThreadgroup() const;

    void                                              reset();

    void                                              setBinaryArchives(const NS::Array* binaryArchives);

    void                                              setLabel(const NS::String* label);

    void                                              setLinkedFunctions(const MTL::LinkedFunctions* linkedFunctions);

    void                                              setMaxCallStackDepth(NS::UInteger maxCallStackDepth);

    void                                              setMaxTotalThreadsPerThreadgroup(NS::UInteger maxTotalThreadsPerThreadgroup);

    void                                              setPreloadedLibraries(const NS::Array* preloadedLibraries);

    void                                              setRasterSampleCount(NS::UInteger rasterSampleCount);

    void                                              setRequiredThreadsPerThreadgroup(MTL::Size requiredThreadsPerThreadgroup);

    void                                              setShaderValidation(MTL::ShaderValidation shaderValidation);

    void                                              setSupportAddingBinaryFunctions(bool supportAddingBinaryFunctions);

    void                                              setThreadgroupSizeMatchesTileSize(bool threadgroupSizeMatchesTileSize);

    void                                              setTileFunction(const MTL::Function* tileFunction);

    ShaderValidation                                  shaderValidation() const;

    bool                                              supportAddingBinaryFunctions() const;

    bool                                              threadgroupSizeMatchesTileSize() const;

    PipelineBufferDescriptorArray*                    tileBuffers() const;

    Function*                                         tileFunction() const;
};
class MeshRenderPipelineDescriptor : public NS::Copying<MeshRenderPipelineDescriptor>
{
public:
    static MeshRenderPipelineDescriptor* alloc();

    [[deprecated("please use isAlphaToCoverageEnabled instead")]]
    bool alphaToCoverageEnabled() const;

    [[deprecated("please use isAlphaToOneEnabled instead")]]
    bool                                          alphaToOneEnabled() const;

    NS::Array*                                    binaryArchives() const;

    RenderPipelineColorAttachmentDescriptorArray* colorAttachments() const;

    PixelFormat                                   depthAttachmentPixelFormat() const;

    PipelineBufferDescriptorArray*                fragmentBuffers() const;

    Function*                                     fragmentFunction() const;

    LinkedFunctions*                              fragmentLinkedFunctions() const;

    MeshRenderPipelineDescriptor*                 init();

    bool                                          isAlphaToCoverageEnabled() const;

    bool                                          isAlphaToOneEnabled() const;

    bool                                          isRasterizationEnabled() const;

    NS::String*                                   label() const;

    NS::UInteger                                  maxTotalThreadgroupsPerMeshGrid() const;

    NS::UInteger                                  maxTotalThreadsPerMeshThreadgroup() const;

    NS::UInteger                                  maxTotalThreadsPerObjectThreadgroup() const;

    NS::UInteger                                  maxVertexAmplificationCount() const;

    PipelineBufferDescriptorArray*                meshBuffers() const;

    Function*                                     meshFunction() const;

    LinkedFunctions*                              meshLinkedFunctions() const;

    bool                                          meshThreadgroupSizeIsMultipleOfThreadExecutionWidth() const;

    PipelineBufferDescriptorArray*                objectBuffers() const;

    Function*                                     objectFunction() const;

    LinkedFunctions*                              objectLinkedFunctions() const;

    bool                                          objectThreadgroupSizeIsMultipleOfThreadExecutionWidth() const;

    NS::UInteger                                  payloadMemoryLength() const;

    NS::UInteger                                  rasterSampleCount() const;

    [[deprecated("please use isRasterizationEnabled instead")]]
    bool             rasterizationEnabled() const;

    Size             requiredThreadsPerMeshThreadgroup() const;

    Size             requiredThreadsPerObjectThreadgroup() const;

    void             reset();

    void             setAlphaToCoverageEnabled(bool alphaToCoverageEnabled);

    void             setAlphaToOneEnabled(bool alphaToOneEnabled);

    void             setBinaryArchives(const NS::Array* binaryArchives);

    void             setDepthAttachmentPixelFormat(MTL::PixelFormat depthAttachmentPixelFormat);

    void             setFragmentFunction(const MTL::Function* fragmentFunction);

    void             setFragmentLinkedFunctions(const MTL::LinkedFunctions* fragmentLinkedFunctions);

    void             setLabel(const NS::String* label);

    void             setMaxTotalThreadgroupsPerMeshGrid(NS::UInteger maxTotalThreadgroupsPerMeshGrid);

    void             setMaxTotalThreadsPerMeshThreadgroup(NS::UInteger maxTotalThreadsPerMeshThreadgroup);

    void             setMaxTotalThreadsPerObjectThreadgroup(NS::UInteger maxTotalThreadsPerObjectThreadgroup);

    void             setMaxVertexAmplificationCount(NS::UInteger maxVertexAmplificationCount);

    void             setMeshFunction(const MTL::Function* meshFunction);

    void             setMeshLinkedFunctions(const MTL::LinkedFunctions* meshLinkedFunctions);

    void             setMeshThreadgroupSizeIsMultipleOfThreadExecutionWidth(bool meshThreadgroupSizeIsMultipleOfThreadExecutionWidth);

    void             setObjectFunction(const MTL::Function* objectFunction);

    void             setObjectLinkedFunctions(const MTL::LinkedFunctions* objectLinkedFunctions);

    void             setObjectThreadgroupSizeIsMultipleOfThreadExecutionWidth(bool objectThreadgroupSizeIsMultipleOfThreadExecutionWidth);

    void             setPayloadMemoryLength(NS::UInteger payloadMemoryLength);

    void             setRasterSampleCount(NS::UInteger rasterSampleCount);

    void             setRasterizationEnabled(bool rasterizationEnabled);

    void             setRequiredThreadsPerMeshThreadgroup(MTL::Size requiredThreadsPerMeshThreadgroup);

    void             setRequiredThreadsPerObjectThreadgroup(MTL::Size requiredThreadsPerObjectThreadgroup);

    void             setShaderValidation(MTL::ShaderValidation shaderValidation);

    void             setStencilAttachmentPixelFormat(MTL::PixelFormat stencilAttachmentPixelFormat);

    void             setSupportIndirectCommandBuffers(bool supportIndirectCommandBuffers);

    ShaderValidation shaderValidation() const;

    PixelFormat      stencilAttachmentPixelFormat() const;

    bool             supportIndirectCommandBuffers() const;
};

}
_MTL_INLINE MTL::RenderPipelineColorAttachmentDescriptor* MTL::RenderPipelineColorAttachmentDescriptor::alloc()
{
    return NS::Object::alloc<MTL::RenderPipelineColorAttachmentDescriptor>(_MTL_PRIVATE_CLS(MTLRenderPipelineColorAttachmentDescriptor));
}

_MTL_INLINE MTL::BlendOperation MTL::RenderPipelineColorAttachmentDescriptor::alphaBlendOperation() const
{
    return Object::sendMessage<MTL::BlendOperation>(this, _MTL_PRIVATE_SEL(alphaBlendOperation));
}

_MTL_INLINE bool MTL::RenderPipelineColorAttachmentDescriptor::blendingEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isBlendingEnabled));
}

_MTL_INLINE MTL::BlendFactor MTL::RenderPipelineColorAttachmentDescriptor::destinationAlphaBlendFactor() const
{
    return Object::sendMessage<MTL::BlendFactor>(this, _MTL_PRIVATE_SEL(destinationAlphaBlendFactor));
}

_MTL_INLINE MTL::BlendFactor MTL::RenderPipelineColorAttachmentDescriptor::destinationRGBBlendFactor() const
{
    return Object::sendMessage<MTL::BlendFactor>(this, _MTL_PRIVATE_SEL(destinationRGBBlendFactor));
}

_MTL_INLINE MTL::RenderPipelineColorAttachmentDescriptor* MTL::RenderPipelineColorAttachmentDescriptor::init()
{
    return NS::Object::init<MTL::RenderPipelineColorAttachmentDescriptor>();
}

_MTL_INLINE bool MTL::RenderPipelineColorAttachmentDescriptor::isBlendingEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isBlendingEnabled));
}

_MTL_INLINE MTL::PixelFormat MTL::RenderPipelineColorAttachmentDescriptor::pixelFormat() const
{
    return Object::sendMessage<MTL::PixelFormat>(this, _MTL_PRIVATE_SEL(pixelFormat));
}

_MTL_INLINE MTL::BlendOperation MTL::RenderPipelineColorAttachmentDescriptor::rgbBlendOperation() const
{
    return Object::sendMessage<MTL::BlendOperation>(this, _MTL_PRIVATE_SEL(rgbBlendOperation));
}

_MTL_INLINE void MTL::RenderPipelineColorAttachmentDescriptor::setAlphaBlendOperation(MTL::BlendOperation alphaBlendOperation)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setAlphaBlendOperation_), alphaBlendOperation);
}

_MTL_INLINE void MTL::RenderPipelineColorAttachmentDescriptor::setBlendingEnabled(bool blendingEnabled)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBlendingEnabled_), blendingEnabled);
}

_MTL_INLINE void MTL::RenderPipelineColorAttachmentDescriptor::setDestinationAlphaBlendFactor(MTL::BlendFactor destinationAlphaBlendFactor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDestinationAlphaBlendFactor_), destinationAlphaBlendFactor);
}

_MTL_INLINE void MTL::RenderPipelineColorAttachmentDescriptor::setDestinationRGBBlendFactor(MTL::BlendFactor destinationRGBBlendFactor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDestinationRGBBlendFactor_), destinationRGBBlendFactor);
}

_MTL_INLINE void MTL::RenderPipelineColorAttachmentDescriptor::setPixelFormat(MTL::PixelFormat pixelFormat)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPixelFormat_), pixelFormat);
}

_MTL_INLINE void MTL::RenderPipelineColorAttachmentDescriptor::setRgbBlendOperation(MTL::BlendOperation rgbBlendOperation)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRgbBlendOperation_), rgbBlendOperation);
}

_MTL_INLINE void MTL::RenderPipelineColorAttachmentDescriptor::setSourceAlphaBlendFactor(MTL::BlendFactor sourceAlphaBlendFactor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSourceAlphaBlendFactor_), sourceAlphaBlendFactor);
}

_MTL_INLINE void MTL::RenderPipelineColorAttachmentDescriptor::setSourceRGBBlendFactor(MTL::BlendFactor sourceRGBBlendFactor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSourceRGBBlendFactor_), sourceRGBBlendFactor);
}

_MTL_INLINE void MTL::RenderPipelineColorAttachmentDescriptor::setWriteMask(MTL::ColorWriteMask writeMask)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setWriteMask_), writeMask);
}

_MTL_INLINE MTL::BlendFactor MTL::RenderPipelineColorAttachmentDescriptor::sourceAlphaBlendFactor() const
{
    return Object::sendMessage<MTL::BlendFactor>(this, _MTL_PRIVATE_SEL(sourceAlphaBlendFactor));
}

_MTL_INLINE MTL::BlendFactor MTL::RenderPipelineColorAttachmentDescriptor::sourceRGBBlendFactor() const
{
    return Object::sendMessage<MTL::BlendFactor>(this, _MTL_PRIVATE_SEL(sourceRGBBlendFactor));
}

_MTL_INLINE MTL::ColorWriteMask MTL::RenderPipelineColorAttachmentDescriptor::writeMask() const
{
    return Object::sendMessage<MTL::ColorWriteMask>(this, _MTL_PRIVATE_SEL(writeMask));
}

_MTL_INLINE MTL::LogicalToPhysicalColorAttachmentMap* MTL::LogicalToPhysicalColorAttachmentMap::alloc()
{
    return NS::Object::alloc<MTL::LogicalToPhysicalColorAttachmentMap>(_MTL_PRIVATE_CLS(MTLLogicalToPhysicalColorAttachmentMap));
}

_MTL_INLINE NS::UInteger MTL::LogicalToPhysicalColorAttachmentMap::getPhysicalIndex(NS::UInteger logicalIndex)
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(getPhysicalIndexForLogicalIndex_), logicalIndex);
}

_MTL_INLINE MTL::LogicalToPhysicalColorAttachmentMap* MTL::LogicalToPhysicalColorAttachmentMap::init()
{
    return NS::Object::init<MTL::LogicalToPhysicalColorAttachmentMap>();
}

_MTL_INLINE void MTL::LogicalToPhysicalColorAttachmentMap::reset()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(reset));
}

_MTL_INLINE void MTL::LogicalToPhysicalColorAttachmentMap::setPhysicalIndex(NS::UInteger physicalIndex, NS::UInteger logicalIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPhysicalIndex_forLogicalIndex_), physicalIndex, logicalIndex);
}

_MTL_INLINE MTL::RenderPipelineReflection* MTL::RenderPipelineReflection::alloc()
{
    return NS::Object::alloc<MTL::RenderPipelineReflection>(_MTL_PRIVATE_CLS(MTLRenderPipelineReflection));
}

_MTL_INLINE NS::Array* MTL::RenderPipelineReflection::fragmentArguments() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(fragmentArguments));
}

_MTL_INLINE NS::Array* MTL::RenderPipelineReflection::fragmentBindings() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(fragmentBindings));
}

_MTL_INLINE MTL::RenderPipelineReflection* MTL::RenderPipelineReflection::init()
{
    return NS::Object::init<MTL::RenderPipelineReflection>();
}

_MTL_INLINE NS::Array* MTL::RenderPipelineReflection::meshBindings() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(meshBindings));
}

_MTL_INLINE NS::Array* MTL::RenderPipelineReflection::objectBindings() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(objectBindings));
}

_MTL_INLINE NS::Array* MTL::RenderPipelineReflection::tileArguments() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(tileArguments));
}

_MTL_INLINE NS::Array* MTL::RenderPipelineReflection::tileBindings() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(tileBindings));
}

_MTL_INLINE NS::Array* MTL::RenderPipelineReflection::vertexArguments() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(vertexArguments));
}

_MTL_INLINE NS::Array* MTL::RenderPipelineReflection::vertexBindings() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(vertexBindings));
}

_MTL_INLINE MTL::RenderPipelineDescriptor* MTL::RenderPipelineDescriptor::alloc()
{
    return NS::Object::alloc<MTL::RenderPipelineDescriptor>(_MTL_PRIVATE_CLS(MTLRenderPipelineDescriptor));
}

_MTL_INLINE bool MTL::RenderPipelineDescriptor::alphaToCoverageEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isAlphaToCoverageEnabled));
}

_MTL_INLINE bool MTL::RenderPipelineDescriptor::alphaToOneEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isAlphaToOneEnabled));
}

_MTL_INLINE NS::Array* MTL::RenderPipelineDescriptor::binaryArchives() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(binaryArchives));
}

_MTL_INLINE MTL::RenderPipelineColorAttachmentDescriptorArray* MTL::RenderPipelineDescriptor::colorAttachments() const
{
    return Object::sendMessage<MTL::RenderPipelineColorAttachmentDescriptorArray*>(this, _MTL_PRIVATE_SEL(colorAttachments));
}

_MTL_INLINE MTL::PixelFormat MTL::RenderPipelineDescriptor::depthAttachmentPixelFormat() const
{
    return Object::sendMessage<MTL::PixelFormat>(this, _MTL_PRIVATE_SEL(depthAttachmentPixelFormat));
}

_MTL_INLINE MTL::PipelineBufferDescriptorArray* MTL::RenderPipelineDescriptor::fragmentBuffers() const
{
    return Object::sendMessage<MTL::PipelineBufferDescriptorArray*>(this, _MTL_PRIVATE_SEL(fragmentBuffers));
}

_MTL_INLINE MTL::Function* MTL::RenderPipelineDescriptor::fragmentFunction() const
{
    return Object::sendMessage<MTL::Function*>(this, _MTL_PRIVATE_SEL(fragmentFunction));
}

_MTL_INLINE MTL::LinkedFunctions* MTL::RenderPipelineDescriptor::fragmentLinkedFunctions() const
{
    return Object::sendMessage<MTL::LinkedFunctions*>(this, _MTL_PRIVATE_SEL(fragmentLinkedFunctions));
}

_MTL_INLINE NS::Array* MTL::RenderPipelineDescriptor::fragmentPreloadedLibraries() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(fragmentPreloadedLibraries));
}

_MTL_INLINE MTL::RenderPipelineDescriptor* MTL::RenderPipelineDescriptor::init()
{
    return NS::Object::init<MTL::RenderPipelineDescriptor>();
}

_MTL_INLINE MTL::PrimitiveTopologyClass MTL::RenderPipelineDescriptor::inputPrimitiveTopology() const
{
    return Object::sendMessage<MTL::PrimitiveTopologyClass>(this, _MTL_PRIVATE_SEL(inputPrimitiveTopology));
}

_MTL_INLINE bool MTL::RenderPipelineDescriptor::isAlphaToCoverageEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isAlphaToCoverageEnabled));
}

_MTL_INLINE bool MTL::RenderPipelineDescriptor::isAlphaToOneEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isAlphaToOneEnabled));
}

_MTL_INLINE bool MTL::RenderPipelineDescriptor::isRasterizationEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isRasterizationEnabled));
}

_MTL_INLINE bool MTL::RenderPipelineDescriptor::isTessellationFactorScaleEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isTessellationFactorScaleEnabled));
}

_MTL_INLINE NS::String* MTL::RenderPipelineDescriptor::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE NS::UInteger MTL::RenderPipelineDescriptor::maxFragmentCallStackDepth() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxFragmentCallStackDepth));
}

_MTL_INLINE NS::UInteger MTL::RenderPipelineDescriptor::maxTessellationFactor() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxTessellationFactor));
}

_MTL_INLINE NS::UInteger MTL::RenderPipelineDescriptor::maxVertexAmplificationCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxVertexAmplificationCount));
}

_MTL_INLINE NS::UInteger MTL::RenderPipelineDescriptor::maxVertexCallStackDepth() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxVertexCallStackDepth));
}

_MTL_INLINE NS::UInteger MTL::RenderPipelineDescriptor::rasterSampleCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(rasterSampleCount));
}

_MTL_INLINE bool MTL::RenderPipelineDescriptor::rasterizationEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isRasterizationEnabled));
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::reset()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(reset));
}

_MTL_INLINE NS::UInteger MTL::RenderPipelineDescriptor::sampleCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(sampleCount));
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setAlphaToCoverageEnabled(bool alphaToCoverageEnabled)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setAlphaToCoverageEnabled_), alphaToCoverageEnabled);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setAlphaToOneEnabled(bool alphaToOneEnabled)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setAlphaToOneEnabled_), alphaToOneEnabled);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setBinaryArchives(const NS::Array* binaryArchives)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBinaryArchives_), binaryArchives);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setDepthAttachmentPixelFormat(MTL::PixelFormat depthAttachmentPixelFormat)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthAttachmentPixelFormat_), depthAttachmentPixelFormat);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setFragmentFunction(const MTL::Function* fragmentFunction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentFunction_), fragmentFunction);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setFragmentLinkedFunctions(const MTL::LinkedFunctions* fragmentLinkedFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentLinkedFunctions_), fragmentLinkedFunctions);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setFragmentPreloadedLibraries(const NS::Array* fragmentPreloadedLibraries)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentPreloadedLibraries_), fragmentPreloadedLibraries);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setInputPrimitiveTopology(MTL::PrimitiveTopologyClass inputPrimitiveTopology)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInputPrimitiveTopology_), inputPrimitiveTopology);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setMaxFragmentCallStackDepth(NS::UInteger maxFragmentCallStackDepth)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxFragmentCallStackDepth_), maxFragmentCallStackDepth);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setMaxTessellationFactor(NS::UInteger maxTessellationFactor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxTessellationFactor_), maxTessellationFactor);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setMaxVertexAmplificationCount(NS::UInteger maxVertexAmplificationCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxVertexAmplificationCount_), maxVertexAmplificationCount);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setMaxVertexCallStackDepth(NS::UInteger maxVertexCallStackDepth)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxVertexCallStackDepth_), maxVertexCallStackDepth);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setRasterSampleCount(NS::UInteger rasterSampleCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRasterSampleCount_), rasterSampleCount);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setRasterizationEnabled(bool rasterizationEnabled)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRasterizationEnabled_), rasterizationEnabled);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setSampleCount(NS::UInteger sampleCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSampleCount_), sampleCount);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setShaderValidation(MTL::ShaderValidation shaderValidation)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setShaderValidation_), shaderValidation);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setStencilAttachmentPixelFormat(MTL::PixelFormat stencilAttachmentPixelFormat)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStencilAttachmentPixelFormat_), stencilAttachmentPixelFormat);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setSupportAddingFragmentBinaryFunctions(bool supportAddingFragmentBinaryFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportAddingFragmentBinaryFunctions_), supportAddingFragmentBinaryFunctions);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setSupportAddingVertexBinaryFunctions(bool supportAddingVertexBinaryFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportAddingVertexBinaryFunctions_), supportAddingVertexBinaryFunctions);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setSupportIndirectCommandBuffers(bool supportIndirectCommandBuffers)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportIndirectCommandBuffers_), supportIndirectCommandBuffers);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setTessellationControlPointIndexType(MTL::TessellationControlPointIndexType tessellationControlPointIndexType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTessellationControlPointIndexType_), tessellationControlPointIndexType);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setTessellationFactorFormat(MTL::TessellationFactorFormat tessellationFactorFormat)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTessellationFactorFormat_), tessellationFactorFormat);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setTessellationFactorScaleEnabled(bool tessellationFactorScaleEnabled)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTessellationFactorScaleEnabled_), tessellationFactorScaleEnabled);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setTessellationFactorStepFunction(MTL::TessellationFactorStepFunction tessellationFactorStepFunction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTessellationFactorStepFunction_), tessellationFactorStepFunction);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setTessellationOutputWindingOrder(MTL::Winding tessellationOutputWindingOrder)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTessellationOutputWindingOrder_), tessellationOutputWindingOrder);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setTessellationPartitionMode(MTL::TessellationPartitionMode tessellationPartitionMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTessellationPartitionMode_), tessellationPartitionMode);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setVertexDescriptor(const MTL::VertexDescriptor* vertexDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexDescriptor_), vertexDescriptor);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setVertexFunction(const MTL::Function* vertexFunction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexFunction_), vertexFunction);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setVertexLinkedFunctions(const MTL::LinkedFunctions* vertexLinkedFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexLinkedFunctions_), vertexLinkedFunctions);
}

_MTL_INLINE void MTL::RenderPipelineDescriptor::setVertexPreloadedLibraries(const NS::Array* vertexPreloadedLibraries)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexPreloadedLibraries_), vertexPreloadedLibraries);
}

_MTL_INLINE MTL::ShaderValidation MTL::RenderPipelineDescriptor::shaderValidation() const
{
    return Object::sendMessage<MTL::ShaderValidation>(this, _MTL_PRIVATE_SEL(shaderValidation));
}

_MTL_INLINE MTL::PixelFormat MTL::RenderPipelineDescriptor::stencilAttachmentPixelFormat() const
{
    return Object::sendMessage<MTL::PixelFormat>(this, _MTL_PRIVATE_SEL(stencilAttachmentPixelFormat));
}

_MTL_INLINE bool MTL::RenderPipelineDescriptor::supportAddingFragmentBinaryFunctions() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportAddingFragmentBinaryFunctions));
}

_MTL_INLINE bool MTL::RenderPipelineDescriptor::supportAddingVertexBinaryFunctions() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportAddingVertexBinaryFunctions));
}

_MTL_INLINE bool MTL::RenderPipelineDescriptor::supportIndirectCommandBuffers() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportIndirectCommandBuffers));
}

_MTL_INLINE MTL::TessellationControlPointIndexType MTL::RenderPipelineDescriptor::tessellationControlPointIndexType() const
{
    return Object::sendMessage<MTL::TessellationControlPointIndexType>(this, _MTL_PRIVATE_SEL(tessellationControlPointIndexType));
}

_MTL_INLINE MTL::TessellationFactorFormat MTL::RenderPipelineDescriptor::tessellationFactorFormat() const
{
    return Object::sendMessage<MTL::TessellationFactorFormat>(this, _MTL_PRIVATE_SEL(tessellationFactorFormat));
}

_MTL_INLINE bool MTL::RenderPipelineDescriptor::tessellationFactorScaleEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isTessellationFactorScaleEnabled));
}

_MTL_INLINE MTL::TessellationFactorStepFunction MTL::RenderPipelineDescriptor::tessellationFactorStepFunction() const
{
    return Object::sendMessage<MTL::TessellationFactorStepFunction>(this, _MTL_PRIVATE_SEL(tessellationFactorStepFunction));
}

_MTL_INLINE MTL::Winding MTL::RenderPipelineDescriptor::tessellationOutputWindingOrder() const
{
    return Object::sendMessage<MTL::Winding>(this, _MTL_PRIVATE_SEL(tessellationOutputWindingOrder));
}

_MTL_INLINE MTL::TessellationPartitionMode MTL::RenderPipelineDescriptor::tessellationPartitionMode() const
{
    return Object::sendMessage<MTL::TessellationPartitionMode>(this, _MTL_PRIVATE_SEL(tessellationPartitionMode));
}

_MTL_INLINE MTL::PipelineBufferDescriptorArray* MTL::RenderPipelineDescriptor::vertexBuffers() const
{
    return Object::sendMessage<MTL::PipelineBufferDescriptorArray*>(this, _MTL_PRIVATE_SEL(vertexBuffers));
}

_MTL_INLINE MTL::VertexDescriptor* MTL::RenderPipelineDescriptor::vertexDescriptor() const
{
    return Object::sendMessage<MTL::VertexDescriptor*>(this, _MTL_PRIVATE_SEL(vertexDescriptor));
}

_MTL_INLINE MTL::Function* MTL::RenderPipelineDescriptor::vertexFunction() const
{
    return Object::sendMessage<MTL::Function*>(this, _MTL_PRIVATE_SEL(vertexFunction));
}

_MTL_INLINE MTL::LinkedFunctions* MTL::RenderPipelineDescriptor::vertexLinkedFunctions() const
{
    return Object::sendMessage<MTL::LinkedFunctions*>(this, _MTL_PRIVATE_SEL(vertexLinkedFunctions));
}

_MTL_INLINE NS::Array* MTL::RenderPipelineDescriptor::vertexPreloadedLibraries() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(vertexPreloadedLibraries));
}

_MTL_INLINE MTL::RenderPipelineFunctionsDescriptor* MTL::RenderPipelineFunctionsDescriptor::alloc()
{
    return NS::Object::alloc<MTL::RenderPipelineFunctionsDescriptor>(_MTL_PRIVATE_CLS(MTLRenderPipelineFunctionsDescriptor));
}

_MTL_INLINE NS::Array* MTL::RenderPipelineFunctionsDescriptor::fragmentAdditionalBinaryFunctions() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(fragmentAdditionalBinaryFunctions));
}

_MTL_INLINE MTL::RenderPipelineFunctionsDescriptor* MTL::RenderPipelineFunctionsDescriptor::init()
{
    return NS::Object::init<MTL::RenderPipelineFunctionsDescriptor>();
}

_MTL_INLINE void MTL::RenderPipelineFunctionsDescriptor::setFragmentAdditionalBinaryFunctions(const NS::Array* fragmentAdditionalBinaryFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentAdditionalBinaryFunctions_), fragmentAdditionalBinaryFunctions);
}

_MTL_INLINE void MTL::RenderPipelineFunctionsDescriptor::setTileAdditionalBinaryFunctions(const NS::Array* tileAdditionalBinaryFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileAdditionalBinaryFunctions_), tileAdditionalBinaryFunctions);
}

_MTL_INLINE void MTL::RenderPipelineFunctionsDescriptor::setVertexAdditionalBinaryFunctions(const NS::Array* vertexAdditionalBinaryFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexAdditionalBinaryFunctions_), vertexAdditionalBinaryFunctions);
}

_MTL_INLINE NS::Array* MTL::RenderPipelineFunctionsDescriptor::tileAdditionalBinaryFunctions() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(tileAdditionalBinaryFunctions));
}

_MTL_INLINE NS::Array* MTL::RenderPipelineFunctionsDescriptor::vertexAdditionalBinaryFunctions() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(vertexAdditionalBinaryFunctions));
}

_MTL_INLINE MTL::Device* MTL::RenderPipelineState::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE MTL::FunctionHandle* MTL::RenderPipelineState::functionHandle(const NS::String* name, MTL::RenderStages stage)
{
    return Object::sendMessage<MTL::FunctionHandle*>(this, _MTL_PRIVATE_SEL(functionHandleWithName_stage_), name, stage);
}

_MTL_INLINE MTL::FunctionHandle* MTL::RenderPipelineState::functionHandle(const MTL4::BinaryFunction* function, MTL::RenderStages stage)
{
    return Object::sendMessage<MTL::FunctionHandle*>(this, _MTL_PRIVATE_SEL(functionHandleWithBinaryFunction_stage_), function, stage);
}

_MTL_INLINE MTL::FunctionHandle* MTL::RenderPipelineState::functionHandle(const MTL::Function* function, MTL::RenderStages stage)
{
    return Object::sendMessage<MTL::FunctionHandle*>(this, _MTL_PRIVATE_SEL(functionHandleWithFunction_stage_), function, stage);
}

_MTL_INLINE MTL::ResourceID MTL::RenderPipelineState::gpuResourceID() const
{
    return Object::sendMessage<MTL::ResourceID>(this, _MTL_PRIVATE_SEL(gpuResourceID));
}

_MTL_INLINE NS::UInteger MTL::RenderPipelineState::imageblockMemoryLength(MTL::Size imageblockDimensions)
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(imageblockMemoryLengthForDimensions_), imageblockDimensions);
}

_MTL_INLINE NS::UInteger MTL::RenderPipelineState::imageblockSampleLength() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(imageblockSampleLength));
}

_MTL_INLINE NS::String* MTL::RenderPipelineState::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE NS::UInteger MTL::RenderPipelineState::maxTotalThreadgroupsPerMeshGrid() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxTotalThreadgroupsPerMeshGrid));
}

_MTL_INLINE NS::UInteger MTL::RenderPipelineState::maxTotalThreadsPerMeshThreadgroup() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxTotalThreadsPerMeshThreadgroup));
}

_MTL_INLINE NS::UInteger MTL::RenderPipelineState::maxTotalThreadsPerObjectThreadgroup() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxTotalThreadsPerObjectThreadgroup));
}

_MTL_INLINE NS::UInteger MTL::RenderPipelineState::maxTotalThreadsPerThreadgroup() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxTotalThreadsPerThreadgroup));
}

_MTL_INLINE NS::UInteger MTL::RenderPipelineState::meshThreadExecutionWidth() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(meshThreadExecutionWidth));
}

_MTL_INLINE MTL::IntersectionFunctionTable* MTL::RenderPipelineState::newIntersectionFunctionTable(const MTL::IntersectionFunctionTableDescriptor* descriptor, MTL::RenderStages stage)
{
    return Object::sendMessage<MTL::IntersectionFunctionTable*>(this, _MTL_PRIVATE_SEL(newIntersectionFunctionTableWithDescriptor_stage_), descriptor, stage);
}

_MTL_INLINE MTL4::PipelineDescriptor* MTL::RenderPipelineState::newRenderPipelineDescriptor()
{
    return Object::sendMessage<MTL4::PipelineDescriptor*>(this, _MTL_PRIVATE_SEL(newRenderPipelineDescriptorForSpecialization));
}

_MTL_INLINE MTL::RenderPipelineState* MTL::RenderPipelineState::newRenderPipelineState(const MTL4::RenderPipelineBinaryFunctionsDescriptor* binaryFunctionsDescriptor, NS::Error** error)
{
    return Object::sendMessage<MTL::RenderPipelineState*>(this, _MTL_PRIVATE_SEL(newRenderPipelineStateWithBinaryFunctions_error_), binaryFunctionsDescriptor, error);
}

_MTL_INLINE MTL::RenderPipelineState* MTL::RenderPipelineState::newRenderPipelineState(const MTL::RenderPipelineFunctionsDescriptor* additionalBinaryFunctions, NS::Error** error)
{
    return Object::sendMessage<MTL::RenderPipelineState*>(this, _MTL_PRIVATE_SEL(newRenderPipelineStateWithAdditionalBinaryFunctions_error_), additionalBinaryFunctions, error);
}

_MTL_INLINE MTL::VisibleFunctionTable* MTL::RenderPipelineState::newVisibleFunctionTable(const MTL::VisibleFunctionTableDescriptor* descriptor, MTL::RenderStages stage)
{
    return Object::sendMessage<MTL::VisibleFunctionTable*>(this, _MTL_PRIVATE_SEL(newVisibleFunctionTableWithDescriptor_stage_), descriptor, stage);
}

_MTL_INLINE NS::UInteger MTL::RenderPipelineState::objectThreadExecutionWidth() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(objectThreadExecutionWidth));
}

_MTL_INLINE MTL::RenderPipelineReflection* MTL::RenderPipelineState::reflection() const
{
    return Object::sendMessage<MTL::RenderPipelineReflection*>(this, _MTL_PRIVATE_SEL(reflection));
}

_MTL_INLINE MTL::Size MTL::RenderPipelineState::requiredThreadsPerMeshThreadgroup() const
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(requiredThreadsPerMeshThreadgroup));
}

_MTL_INLINE MTL::Size MTL::RenderPipelineState::requiredThreadsPerObjectThreadgroup() const
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(requiredThreadsPerObjectThreadgroup));
}

_MTL_INLINE MTL::Size MTL::RenderPipelineState::requiredThreadsPerTileThreadgroup() const
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(requiredThreadsPerTileThreadgroup));
}

_MTL_INLINE MTL::ShaderValidation MTL::RenderPipelineState::shaderValidation() const
{
    return Object::sendMessage<MTL::ShaderValidation>(this, _MTL_PRIVATE_SEL(shaderValidation));
}

_MTL_INLINE bool MTL::RenderPipelineState::supportIndirectCommandBuffers() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportIndirectCommandBuffers));
}

_MTL_INLINE bool MTL::RenderPipelineState::threadgroupSizeMatchesTileSize() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(threadgroupSizeMatchesTileSize));
}

_MTL_INLINE MTL::RenderPipelineColorAttachmentDescriptorArray* MTL::RenderPipelineColorAttachmentDescriptorArray::alloc()
{
    return NS::Object::alloc<MTL::RenderPipelineColorAttachmentDescriptorArray>(_MTL_PRIVATE_CLS(MTLRenderPipelineColorAttachmentDescriptorArray));
}

_MTL_INLINE MTL::RenderPipelineColorAttachmentDescriptorArray* MTL::RenderPipelineColorAttachmentDescriptorArray::init()
{
    return NS::Object::init<MTL::RenderPipelineColorAttachmentDescriptorArray>();
}

_MTL_INLINE MTL::RenderPipelineColorAttachmentDescriptor* MTL::RenderPipelineColorAttachmentDescriptorArray::object(NS::UInteger attachmentIndex)
{
    return Object::sendMessage<MTL::RenderPipelineColorAttachmentDescriptor*>(this, _MTL_PRIVATE_SEL(objectAtIndexedSubscript_), attachmentIndex);
}

_MTL_INLINE void MTL::RenderPipelineColorAttachmentDescriptorArray::setObject(const MTL::RenderPipelineColorAttachmentDescriptor* attachment, NS::UInteger attachmentIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObject_atIndexedSubscript_), attachment, attachmentIndex);
}

_MTL_INLINE MTL::TileRenderPipelineColorAttachmentDescriptor* MTL::TileRenderPipelineColorAttachmentDescriptor::alloc()
{
    return NS::Object::alloc<MTL::TileRenderPipelineColorAttachmentDescriptor>(_MTL_PRIVATE_CLS(MTLTileRenderPipelineColorAttachmentDescriptor));
}

_MTL_INLINE MTL::TileRenderPipelineColorAttachmentDescriptor* MTL::TileRenderPipelineColorAttachmentDescriptor::init()
{
    return NS::Object::init<MTL::TileRenderPipelineColorAttachmentDescriptor>();
}

_MTL_INLINE MTL::PixelFormat MTL::TileRenderPipelineColorAttachmentDescriptor::pixelFormat() const
{
    return Object::sendMessage<MTL::PixelFormat>(this, _MTL_PRIVATE_SEL(pixelFormat));
}

_MTL_INLINE void MTL::TileRenderPipelineColorAttachmentDescriptor::setPixelFormat(MTL::PixelFormat pixelFormat)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPixelFormat_), pixelFormat);
}

_MTL_INLINE MTL::TileRenderPipelineColorAttachmentDescriptorArray* MTL::TileRenderPipelineColorAttachmentDescriptorArray::alloc()
{
    return NS::Object::alloc<MTL::TileRenderPipelineColorAttachmentDescriptorArray>(_MTL_PRIVATE_CLS(MTLTileRenderPipelineColorAttachmentDescriptorArray));
}

_MTL_INLINE MTL::TileRenderPipelineColorAttachmentDescriptorArray* MTL::TileRenderPipelineColorAttachmentDescriptorArray::init()
{
    return NS::Object::init<MTL::TileRenderPipelineColorAttachmentDescriptorArray>();
}

_MTL_INLINE MTL::TileRenderPipelineColorAttachmentDescriptor* MTL::TileRenderPipelineColorAttachmentDescriptorArray::object(NS::UInteger attachmentIndex)
{
    return Object::sendMessage<MTL::TileRenderPipelineColorAttachmentDescriptor*>(this, _MTL_PRIVATE_SEL(objectAtIndexedSubscript_), attachmentIndex);
}

_MTL_INLINE void MTL::TileRenderPipelineColorAttachmentDescriptorArray::setObject(const MTL::TileRenderPipelineColorAttachmentDescriptor* attachment, NS::UInteger attachmentIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObject_atIndexedSubscript_), attachment, attachmentIndex);
}

_MTL_INLINE MTL::TileRenderPipelineDescriptor* MTL::TileRenderPipelineDescriptor::alloc()
{
    return NS::Object::alloc<MTL::TileRenderPipelineDescriptor>(_MTL_PRIVATE_CLS(MTLTileRenderPipelineDescriptor));
}

_MTL_INLINE NS::Array* MTL::TileRenderPipelineDescriptor::binaryArchives() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(binaryArchives));
}

_MTL_INLINE MTL::TileRenderPipelineColorAttachmentDescriptorArray* MTL::TileRenderPipelineDescriptor::colorAttachments() const
{
    return Object::sendMessage<MTL::TileRenderPipelineColorAttachmentDescriptorArray*>(this, _MTL_PRIVATE_SEL(colorAttachments));
}

_MTL_INLINE MTL::TileRenderPipelineDescriptor* MTL::TileRenderPipelineDescriptor::init()
{
    return NS::Object::init<MTL::TileRenderPipelineDescriptor>();
}

_MTL_INLINE NS::String* MTL::TileRenderPipelineDescriptor::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE MTL::LinkedFunctions* MTL::TileRenderPipelineDescriptor::linkedFunctions() const
{
    return Object::sendMessage<MTL::LinkedFunctions*>(this, _MTL_PRIVATE_SEL(linkedFunctions));
}

_MTL_INLINE NS::UInteger MTL::TileRenderPipelineDescriptor::maxCallStackDepth() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxCallStackDepth));
}

_MTL_INLINE NS::UInteger MTL::TileRenderPipelineDescriptor::maxTotalThreadsPerThreadgroup() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxTotalThreadsPerThreadgroup));
}

_MTL_INLINE NS::Array* MTL::TileRenderPipelineDescriptor::preloadedLibraries() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(preloadedLibraries));
}

_MTL_INLINE NS::UInteger MTL::TileRenderPipelineDescriptor::rasterSampleCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(rasterSampleCount));
}

_MTL_INLINE MTL::Size MTL::TileRenderPipelineDescriptor::requiredThreadsPerThreadgroup() const
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(requiredThreadsPerThreadgroup));
}

_MTL_INLINE void MTL::TileRenderPipelineDescriptor::reset()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(reset));
}

_MTL_INLINE void MTL::TileRenderPipelineDescriptor::setBinaryArchives(const NS::Array* binaryArchives)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBinaryArchives_), binaryArchives);
}

_MTL_INLINE void MTL::TileRenderPipelineDescriptor::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE void MTL::TileRenderPipelineDescriptor::setLinkedFunctions(const MTL::LinkedFunctions* linkedFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLinkedFunctions_), linkedFunctions);
}

_MTL_INLINE void MTL::TileRenderPipelineDescriptor::setMaxCallStackDepth(NS::UInteger maxCallStackDepth)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxCallStackDepth_), maxCallStackDepth);
}

_MTL_INLINE void MTL::TileRenderPipelineDescriptor::setMaxTotalThreadsPerThreadgroup(NS::UInteger maxTotalThreadsPerThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxTotalThreadsPerThreadgroup_), maxTotalThreadsPerThreadgroup);
}

_MTL_INLINE void MTL::TileRenderPipelineDescriptor::setPreloadedLibraries(const NS::Array* preloadedLibraries)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPreloadedLibraries_), preloadedLibraries);
}

_MTL_INLINE void MTL::TileRenderPipelineDescriptor::setRasterSampleCount(NS::UInteger rasterSampleCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRasterSampleCount_), rasterSampleCount);
}

_MTL_INLINE void MTL::TileRenderPipelineDescriptor::setRequiredThreadsPerThreadgroup(MTL::Size requiredThreadsPerThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRequiredThreadsPerThreadgroup_), requiredThreadsPerThreadgroup);
}

_MTL_INLINE void MTL::TileRenderPipelineDescriptor::setShaderValidation(MTL::ShaderValidation shaderValidation)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setShaderValidation_), shaderValidation);
}

_MTL_INLINE void MTL::TileRenderPipelineDescriptor::setSupportAddingBinaryFunctions(bool supportAddingBinaryFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportAddingBinaryFunctions_), supportAddingBinaryFunctions);
}

_MTL_INLINE void MTL::TileRenderPipelineDescriptor::setThreadgroupSizeMatchesTileSize(bool threadgroupSizeMatchesTileSize)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setThreadgroupSizeMatchesTileSize_), threadgroupSizeMatchesTileSize);
}

_MTL_INLINE void MTL::TileRenderPipelineDescriptor::setTileFunction(const MTL::Function* tileFunction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileFunction_), tileFunction);
}

_MTL_INLINE MTL::ShaderValidation MTL::TileRenderPipelineDescriptor::shaderValidation() const
{
    return Object::sendMessage<MTL::ShaderValidation>(this, _MTL_PRIVATE_SEL(shaderValidation));
}

_MTL_INLINE bool MTL::TileRenderPipelineDescriptor::supportAddingBinaryFunctions() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportAddingBinaryFunctions));
}

_MTL_INLINE bool MTL::TileRenderPipelineDescriptor::threadgroupSizeMatchesTileSize() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(threadgroupSizeMatchesTileSize));
}

_MTL_INLINE MTL::PipelineBufferDescriptorArray* MTL::TileRenderPipelineDescriptor::tileBuffers() const
{
    return Object::sendMessage<MTL::PipelineBufferDescriptorArray*>(this, _MTL_PRIVATE_SEL(tileBuffers));
}

_MTL_INLINE MTL::Function* MTL::TileRenderPipelineDescriptor::tileFunction() const
{
    return Object::sendMessage<MTL::Function*>(this, _MTL_PRIVATE_SEL(tileFunction));
}

_MTL_INLINE MTL::MeshRenderPipelineDescriptor* MTL::MeshRenderPipelineDescriptor::alloc()
{
    return NS::Object::alloc<MTL::MeshRenderPipelineDescriptor>(_MTL_PRIVATE_CLS(MTLMeshRenderPipelineDescriptor));
}

_MTL_INLINE bool MTL::MeshRenderPipelineDescriptor::alphaToCoverageEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isAlphaToCoverageEnabled));
}

_MTL_INLINE bool MTL::MeshRenderPipelineDescriptor::alphaToOneEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isAlphaToOneEnabled));
}

_MTL_INLINE NS::Array* MTL::MeshRenderPipelineDescriptor::binaryArchives() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(binaryArchives));
}

_MTL_INLINE MTL::RenderPipelineColorAttachmentDescriptorArray* MTL::MeshRenderPipelineDescriptor::colorAttachments() const
{
    return Object::sendMessage<MTL::RenderPipelineColorAttachmentDescriptorArray*>(this, _MTL_PRIVATE_SEL(colorAttachments));
}

_MTL_INLINE MTL::PixelFormat MTL::MeshRenderPipelineDescriptor::depthAttachmentPixelFormat() const
{
    return Object::sendMessage<MTL::PixelFormat>(this, _MTL_PRIVATE_SEL(depthAttachmentPixelFormat));
}

_MTL_INLINE MTL::PipelineBufferDescriptorArray* MTL::MeshRenderPipelineDescriptor::fragmentBuffers() const
{
    return Object::sendMessage<MTL::PipelineBufferDescriptorArray*>(this, _MTL_PRIVATE_SEL(fragmentBuffers));
}

_MTL_INLINE MTL::Function* MTL::MeshRenderPipelineDescriptor::fragmentFunction() const
{
    return Object::sendMessage<MTL::Function*>(this, _MTL_PRIVATE_SEL(fragmentFunction));
}

_MTL_INLINE MTL::LinkedFunctions* MTL::MeshRenderPipelineDescriptor::fragmentLinkedFunctions() const
{
    return Object::sendMessage<MTL::LinkedFunctions*>(this, _MTL_PRIVATE_SEL(fragmentLinkedFunctions));
}

_MTL_INLINE MTL::MeshRenderPipelineDescriptor* MTL::MeshRenderPipelineDescriptor::init()
{
    return NS::Object::init<MTL::MeshRenderPipelineDescriptor>();
}

_MTL_INLINE bool MTL::MeshRenderPipelineDescriptor::isAlphaToCoverageEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isAlphaToCoverageEnabled));
}

_MTL_INLINE bool MTL::MeshRenderPipelineDescriptor::isAlphaToOneEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isAlphaToOneEnabled));
}

_MTL_INLINE bool MTL::MeshRenderPipelineDescriptor::isRasterizationEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isRasterizationEnabled));
}

_MTL_INLINE NS::String* MTL::MeshRenderPipelineDescriptor::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE NS::UInteger MTL::MeshRenderPipelineDescriptor::maxTotalThreadgroupsPerMeshGrid() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxTotalThreadgroupsPerMeshGrid));
}

_MTL_INLINE NS::UInteger MTL::MeshRenderPipelineDescriptor::maxTotalThreadsPerMeshThreadgroup() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxTotalThreadsPerMeshThreadgroup));
}

_MTL_INLINE NS::UInteger MTL::MeshRenderPipelineDescriptor::maxTotalThreadsPerObjectThreadgroup() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxTotalThreadsPerObjectThreadgroup));
}

_MTL_INLINE NS::UInteger MTL::MeshRenderPipelineDescriptor::maxVertexAmplificationCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxVertexAmplificationCount));
}

_MTL_INLINE MTL::PipelineBufferDescriptorArray* MTL::MeshRenderPipelineDescriptor::meshBuffers() const
{
    return Object::sendMessage<MTL::PipelineBufferDescriptorArray*>(this, _MTL_PRIVATE_SEL(meshBuffers));
}

_MTL_INLINE MTL::Function* MTL::MeshRenderPipelineDescriptor::meshFunction() const
{
    return Object::sendMessage<MTL::Function*>(this, _MTL_PRIVATE_SEL(meshFunction));
}

_MTL_INLINE MTL::LinkedFunctions* MTL::MeshRenderPipelineDescriptor::meshLinkedFunctions() const
{
    return Object::sendMessage<MTL::LinkedFunctions*>(this, _MTL_PRIVATE_SEL(meshLinkedFunctions));
}

_MTL_INLINE bool MTL::MeshRenderPipelineDescriptor::meshThreadgroupSizeIsMultipleOfThreadExecutionWidth() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(meshThreadgroupSizeIsMultipleOfThreadExecutionWidth));
}

_MTL_INLINE MTL::PipelineBufferDescriptorArray* MTL::MeshRenderPipelineDescriptor::objectBuffers() const
{
    return Object::sendMessage<MTL::PipelineBufferDescriptorArray*>(this, _MTL_PRIVATE_SEL(objectBuffers));
}

_MTL_INLINE MTL::Function* MTL::MeshRenderPipelineDescriptor::objectFunction() const
{
    return Object::sendMessage<MTL::Function*>(this, _MTL_PRIVATE_SEL(objectFunction));
}

_MTL_INLINE MTL::LinkedFunctions* MTL::MeshRenderPipelineDescriptor::objectLinkedFunctions() const
{
    return Object::sendMessage<MTL::LinkedFunctions*>(this, _MTL_PRIVATE_SEL(objectLinkedFunctions));
}

_MTL_INLINE bool MTL::MeshRenderPipelineDescriptor::objectThreadgroupSizeIsMultipleOfThreadExecutionWidth() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(objectThreadgroupSizeIsMultipleOfThreadExecutionWidth));
}

_MTL_INLINE NS::UInteger MTL::MeshRenderPipelineDescriptor::payloadMemoryLength() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(payloadMemoryLength));
}

_MTL_INLINE NS::UInteger MTL::MeshRenderPipelineDescriptor::rasterSampleCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(rasterSampleCount));
}

_MTL_INLINE bool MTL::MeshRenderPipelineDescriptor::rasterizationEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isRasterizationEnabled));
}

_MTL_INLINE MTL::Size MTL::MeshRenderPipelineDescriptor::requiredThreadsPerMeshThreadgroup() const
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(requiredThreadsPerMeshThreadgroup));
}

_MTL_INLINE MTL::Size MTL::MeshRenderPipelineDescriptor::requiredThreadsPerObjectThreadgroup() const
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(requiredThreadsPerObjectThreadgroup));
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::reset()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(reset));
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setAlphaToCoverageEnabled(bool alphaToCoverageEnabled)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setAlphaToCoverageEnabled_), alphaToCoverageEnabled);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setAlphaToOneEnabled(bool alphaToOneEnabled)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setAlphaToOneEnabled_), alphaToOneEnabled);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setBinaryArchives(const NS::Array* binaryArchives)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBinaryArchives_), binaryArchives);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setDepthAttachmentPixelFormat(MTL::PixelFormat depthAttachmentPixelFormat)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthAttachmentPixelFormat_), depthAttachmentPixelFormat);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setFragmentFunction(const MTL::Function* fragmentFunction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentFunction_), fragmentFunction);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setFragmentLinkedFunctions(const MTL::LinkedFunctions* fragmentLinkedFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentLinkedFunctions_), fragmentLinkedFunctions);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setMaxTotalThreadgroupsPerMeshGrid(NS::UInteger maxTotalThreadgroupsPerMeshGrid)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxTotalThreadgroupsPerMeshGrid_), maxTotalThreadgroupsPerMeshGrid);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setMaxTotalThreadsPerMeshThreadgroup(NS::UInteger maxTotalThreadsPerMeshThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxTotalThreadsPerMeshThreadgroup_), maxTotalThreadsPerMeshThreadgroup);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setMaxTotalThreadsPerObjectThreadgroup(NS::UInteger maxTotalThreadsPerObjectThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxTotalThreadsPerObjectThreadgroup_), maxTotalThreadsPerObjectThreadgroup);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setMaxVertexAmplificationCount(NS::UInteger maxVertexAmplificationCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxVertexAmplificationCount_), maxVertexAmplificationCount);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setMeshFunction(const MTL::Function* meshFunction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMeshFunction_), meshFunction);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setMeshLinkedFunctions(const MTL::LinkedFunctions* meshLinkedFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMeshLinkedFunctions_), meshLinkedFunctions);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setMeshThreadgroupSizeIsMultipleOfThreadExecutionWidth(bool meshThreadgroupSizeIsMultipleOfThreadExecutionWidth)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMeshThreadgroupSizeIsMultipleOfThreadExecutionWidth_), meshThreadgroupSizeIsMultipleOfThreadExecutionWidth);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setObjectFunction(const MTL::Function* objectFunction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectFunction_), objectFunction);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setObjectLinkedFunctions(const MTL::LinkedFunctions* objectLinkedFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectLinkedFunctions_), objectLinkedFunctions);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setObjectThreadgroupSizeIsMultipleOfThreadExecutionWidth(bool objectThreadgroupSizeIsMultipleOfThreadExecutionWidth)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectThreadgroupSizeIsMultipleOfThreadExecutionWidth_), objectThreadgroupSizeIsMultipleOfThreadExecutionWidth);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setPayloadMemoryLength(NS::UInteger payloadMemoryLength)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPayloadMemoryLength_), payloadMemoryLength);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setRasterSampleCount(NS::UInteger rasterSampleCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRasterSampleCount_), rasterSampleCount);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setRasterizationEnabled(bool rasterizationEnabled)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRasterizationEnabled_), rasterizationEnabled);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setRequiredThreadsPerMeshThreadgroup(MTL::Size requiredThreadsPerMeshThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRequiredThreadsPerMeshThreadgroup_), requiredThreadsPerMeshThreadgroup);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setRequiredThreadsPerObjectThreadgroup(MTL::Size requiredThreadsPerObjectThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRequiredThreadsPerObjectThreadgroup_), requiredThreadsPerObjectThreadgroup);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setShaderValidation(MTL::ShaderValidation shaderValidation)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setShaderValidation_), shaderValidation);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setStencilAttachmentPixelFormat(MTL::PixelFormat stencilAttachmentPixelFormat)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStencilAttachmentPixelFormat_), stencilAttachmentPixelFormat);
}

_MTL_INLINE void MTL::MeshRenderPipelineDescriptor::setSupportIndirectCommandBuffers(bool supportIndirectCommandBuffers)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportIndirectCommandBuffers_), supportIndirectCommandBuffers);
}

_MTL_INLINE MTL::ShaderValidation MTL::MeshRenderPipelineDescriptor::shaderValidation() const
{
    return Object::sendMessage<MTL::ShaderValidation>(this, _MTL_PRIVATE_SEL(shaderValidation));
}

_MTL_INLINE MTL::PixelFormat MTL::MeshRenderPipelineDescriptor::stencilAttachmentPixelFormat() const
{
    return Object::sendMessage<MTL::PixelFormat>(this, _MTL_PRIVATE_SEL(stencilAttachmentPixelFormat));
}

_MTL_INLINE bool MTL::MeshRenderPipelineDescriptor::supportIndirectCommandBuffers() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportIndirectCommandBuffers));
}

#pragma once

#include <cstdint>

namespace MTL
{
class Buffer;
class Fence;
struct Region;
class Texture;
_MTL_ENUM(NS::UInteger, SparseTextureMappingMode) {
    SparseTextureMappingModeMap = 0,
    SparseTextureMappingModeUnmap = 1,
};

struct MapIndirectArguments
{
    uint32_t regionOriginX;
    uint32_t regionOriginY;
    uint32_t regionOriginZ;
    uint32_t regionSizeWidth;
    uint32_t regionSizeHeight;
    uint32_t regionSizeDepth;
    uint32_t mipMapLevel;
    uint32_t sliceId;
} _MTL_PACKED;

class ResourceStateCommandEncoder : public NS::Referencing<ResourceStateCommandEncoder, CommandEncoder>
{
public:
    void moveTextureMappingsFromTexture(const MTL::Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, MTL::Origin sourceOrigin, MTL::Size sourceSize, const MTL::Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, MTL::Origin destinationOrigin);

    void updateFence(const MTL::Fence* fence);

    void updateTextureMapping(const MTL::Texture* texture, const MTL::SparseTextureMappingMode mode, const MTL::Region region, const NS::UInteger mipLevel, const NS::UInteger slice);
    void updateTextureMapping(const MTL::Texture* texture, const MTL::SparseTextureMappingMode mode, const MTL::Buffer* indirectBuffer, NS::UInteger indirectBufferOffset);
    void updateTextureMappings(const MTL::Texture* texture, const MTL::SparseTextureMappingMode mode, const MTL::Region* regions, const NS::UInteger* mipLevels, const NS::UInteger* slices, NS::UInteger numRegions);

    void waitForFence(const MTL::Fence* fence);
};

}

_MTL_INLINE void MTL::ResourceStateCommandEncoder::moveTextureMappingsFromTexture(const MTL::Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, MTL::Origin sourceOrigin, MTL::Size sourceSize, const MTL::Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, MTL::Origin destinationOrigin)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(moveTextureMappingsFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin_), sourceTexture, sourceSlice, sourceLevel, sourceOrigin, sourceSize, destinationTexture, destinationSlice, destinationLevel, destinationOrigin);
}

_MTL_INLINE void MTL::ResourceStateCommandEncoder::updateFence(const MTL::Fence* fence)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(updateFence_), fence);
}

_MTL_INLINE void MTL::ResourceStateCommandEncoder::updateTextureMapping(const MTL::Texture* texture, const MTL::SparseTextureMappingMode mode, const MTL::Region region, const NS::UInteger mipLevel, const NS::UInteger slice)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(updateTextureMapping_mode_region_mipLevel_slice_), texture, mode, region, mipLevel, slice);
}

_MTL_INLINE void MTL::ResourceStateCommandEncoder::updateTextureMapping(const MTL::Texture* texture, const MTL::SparseTextureMappingMode mode, const MTL::Buffer* indirectBuffer, NS::UInteger indirectBufferOffset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(updateTextureMapping_mode_indirectBuffer_indirectBufferOffset_), texture, mode, indirectBuffer, indirectBufferOffset);
}

_MTL_INLINE void MTL::ResourceStateCommandEncoder::updateTextureMappings(const MTL::Texture* texture, const MTL::SparseTextureMappingMode mode, const MTL::Region* regions, const NS::UInteger* mipLevels, const NS::UInteger* slices, NS::UInteger numRegions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(updateTextureMappings_mode_regions_mipLevels_slices_numRegions_), texture, mode, regions, mipLevels, slices, numRegions);
}

_MTL_INLINE void MTL::ResourceStateCommandEncoder::waitForFence(const MTL::Fence* fence)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(waitForFence_), fence);
}

#pragma once

namespace MTL
{
class CounterSampleBuffer;
class ResourceStatePassDescriptor;
class ResourceStatePassSampleBufferAttachmentDescriptor;
class ResourceStatePassSampleBufferAttachmentDescriptorArray;

class ResourceStatePassSampleBufferAttachmentDescriptor : public NS::Copying<ResourceStatePassSampleBufferAttachmentDescriptor>
{
public:
    static ResourceStatePassSampleBufferAttachmentDescriptor* alloc();

    NS::UInteger                                              endOfEncoderSampleIndex() const;

    ResourceStatePassSampleBufferAttachmentDescriptor*        init();

    CounterSampleBuffer*                                      sampleBuffer() const;

    void                                                      setEndOfEncoderSampleIndex(NS::UInteger endOfEncoderSampleIndex);

    void                                                      setSampleBuffer(const MTL::CounterSampleBuffer* sampleBuffer);

    void                                                      setStartOfEncoderSampleIndex(NS::UInteger startOfEncoderSampleIndex);
    NS::UInteger                                              startOfEncoderSampleIndex() const;
};
class ResourceStatePassSampleBufferAttachmentDescriptorArray : public NS::Referencing<ResourceStatePassSampleBufferAttachmentDescriptorArray>
{
public:
    static ResourceStatePassSampleBufferAttachmentDescriptorArray* alloc();

    ResourceStatePassSampleBufferAttachmentDescriptorArray*        init();

    ResourceStatePassSampleBufferAttachmentDescriptor*             object(NS::UInteger attachmentIndex);
    void                                                           setObject(const MTL::ResourceStatePassSampleBufferAttachmentDescriptor* attachment, NS::UInteger attachmentIndex);
};
class ResourceStatePassDescriptor : public NS::Copying<ResourceStatePassDescriptor>
{
public:
    static ResourceStatePassDescriptor*                     alloc();

    ResourceStatePassDescriptor*                            init();

    static ResourceStatePassDescriptor*                     resourceStatePassDescriptor();

    ResourceStatePassSampleBufferAttachmentDescriptorArray* sampleBufferAttachments() const;
};

}
_MTL_INLINE MTL::ResourceStatePassSampleBufferAttachmentDescriptor* MTL::ResourceStatePassSampleBufferAttachmentDescriptor::alloc()
{
    return NS::Object::alloc<MTL::ResourceStatePassSampleBufferAttachmentDescriptor>(_MTL_PRIVATE_CLS(MTLResourceStatePassSampleBufferAttachmentDescriptor));
}

_MTL_INLINE NS::UInteger MTL::ResourceStatePassSampleBufferAttachmentDescriptor::endOfEncoderSampleIndex() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(endOfEncoderSampleIndex));
}

_MTL_INLINE MTL::ResourceStatePassSampleBufferAttachmentDescriptor* MTL::ResourceStatePassSampleBufferAttachmentDescriptor::init()
{
    return NS::Object::init<MTL::ResourceStatePassSampleBufferAttachmentDescriptor>();
}

_MTL_INLINE MTL::CounterSampleBuffer* MTL::ResourceStatePassSampleBufferAttachmentDescriptor::sampleBuffer() const
{
    return Object::sendMessage<MTL::CounterSampleBuffer*>(this, _MTL_PRIVATE_SEL(sampleBuffer));
}

_MTL_INLINE void MTL::ResourceStatePassSampleBufferAttachmentDescriptor::setEndOfEncoderSampleIndex(NS::UInteger endOfEncoderSampleIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setEndOfEncoderSampleIndex_), endOfEncoderSampleIndex);
}

_MTL_INLINE void MTL::ResourceStatePassSampleBufferAttachmentDescriptor::setSampleBuffer(const MTL::CounterSampleBuffer* sampleBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSampleBuffer_), sampleBuffer);
}

_MTL_INLINE void MTL::ResourceStatePassSampleBufferAttachmentDescriptor::setStartOfEncoderSampleIndex(NS::UInteger startOfEncoderSampleIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStartOfEncoderSampleIndex_), startOfEncoderSampleIndex);
}

_MTL_INLINE NS::UInteger MTL::ResourceStatePassSampleBufferAttachmentDescriptor::startOfEncoderSampleIndex() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(startOfEncoderSampleIndex));
}

_MTL_INLINE MTL::ResourceStatePassSampleBufferAttachmentDescriptorArray* MTL::ResourceStatePassSampleBufferAttachmentDescriptorArray::alloc()
{
    return NS::Object::alloc<MTL::ResourceStatePassSampleBufferAttachmentDescriptorArray>(_MTL_PRIVATE_CLS(MTLResourceStatePassSampleBufferAttachmentDescriptorArray));
}

_MTL_INLINE MTL::ResourceStatePassSampleBufferAttachmentDescriptorArray* MTL::ResourceStatePassSampleBufferAttachmentDescriptorArray::init()
{
    return NS::Object::init<MTL::ResourceStatePassSampleBufferAttachmentDescriptorArray>();
}

_MTL_INLINE MTL::ResourceStatePassSampleBufferAttachmentDescriptor* MTL::ResourceStatePassSampleBufferAttachmentDescriptorArray::object(NS::UInteger attachmentIndex)
{
    return Object::sendMessage<MTL::ResourceStatePassSampleBufferAttachmentDescriptor*>(this, _MTL_PRIVATE_SEL(objectAtIndexedSubscript_), attachmentIndex);
}

_MTL_INLINE void MTL::ResourceStatePassSampleBufferAttachmentDescriptorArray::setObject(const MTL::ResourceStatePassSampleBufferAttachmentDescriptor* attachment, NS::UInteger attachmentIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObject_atIndexedSubscript_), attachment, attachmentIndex);
}

_MTL_INLINE MTL::ResourceStatePassDescriptor* MTL::ResourceStatePassDescriptor::alloc()
{
    return NS::Object::alloc<MTL::ResourceStatePassDescriptor>(_MTL_PRIVATE_CLS(MTLResourceStatePassDescriptor));
}

_MTL_INLINE MTL::ResourceStatePassDescriptor* MTL::ResourceStatePassDescriptor::init()
{
    return NS::Object::init<MTL::ResourceStatePassDescriptor>();
}

_MTL_INLINE MTL::ResourceStatePassDescriptor* MTL::ResourceStatePassDescriptor::resourceStatePassDescriptor()
{
    return Object::sendMessage<MTL::ResourceStatePassDescriptor*>(_MTL_PRIVATE_CLS(MTLResourceStatePassDescriptor), _MTL_PRIVATE_SEL(resourceStatePassDescriptor));
}

_MTL_INLINE MTL::ResourceStatePassSampleBufferAttachmentDescriptorArray* MTL::ResourceStatePassDescriptor::sampleBufferAttachments() const
{
    return Object::sendMessage<MTL::ResourceStatePassSampleBufferAttachmentDescriptorArray*>(this, _MTL_PRIVATE_SEL(sampleBufferAttachments));
}

#pragma once

namespace MTL
{
class Device;
class SamplerDescriptor;
_MTL_ENUM(NS::UInteger, SamplerMinMagFilter) {
    SamplerMinMagFilterNearest = 0,
    SamplerMinMagFilterLinear = 1,
};

_MTL_ENUM(NS::UInteger, SamplerMipFilter) {
    SamplerMipFilterNotMipmapped = 0,
    SamplerMipFilterNearest = 1,
    SamplerMipFilterLinear = 2,
};

_MTL_ENUM(NS::UInteger, SamplerAddressMode) {
    SamplerAddressModeClampToEdge = 0,
    SamplerAddressModeMirrorClampToEdge = 1,
    SamplerAddressModeRepeat = 2,
    SamplerAddressModeMirrorRepeat = 3,
    SamplerAddressModeClampToZero = 4,
    SamplerAddressModeClampToBorderColor = 5,
};

_MTL_ENUM(NS::UInteger, SamplerBorderColor) {
    SamplerBorderColorTransparentBlack = 0,
    SamplerBorderColorOpaqueBlack = 1,
    SamplerBorderColorOpaqueWhite = 2,
};

_MTL_ENUM(NS::UInteger, SamplerReductionMode) {
    SamplerReductionModeWeightedAverage = 0,
    SamplerReductionModeMinimum = 1,
    SamplerReductionModeMaximum = 2,
};

class SamplerDescriptor : public NS::Copying<SamplerDescriptor>
{
public:
    static SamplerDescriptor* alloc();

    SamplerBorderColor        borderColor() const;

    CompareFunction           compareFunction() const;

    SamplerDescriptor*        init();

    NS::String*               label() const;

    bool                      lodAverage() const;

    float                     lodBias() const;

    float                     lodMaxClamp() const;

    float                     lodMinClamp() const;

    SamplerMinMagFilter       magFilter() const;

    NS::UInteger              maxAnisotropy() const;

    SamplerMinMagFilter       minFilter() const;

    SamplerMipFilter          mipFilter() const;

    bool                      normalizedCoordinates() const;

    SamplerAddressMode        rAddressMode() const;

    SamplerReductionMode      reductionMode() const;

    SamplerAddressMode        sAddressMode() const;

    void                      setBorderColor(MTL::SamplerBorderColor borderColor);

    void                      setCompareFunction(MTL::CompareFunction compareFunction);

    void                      setLabel(const NS::String* label);

    void                      setLodAverage(bool lodAverage);

    void                      setLodBias(float lodBias);

    void                      setLodMaxClamp(float lodMaxClamp);

    void                      setLodMinClamp(float lodMinClamp);

    void                      setMagFilter(MTL::SamplerMinMagFilter magFilter);

    void                      setMaxAnisotropy(NS::UInteger maxAnisotropy);

    void                      setMinFilter(MTL::SamplerMinMagFilter minFilter);

    void                      setMipFilter(MTL::SamplerMipFilter mipFilter);

    void                      setNormalizedCoordinates(bool normalizedCoordinates);

    void                      setRAddressMode(MTL::SamplerAddressMode rAddressMode);

    void                      setReductionMode(MTL::SamplerReductionMode reductionMode);

    void                      setSAddressMode(MTL::SamplerAddressMode sAddressMode);

    void                      setSupportArgumentBuffers(bool supportArgumentBuffers);

    void                      setTAddressMode(MTL::SamplerAddressMode tAddressMode);

    bool                      supportArgumentBuffers() const;

    SamplerAddressMode        tAddressMode() const;
};
class SamplerState : public NS::Referencing<SamplerState>
{
public:
    Device*     device() const;

    ResourceID  gpuResourceID() const;

    NS::String* label() const;
};

}
_MTL_INLINE MTL::SamplerDescriptor* MTL::SamplerDescriptor::alloc()
{
    return NS::Object::alloc<MTL::SamplerDescriptor>(_MTL_PRIVATE_CLS(MTLSamplerDescriptor));
}

_MTL_INLINE MTL::SamplerBorderColor MTL::SamplerDescriptor::borderColor() const
{
    return Object::sendMessage<MTL::SamplerBorderColor>(this, _MTL_PRIVATE_SEL(borderColor));
}

_MTL_INLINE MTL::CompareFunction MTL::SamplerDescriptor::compareFunction() const
{
    return Object::sendMessage<MTL::CompareFunction>(this, _MTL_PRIVATE_SEL(compareFunction));
}

_MTL_INLINE MTL::SamplerDescriptor* MTL::SamplerDescriptor::init()
{
    return NS::Object::init<MTL::SamplerDescriptor>();
}

_MTL_INLINE NS::String* MTL::SamplerDescriptor::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE bool MTL::SamplerDescriptor::lodAverage() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(lodAverage));
}

_MTL_INLINE float MTL::SamplerDescriptor::lodBias() const
{
    return Object::sendMessage<float>(this, _MTL_PRIVATE_SEL(lodBias));
}

_MTL_INLINE float MTL::SamplerDescriptor::lodMaxClamp() const
{
    return Object::sendMessage<float>(this, _MTL_PRIVATE_SEL(lodMaxClamp));
}

_MTL_INLINE float MTL::SamplerDescriptor::lodMinClamp() const
{
    return Object::sendMessage<float>(this, _MTL_PRIVATE_SEL(lodMinClamp));
}

_MTL_INLINE MTL::SamplerMinMagFilter MTL::SamplerDescriptor::magFilter() const
{
    return Object::sendMessage<MTL::SamplerMinMagFilter>(this, _MTL_PRIVATE_SEL(magFilter));
}

_MTL_INLINE NS::UInteger MTL::SamplerDescriptor::maxAnisotropy() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxAnisotropy));
}

_MTL_INLINE MTL::SamplerMinMagFilter MTL::SamplerDescriptor::minFilter() const
{
    return Object::sendMessage<MTL::SamplerMinMagFilter>(this, _MTL_PRIVATE_SEL(minFilter));
}

_MTL_INLINE MTL::SamplerMipFilter MTL::SamplerDescriptor::mipFilter() const
{
    return Object::sendMessage<MTL::SamplerMipFilter>(this, _MTL_PRIVATE_SEL(mipFilter));
}

_MTL_INLINE bool MTL::SamplerDescriptor::normalizedCoordinates() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(normalizedCoordinates));
}

_MTL_INLINE MTL::SamplerAddressMode MTL::SamplerDescriptor::rAddressMode() const
{
    return Object::sendMessage<MTL::SamplerAddressMode>(this, _MTL_PRIVATE_SEL(rAddressMode));
}

_MTL_INLINE MTL::SamplerReductionMode MTL::SamplerDescriptor::reductionMode() const
{
    return Object::sendMessage<MTL::SamplerReductionMode>(this, _MTL_PRIVATE_SEL(reductionMode));
}

_MTL_INLINE MTL::SamplerAddressMode MTL::SamplerDescriptor::sAddressMode() const
{
    return Object::sendMessage<MTL::SamplerAddressMode>(this, _MTL_PRIVATE_SEL(sAddressMode));
}

_MTL_INLINE void MTL::SamplerDescriptor::setBorderColor(MTL::SamplerBorderColor borderColor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBorderColor_), borderColor);
}

_MTL_INLINE void MTL::SamplerDescriptor::setCompareFunction(MTL::CompareFunction compareFunction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setCompareFunction_), compareFunction);
}

_MTL_INLINE void MTL::SamplerDescriptor::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE void MTL::SamplerDescriptor::setLodAverage(bool lodAverage)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLodAverage_), lodAverage);
}

_MTL_INLINE void MTL::SamplerDescriptor::setLodBias(float lodBias)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLodBias_), lodBias);
}

_MTL_INLINE void MTL::SamplerDescriptor::setLodMaxClamp(float lodMaxClamp)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLodMaxClamp_), lodMaxClamp);
}

_MTL_INLINE void MTL::SamplerDescriptor::setLodMinClamp(float lodMinClamp)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLodMinClamp_), lodMinClamp);
}

_MTL_INLINE void MTL::SamplerDescriptor::setMagFilter(MTL::SamplerMinMagFilter magFilter)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMagFilter_), magFilter);
}

_MTL_INLINE void MTL::SamplerDescriptor::setMaxAnisotropy(NS::UInteger maxAnisotropy)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxAnisotropy_), maxAnisotropy);
}

_MTL_INLINE void MTL::SamplerDescriptor::setMinFilter(MTL::SamplerMinMagFilter minFilter)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMinFilter_), minFilter);
}

_MTL_INLINE void MTL::SamplerDescriptor::setMipFilter(MTL::SamplerMipFilter mipFilter)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMipFilter_), mipFilter);
}

_MTL_INLINE void MTL::SamplerDescriptor::setNormalizedCoordinates(bool normalizedCoordinates)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setNormalizedCoordinates_), normalizedCoordinates);
}

_MTL_INLINE void MTL::SamplerDescriptor::setRAddressMode(MTL::SamplerAddressMode rAddressMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRAddressMode_), rAddressMode);
}

_MTL_INLINE void MTL::SamplerDescriptor::setReductionMode(MTL::SamplerReductionMode reductionMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setReductionMode_), reductionMode);
}

_MTL_INLINE void MTL::SamplerDescriptor::setSAddressMode(MTL::SamplerAddressMode sAddressMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSAddressMode_), sAddressMode);
}

_MTL_INLINE void MTL::SamplerDescriptor::setSupportArgumentBuffers(bool supportArgumentBuffers)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportArgumentBuffers_), supportArgumentBuffers);
}

_MTL_INLINE void MTL::SamplerDescriptor::setTAddressMode(MTL::SamplerAddressMode tAddressMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTAddressMode_), tAddressMode);
}

_MTL_INLINE bool MTL::SamplerDescriptor::supportArgumentBuffers() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportArgumentBuffers));
}

_MTL_INLINE MTL::SamplerAddressMode MTL::SamplerDescriptor::tAddressMode() const
{
    return Object::sendMessage<MTL::SamplerAddressMode>(this, _MTL_PRIVATE_SEL(tAddressMode));
}

_MTL_INLINE MTL::Device* MTL::SamplerState::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE MTL::ResourceID MTL::SamplerState::gpuResourceID() const
{
    return Object::sendMessage<MTL::ResourceID>(this, _MTL_PRIVATE_SEL(gpuResourceID));
}

_MTL_INLINE NS::String* MTL::SamplerState::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

#pragma once

namespace MTL
{
class VertexAttributeDescriptor;
class VertexAttributeDescriptorArray;
class VertexBufferLayoutDescriptor;
class VertexBufferLayoutDescriptorArray;
class VertexDescriptor;
_MTL_ENUM(NS::UInteger, VertexFormat) {
    VertexFormatInvalid = 0,
    VertexFormatUChar2 = 1,
    VertexFormatUChar3 = 2,
    VertexFormatUChar4 = 3,
    VertexFormatChar2 = 4,
    VertexFormatChar3 = 5,
    VertexFormatChar4 = 6,
    VertexFormatUChar2Normalized = 7,
    VertexFormatUChar3Normalized = 8,
    VertexFormatUChar4Normalized = 9,
    VertexFormatChar2Normalized = 10,
    VertexFormatChar3Normalized = 11,
    VertexFormatChar4Normalized = 12,
    VertexFormatUShort2 = 13,
    VertexFormatUShort3 = 14,
    VertexFormatUShort4 = 15,
    VertexFormatShort2 = 16,
    VertexFormatShort3 = 17,
    VertexFormatShort4 = 18,
    VertexFormatUShort2Normalized = 19,
    VertexFormatUShort3Normalized = 20,
    VertexFormatUShort4Normalized = 21,
    VertexFormatShort2Normalized = 22,
    VertexFormatShort3Normalized = 23,
    VertexFormatShort4Normalized = 24,
    VertexFormatHalf2 = 25,
    VertexFormatHalf3 = 26,
    VertexFormatHalf4 = 27,
    VertexFormatFloat = 28,
    VertexFormatFloat2 = 29,
    VertexFormatFloat3 = 30,
    VertexFormatFloat4 = 31,
    VertexFormatInt = 32,
    VertexFormatInt2 = 33,
    VertexFormatInt3 = 34,
    VertexFormatInt4 = 35,
    VertexFormatUInt = 36,
    VertexFormatUInt2 = 37,
    VertexFormatUInt3 = 38,
    VertexFormatUInt4 = 39,
    VertexFormatInt1010102Normalized = 40,
    VertexFormatUInt1010102Normalized = 41,
    VertexFormatUChar4Normalized_BGRA = 42,
    VertexFormatUChar = 45,
    VertexFormatChar = 46,
    VertexFormatUCharNormalized = 47,
    VertexFormatCharNormalized = 48,
    VertexFormatUShort = 49,
    VertexFormatShort = 50,
    VertexFormatUShortNormalized = 51,
    VertexFormatShortNormalized = 52,
    VertexFormatHalf = 53,
    VertexFormatFloatRG11B10 = 54,
    VertexFormatFloatRGB9E5 = 55,
};

_MTL_ENUM(NS::UInteger, VertexStepFunction) {
    VertexStepFunctionConstant = 0,
    VertexStepFunctionPerVertex = 1,
    VertexStepFunctionPerInstance = 2,
    VertexStepFunctionPerPatch = 3,
    VertexStepFunctionPerPatchControlPoint = 4,
};

static const NS::UInteger BufferLayoutStrideDynamic = NS::UIntegerMax;

class VertexBufferLayoutDescriptor : public NS::Copying<VertexBufferLayoutDescriptor>
{
public:
    static VertexBufferLayoutDescriptor* alloc();

    VertexBufferLayoutDescriptor*        init();

    void                                 setStepFunction(MTL::VertexStepFunction stepFunction);

    void                                 setStepRate(NS::UInteger stepRate);

    void                                 setStride(NS::UInteger stride);

    VertexStepFunction                   stepFunction() const;

    NS::UInteger                         stepRate() const;

    NS::UInteger                         stride() const;
};
class VertexBufferLayoutDescriptorArray : public NS::Referencing<VertexBufferLayoutDescriptorArray>
{
public:
    static VertexBufferLayoutDescriptorArray* alloc();

    VertexBufferLayoutDescriptorArray*        init();

    VertexBufferLayoutDescriptor*             object(NS::UInteger index);
    void                                      setObject(const MTL::VertexBufferLayoutDescriptor* bufferDesc, NS::UInteger index);
};
class VertexAttributeDescriptor : public NS::Copying<VertexAttributeDescriptor>
{
public:
    static VertexAttributeDescriptor* alloc();

    NS::UInteger                      bufferIndex() const;

    VertexFormat                      format() const;

    VertexAttributeDescriptor*        init();

    NS::UInteger                      offset() const;

    void                              setBufferIndex(NS::UInteger bufferIndex);

    void                              setFormat(MTL::VertexFormat format);

    void                              setOffset(NS::UInteger offset);
};
class VertexAttributeDescriptorArray : public NS::Referencing<VertexAttributeDescriptorArray>
{
public:
    static VertexAttributeDescriptorArray* alloc();

    VertexAttributeDescriptorArray*        init();

    VertexAttributeDescriptor*             object(NS::UInteger index);
    void                                   setObject(const MTL::VertexAttributeDescriptor* attributeDesc, NS::UInteger index);
};
class VertexDescriptor : public NS::Copying<VertexDescriptor>
{
public:
    static VertexDescriptor*           alloc();

    VertexAttributeDescriptorArray*    attributes() const;

    VertexDescriptor*                  init();

    VertexBufferLayoutDescriptorArray* layouts() const;

    void                               reset();

    static VertexDescriptor*           vertexDescriptor();
};

}

_MTL_INLINE MTL::VertexBufferLayoutDescriptor* MTL::VertexBufferLayoutDescriptor::alloc()
{
    return NS::Object::alloc<MTL::VertexBufferLayoutDescriptor>(_MTL_PRIVATE_CLS(MTLVertexBufferLayoutDescriptor));
}

_MTL_INLINE MTL::VertexBufferLayoutDescriptor* MTL::VertexBufferLayoutDescriptor::init()
{
    return NS::Object::init<MTL::VertexBufferLayoutDescriptor>();
}

_MTL_INLINE void MTL::VertexBufferLayoutDescriptor::setStepFunction(MTL::VertexStepFunction stepFunction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStepFunction_), stepFunction);
}

_MTL_INLINE void MTL::VertexBufferLayoutDescriptor::setStepRate(NS::UInteger stepRate)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStepRate_), stepRate);
}

_MTL_INLINE void MTL::VertexBufferLayoutDescriptor::setStride(NS::UInteger stride)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStride_), stride);
}

_MTL_INLINE MTL::VertexStepFunction MTL::VertexBufferLayoutDescriptor::stepFunction() const
{
    return Object::sendMessage<MTL::VertexStepFunction>(this, _MTL_PRIVATE_SEL(stepFunction));
}

_MTL_INLINE NS::UInteger MTL::VertexBufferLayoutDescriptor::stepRate() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(stepRate));
}

_MTL_INLINE NS::UInteger MTL::VertexBufferLayoutDescriptor::stride() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(stride));
}

_MTL_INLINE MTL::VertexBufferLayoutDescriptorArray* MTL::VertexBufferLayoutDescriptorArray::alloc()
{
    return NS::Object::alloc<MTL::VertexBufferLayoutDescriptorArray>(_MTL_PRIVATE_CLS(MTLVertexBufferLayoutDescriptorArray));
}

_MTL_INLINE MTL::VertexBufferLayoutDescriptorArray* MTL::VertexBufferLayoutDescriptorArray::init()
{
    return NS::Object::init<MTL::VertexBufferLayoutDescriptorArray>();
}

_MTL_INLINE MTL::VertexBufferLayoutDescriptor* MTL::VertexBufferLayoutDescriptorArray::object(NS::UInteger index)
{
    return Object::sendMessage<MTL::VertexBufferLayoutDescriptor*>(this, _MTL_PRIVATE_SEL(objectAtIndexedSubscript_), index);
}

_MTL_INLINE void MTL::VertexBufferLayoutDescriptorArray::setObject(const MTL::VertexBufferLayoutDescriptor* bufferDesc, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObject_atIndexedSubscript_), bufferDesc, index);
}

_MTL_INLINE MTL::VertexAttributeDescriptor* MTL::VertexAttributeDescriptor::alloc()
{
    return NS::Object::alloc<MTL::VertexAttributeDescriptor>(_MTL_PRIVATE_CLS(MTLVertexAttributeDescriptor));
}

_MTL_INLINE NS::UInteger MTL::VertexAttributeDescriptor::bufferIndex() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(bufferIndex));
}

_MTL_INLINE MTL::VertexFormat MTL::VertexAttributeDescriptor::format() const
{
    return Object::sendMessage<MTL::VertexFormat>(this, _MTL_PRIVATE_SEL(format));
}

_MTL_INLINE MTL::VertexAttributeDescriptor* MTL::VertexAttributeDescriptor::init()
{
    return NS::Object::init<MTL::VertexAttributeDescriptor>();
}

_MTL_INLINE NS::UInteger MTL::VertexAttributeDescriptor::offset() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(offset));
}

_MTL_INLINE void MTL::VertexAttributeDescriptor::setBufferIndex(NS::UInteger bufferIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBufferIndex_), bufferIndex);
}

_MTL_INLINE void MTL::VertexAttributeDescriptor::setFormat(MTL::VertexFormat format)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFormat_), format);
}

_MTL_INLINE void MTL::VertexAttributeDescriptor::setOffset(NS::UInteger offset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setOffset_), offset);
}

_MTL_INLINE MTL::VertexAttributeDescriptorArray* MTL::VertexAttributeDescriptorArray::alloc()
{
    return NS::Object::alloc<MTL::VertexAttributeDescriptorArray>(_MTL_PRIVATE_CLS(MTLVertexAttributeDescriptorArray));
}

_MTL_INLINE MTL::VertexAttributeDescriptorArray* MTL::VertexAttributeDescriptorArray::init()
{
    return NS::Object::init<MTL::VertexAttributeDescriptorArray>();
}

_MTL_INLINE MTL::VertexAttributeDescriptor* MTL::VertexAttributeDescriptorArray::object(NS::UInteger index)
{
    return Object::sendMessage<MTL::VertexAttributeDescriptor*>(this, _MTL_PRIVATE_SEL(objectAtIndexedSubscript_), index);
}

_MTL_INLINE void MTL::VertexAttributeDescriptorArray::setObject(const MTL::VertexAttributeDescriptor* attributeDesc, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObject_atIndexedSubscript_), attributeDesc, index);
}

_MTL_INLINE MTL::VertexDescriptor* MTL::VertexDescriptor::alloc()
{
    return NS::Object::alloc<MTL::VertexDescriptor>(_MTL_PRIVATE_CLS(MTLVertexDescriptor));
}

_MTL_INLINE MTL::VertexAttributeDescriptorArray* MTL::VertexDescriptor::attributes() const
{
    return Object::sendMessage<MTL::VertexAttributeDescriptorArray*>(this, _MTL_PRIVATE_SEL(attributes));
}

_MTL_INLINE MTL::VertexDescriptor* MTL::VertexDescriptor::init()
{
    return NS::Object::init<MTL::VertexDescriptor>();
}

_MTL_INLINE MTL::VertexBufferLayoutDescriptorArray* MTL::VertexDescriptor::layouts() const
{
    return Object::sendMessage<MTL::VertexBufferLayoutDescriptorArray*>(this, _MTL_PRIVATE_SEL(layouts));
}

_MTL_INLINE void MTL::VertexDescriptor::reset()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(reset));
}

_MTL_INLINE MTL::VertexDescriptor* MTL::VertexDescriptor::vertexDescriptor()
{
    return Object::sendMessage<MTL::VertexDescriptor*>(_MTL_PRIVATE_CLS(MTLVertexDescriptor), _MTL_PRIVATE_SEL(vertexDescriptor));
}

#pragma once

namespace MTL
{
class FunctionHandle;
class VisibleFunctionTableDescriptor;

class VisibleFunctionTableDescriptor : public NS::Copying<VisibleFunctionTableDescriptor>
{
public:
    static VisibleFunctionTableDescriptor* alloc();

    NS::UInteger                           functionCount() const;

    VisibleFunctionTableDescriptor*        init();

    void                                   setFunctionCount(NS::UInteger functionCount);

    static VisibleFunctionTableDescriptor* visibleFunctionTableDescriptor();
};
class VisibleFunctionTable : public NS::Referencing<VisibleFunctionTable, Resource>
{
public:
    ResourceID gpuResourceID() const;

    void       setFunction(const MTL::FunctionHandle* function, NS::UInteger index);
    void       setFunctions(const MTL::FunctionHandle* const functions[], NS::Range range);
};

}
_MTL_INLINE MTL::VisibleFunctionTableDescriptor* MTL::VisibleFunctionTableDescriptor::alloc()
{
    return NS::Object::alloc<MTL::VisibleFunctionTableDescriptor>(_MTL_PRIVATE_CLS(MTLVisibleFunctionTableDescriptor));
}

_MTL_INLINE NS::UInteger MTL::VisibleFunctionTableDescriptor::functionCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(functionCount));
}

_MTL_INLINE MTL::VisibleFunctionTableDescriptor* MTL::VisibleFunctionTableDescriptor::init()
{
    return NS::Object::init<MTL::VisibleFunctionTableDescriptor>();
}

_MTL_INLINE void MTL::VisibleFunctionTableDescriptor::setFunctionCount(NS::UInteger functionCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFunctionCount_), functionCount);
}

_MTL_INLINE MTL::VisibleFunctionTableDescriptor* MTL::VisibleFunctionTableDescriptor::visibleFunctionTableDescriptor()
{
    return Object::sendMessage<MTL::VisibleFunctionTableDescriptor*>(_MTL_PRIVATE_CLS(MTLVisibleFunctionTableDescriptor), _MTL_PRIVATE_SEL(visibleFunctionTableDescriptor));
}

_MTL_INLINE MTL::ResourceID MTL::VisibleFunctionTable::gpuResourceID() const
{
    return Object::sendMessage<MTL::ResourceID>(this, _MTL_PRIVATE_SEL(gpuResourceID));
}

_MTL_INLINE void MTL::VisibleFunctionTable::setFunction(const MTL::FunctionHandle* function, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFunction_atIndex_), function, index);
}

_MTL_INLINE void MTL::VisibleFunctionTable::setFunctions(const MTL::FunctionHandle* const functions[], NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFunctions_withRange_), functions, range);
}

#define METALCPP_VERSION_MAJOR 370
#define METALCPP_VERSION_MINOR 63
#define METALCPP_VERSION_PATCH 1

#define METALCPP_SUPPORTS_VERSION(major, minor, patch) \
    ((major < METALCPP_VERSION_MAJOR) || \
    (major == METALCPP_VERSION_MAJOR && minor < METALCPP_VERSION_MINOR) || \
    (major == METALCPP_VERSION_MAJOR && minor == METALCPP_VERSION_MINOR && patch <= METALCPP_VERSION_PATCH))

#pragma once

namespace MTL
{
class Device;
class ResourceViewPool;
class ResourceViewPoolDescriptor;

class ResourceViewPoolDescriptor : public NS::Copying<ResourceViewPoolDescriptor>
{
public:
    static ResourceViewPoolDescriptor* alloc();

    ResourceViewPoolDescriptor*        init();

    NS::String*                        label() const;

    NS::UInteger                       resourceViewCount() const;

    void                               setLabel(const NS::String* label);

    void                               setResourceViewCount(NS::UInteger resourceViewCount);
};
class ResourceViewPool : public NS::Referencing<ResourceViewPool>
{
public:
    ResourceID   baseResourceID() const;

    ResourceID   copyResourceViewsFromPool(const MTL::ResourceViewPool* sourcePool, NS::Range sourceRange, NS::UInteger destinationIndex);

    Device*      device() const;

    NS::String*  label() const;

    NS::UInteger resourceViewCount() const;
};

}
_MTL_INLINE MTL::ResourceViewPoolDescriptor* MTL::ResourceViewPoolDescriptor::alloc()
{
    return NS::Object::alloc<MTL::ResourceViewPoolDescriptor>(_MTL_PRIVATE_CLS(MTLResourceViewPoolDescriptor));
}

_MTL_INLINE MTL::ResourceViewPoolDescriptor* MTL::ResourceViewPoolDescriptor::init()
{
    return NS::Object::init<MTL::ResourceViewPoolDescriptor>();
}

_MTL_INLINE NS::String* MTL::ResourceViewPoolDescriptor::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE NS::UInteger MTL::ResourceViewPoolDescriptor::resourceViewCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(resourceViewCount));
}

_MTL_INLINE void MTL::ResourceViewPoolDescriptor::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE void MTL::ResourceViewPoolDescriptor::setResourceViewCount(NS::UInteger resourceViewCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setResourceViewCount_), resourceViewCount);
}

_MTL_INLINE MTL::ResourceID MTL::ResourceViewPool::baseResourceID() const
{
    return Object::sendMessage<MTL::ResourceID>(this, _MTL_PRIVATE_SEL(baseResourceID));
}

_MTL_INLINE MTL::ResourceID MTL::ResourceViewPool::copyResourceViewsFromPool(const MTL::ResourceViewPool* sourcePool, NS::Range sourceRange, NS::UInteger destinationIndex)
{
    return Object::sendMessage<MTL::ResourceID>(this, _MTL_PRIVATE_SEL(copyResourceViewsFromPool_sourceRange_destinationIndex_), sourcePool, sourceRange, destinationIndex);
}

_MTL_INLINE MTL::Device* MTL::ResourceViewPool::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE NS::String* MTL::ResourceViewPool::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE NS::UInteger MTL::ResourceViewPool::resourceViewCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(resourceViewCount));
}

#pragma once

namespace MTL
{
class Buffer;
class Texture;
class TextureDescriptor;
class TextureViewDescriptor;

class TextureViewPool : public NS::Referencing<TextureViewPool, ResourceViewPool>
{
public:
    ResourceID setTextureView(const MTL::Texture* texture, NS::UInteger index);
    ResourceID setTextureView(const MTL::Texture* texture, const MTL::TextureViewDescriptor* descriptor, NS::UInteger index);
    ResourceID setTextureViewFromBuffer(const MTL::Buffer* buffer, const MTL::TextureDescriptor* descriptor, NS::UInteger offset, NS::UInteger bytesPerRow, NS::UInteger index);
};

}
_MTL_INLINE MTL::ResourceID MTL::TextureViewPool::setTextureView(const MTL::Texture* texture, NS::UInteger index)
{
    return Object::sendMessage<MTL::ResourceID>(this, _MTL_PRIVATE_SEL(setTextureView_atIndex_), texture, index);
}

_MTL_INLINE MTL::ResourceID MTL::TextureViewPool::setTextureView(const MTL::Texture* texture, const MTL::TextureViewDescriptor* descriptor, NS::UInteger index)
{
    return Object::sendMessage<MTL::ResourceID>(this, _MTL_PRIVATE_SEL(setTextureView_descriptor_atIndex_), texture, descriptor, index);
}

_MTL_INLINE MTL::ResourceID MTL::TextureViewPool::setTextureViewFromBuffer(const MTL::Buffer* buffer, const MTL::TextureDescriptor* descriptor, NS::UInteger offset, NS::UInteger bytesPerRow, NS::UInteger index)
{
    return Object::sendMessage<MTL::ResourceID>(this, _MTL_PRIVATE_SEL(setTextureViewFromBuffer_descriptor_offset_bytesPerRow_atIndex_), buffer, descriptor, offset, bytesPerRow, index);
}

#pragma once

namespace MTL
{
class Device;
}

namespace MTL4
{
class ArgumentTableDescriptor : public NS::Copying<ArgumentTableDescriptor>
{
public:
    static ArgumentTableDescriptor* alloc();

    ArgumentTableDescriptor*        init();
    bool                            initializeBindings() const;

    NS::String*                     label() const;

    NS::UInteger                    maxBufferBindCount() const;

    NS::UInteger                    maxSamplerStateBindCount() const;

    NS::UInteger                    maxTextureBindCount() const;

    void                            setInitializeBindings(bool initializeBindings);

    void                            setLabel(const NS::String* label);

    void                            setMaxBufferBindCount(NS::UInteger maxBufferBindCount);

    void                            setMaxSamplerStateBindCount(NS::UInteger maxSamplerStateBindCount);

    void                            setMaxTextureBindCount(NS::UInteger maxTextureBindCount);

    void                            setSupportAttributeStrides(bool supportAttributeStrides);
    bool                            supportAttributeStrides() const;
};
class ArgumentTable : public NS::Referencing<ArgumentTable>
{
public:
    MTL::Device* device() const;

    NS::String*  label() const;

    void         setAddress(MTL::GPUAddress gpuAddress, NS::UInteger bindingIndex);
    void         setAddress(MTL::GPUAddress gpuAddress, NS::UInteger stride, NS::UInteger bindingIndex);

    void         setResource(MTL::ResourceID resourceID, NS::UInteger bindingIndex);

    void         setSamplerState(MTL::ResourceID resourceID, NS::UInteger bindingIndex);

    void         setTexture(MTL::ResourceID resourceID, NS::UInteger bindingIndex);
};

}
_MTL_INLINE MTL4::ArgumentTableDescriptor* MTL4::ArgumentTableDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::ArgumentTableDescriptor>(_MTL_PRIVATE_CLS(MTL4ArgumentTableDescriptor));
}

_MTL_INLINE MTL4::ArgumentTableDescriptor* MTL4::ArgumentTableDescriptor::init()
{
    return NS::Object::init<MTL4::ArgumentTableDescriptor>();
}

_MTL_INLINE bool MTL4::ArgumentTableDescriptor::initializeBindings() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(initializeBindings));
}

_MTL_INLINE NS::String* MTL4::ArgumentTableDescriptor::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE NS::UInteger MTL4::ArgumentTableDescriptor::maxBufferBindCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxBufferBindCount));
}

_MTL_INLINE NS::UInteger MTL4::ArgumentTableDescriptor::maxSamplerStateBindCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxSamplerStateBindCount));
}

_MTL_INLINE NS::UInteger MTL4::ArgumentTableDescriptor::maxTextureBindCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxTextureBindCount));
}

_MTL_INLINE void MTL4::ArgumentTableDescriptor::setInitializeBindings(bool initializeBindings)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInitializeBindings_), initializeBindings);
}

_MTL_INLINE void MTL4::ArgumentTableDescriptor::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE void MTL4::ArgumentTableDescriptor::setMaxBufferBindCount(NS::UInteger maxBufferBindCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxBufferBindCount_), maxBufferBindCount);
}

_MTL_INLINE void MTL4::ArgumentTableDescriptor::setMaxSamplerStateBindCount(NS::UInteger maxSamplerStateBindCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxSamplerStateBindCount_), maxSamplerStateBindCount);
}

_MTL_INLINE void MTL4::ArgumentTableDescriptor::setMaxTextureBindCount(NS::UInteger maxTextureBindCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxTextureBindCount_), maxTextureBindCount);
}

_MTL_INLINE void MTL4::ArgumentTableDescriptor::setSupportAttributeStrides(bool supportAttributeStrides)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportAttributeStrides_), supportAttributeStrides);
}

_MTL_INLINE bool MTL4::ArgumentTableDescriptor::supportAttributeStrides() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportAttributeStrides));
}

_MTL_INLINE MTL::Device* MTL4::ArgumentTable::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE NS::String* MTL4::ArgumentTable::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE void MTL4::ArgumentTable::setAddress(MTL::GPUAddress gpuAddress, NS::UInteger bindingIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setAddress_atIndex_), gpuAddress, bindingIndex);
}

_MTL_INLINE void MTL4::ArgumentTable::setAddress(MTL::GPUAddress gpuAddress, NS::UInteger stride, NS::UInteger bindingIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setAddress_attributeStride_atIndex_), gpuAddress, stride, bindingIndex);
}

_MTL_INLINE void MTL4::ArgumentTable::setResource(MTL::ResourceID resourceID, NS::UInteger bindingIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setResource_atBufferIndex_), resourceID, bindingIndex);
}

_MTL_INLINE void MTL4::ArgumentTable::setSamplerState(MTL::ResourceID resourceID, NS::UInteger bindingIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSamplerState_atIndex_), resourceID, bindingIndex);
}

_MTL_INLINE void MTL4::ArgumentTable::setTexture(MTL::ResourceID resourceID, NS::UInteger bindingIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTexture_atIndex_), resourceID, bindingIndex);
}

#pragma once

namespace MTL4
{

class BinaryFunction : public NS::Referencing<BinaryFunction>
{
public:
    MTL::FunctionType functionType() const;

    NS::String*       name() const;
};

}

_MTL_INLINE MTL::FunctionType MTL4::BinaryFunction::functionType() const
{
    return Object::sendMessage<MTL::FunctionType>(this, _MTL_PRIVATE_SEL(functionType));
}

_MTL_INLINE NS::String* MTL4::BinaryFunction::name() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(name));
}

#pragma once

#include <cstdint>

namespace MTL
{
class Device;
}

namespace MTL4
{

class CommandAllocatorDescriptor : public NS::Copying<CommandAllocatorDescriptor>
{
public:
    static CommandAllocatorDescriptor* alloc();

    CommandAllocatorDescriptor*        init();

    NS::String*                        label() const;
    void                               setLabel(const NS::String* label);
};

class CommandAllocator : public NS::Referencing<CommandAllocator>
{
public:
    uint64_t     allocatedSize();

    MTL::Device* device() const;

    NS::String*  label() const;

    void         reset();
};

}

_MTL_INLINE MTL4::CommandAllocatorDescriptor* MTL4::CommandAllocatorDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::CommandAllocatorDescriptor>(_MTL_PRIVATE_CLS(MTL4CommandAllocatorDescriptor));
}

_MTL_INLINE MTL4::CommandAllocatorDescriptor* MTL4::CommandAllocatorDescriptor::init()
{
    return NS::Object::init<MTL4::CommandAllocatorDescriptor>();
}

_MTL_INLINE NS::String* MTL4::CommandAllocatorDescriptor::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE void MTL4::CommandAllocatorDescriptor::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE uint64_t MTL4::CommandAllocator::allocatedSize()
{
    return Object::sendMessage<uint64_t>(this, _MTL_PRIVATE_SEL(allocatedSize));
}

_MTL_INLINE MTL::Device* MTL4::CommandAllocator::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE NS::String* MTL4::CommandAllocator::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE void MTL4::CommandAllocator::reset()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(reset));
}

#pragma once

#pragma once

#pragma once

namespace MTL4
{
class CommandBuffer;
}

namespace MTL
{
class Fence;
}

namespace MTL4
{
_MTL_OPTIONS(NS::UInteger, VisibilityOptions) {
    VisibilityOptionNone = 0,
    VisibilityOptionDevice = 1,
    VisibilityOptionResourceAlias = 1 << 1,
};

class CommandEncoder : public NS::Referencing<CommandEncoder>
{
public:
    void           barrierAfterEncoderStages(MTL::Stages afterEncoderStages, MTL::Stages beforeEncoderStages, MTL4::VisibilityOptions visibilityOptions);

    void           barrierAfterQueueStages(MTL::Stages afterQueueStages, MTL::Stages beforeStages, MTL4::VisibilityOptions visibilityOptions);

    void           barrierAfterStages(MTL::Stages afterStages, MTL::Stages beforeQueueStages, MTL4::VisibilityOptions visibilityOptions);

    CommandBuffer* commandBuffer() const;

    void           endEncoding();

    void           insertDebugSignpost(const NS::String* string);

    NS::String*    label() const;

    void           popDebugGroup();

    void           pushDebugGroup(const NS::String* string);

    void           setLabel(const NS::String* label);

    void           updateFence(const MTL::Fence* fence, MTL::Stages afterEncoderStages);

    void           waitForFence(const MTL::Fence* fence, MTL::Stages beforeEncoderStages);
};

}
_MTL_INLINE void MTL4::CommandEncoder::barrierAfterEncoderStages(MTL::Stages afterEncoderStages, MTL::Stages beforeEncoderStages, MTL4::VisibilityOptions visibilityOptions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(barrierAfterEncoderStages_beforeEncoderStages_visibilityOptions_), afterEncoderStages, beforeEncoderStages, visibilityOptions);
}

_MTL_INLINE void MTL4::CommandEncoder::barrierAfterQueueStages(MTL::Stages afterQueueStages, MTL::Stages beforeStages, MTL4::VisibilityOptions visibilityOptions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(barrierAfterQueueStages_beforeStages_visibilityOptions_), afterQueueStages, beforeStages, visibilityOptions);
}

_MTL_INLINE void MTL4::CommandEncoder::barrierAfterStages(MTL::Stages afterStages, MTL::Stages beforeQueueStages, MTL4::VisibilityOptions visibilityOptions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(barrierAfterStages_beforeQueueStages_visibilityOptions_), afterStages, beforeQueueStages, visibilityOptions);
}

_MTL_INLINE MTL4::CommandBuffer* MTL4::CommandEncoder::commandBuffer() const
{
    return Object::sendMessage<MTL4::CommandBuffer*>(this, _MTL_PRIVATE_SEL(commandBuffer));
}

_MTL_INLINE void MTL4::CommandEncoder::endEncoding()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(endEncoding));
}

_MTL_INLINE void MTL4::CommandEncoder::insertDebugSignpost(const NS::String* string)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(insertDebugSignpost_), string);
}

_MTL_INLINE NS::String* MTL4::CommandEncoder::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE void MTL4::CommandEncoder::popDebugGroup()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(popDebugGroup));
}

_MTL_INLINE void MTL4::CommandEncoder::pushDebugGroup(const NS::String* string)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(pushDebugGroup_), string);
}

_MTL_INLINE void MTL4::CommandEncoder::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE void MTL4::CommandEncoder::updateFence(const MTL::Fence* fence, MTL::Stages afterEncoderStages)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(updateFence_afterEncoderStages_), fence, afterEncoderStages);
}

_MTL_INLINE void MTL4::CommandEncoder::waitForFence(const MTL::Fence* fence, MTL::Stages beforeEncoderStages)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(waitForFence_beforeEncoderStages_), fence, beforeEncoderStages);
}

#include <cstdint>

namespace MTL4
{
class ArgumentTable;
class CounterHeap;
}

namespace MTL
{
class DepthStencilState;
class IndirectCommandBuffer;
class LogicalToPhysicalColorAttachmentMap;
class RenderPipelineState;
struct ScissorRect;
struct VertexAmplificationViewMapping;
struct Viewport;

}
namespace MTL4
{
_MTL_OPTIONS(NS::UInteger, RenderEncoderOptions) {
    RenderEncoderOptionNone = 0,
    RenderEncoderOptionSuspending = 1,
    RenderEncoderOptionResuming = 1 << 1,
};

class RenderCommandEncoder : public NS::Referencing<RenderCommandEncoder, CommandEncoder>
{
public:
    void         dispatchThreadsPerTile(MTL::Size threadsPerTile);

    void         drawIndexedPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger indexCount, MTL::IndexType indexType, MTL::GPUAddress indexBuffer, NS::UInteger indexBufferLength);
    void         drawIndexedPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger indexCount, MTL::IndexType indexType, MTL::GPUAddress indexBuffer, NS::UInteger indexBufferLength, NS::UInteger instanceCount);
    void         drawIndexedPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger indexCount, MTL::IndexType indexType, MTL::GPUAddress indexBuffer, NS::UInteger indexBufferLength, NS::UInteger instanceCount, NS::Integer baseVertex, NS::UInteger baseInstance);
    void         drawIndexedPrimitives(MTL::PrimitiveType primitiveType, MTL::IndexType indexType, MTL::GPUAddress indexBuffer, NS::UInteger indexBufferLength, MTL::GPUAddress indirectBuffer);

    void         drawMeshThreadgroups(MTL::Size threadgroupsPerGrid, MTL::Size threadsPerObjectThreadgroup, MTL::Size threadsPerMeshThreadgroup);
    void         drawMeshThreadgroups(MTL::GPUAddress indirectBuffer, MTL::Size threadsPerObjectThreadgroup, MTL::Size threadsPerMeshThreadgroup);

    void         drawMeshThreads(MTL::Size threadsPerGrid, MTL::Size threadsPerObjectThreadgroup, MTL::Size threadsPerMeshThreadgroup);

    void         drawPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger vertexStart, NS::UInteger vertexCount);
    void         drawPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger vertexStart, NS::UInteger vertexCount, NS::UInteger instanceCount);
    void         drawPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger vertexStart, NS::UInteger vertexCount, NS::UInteger instanceCount, NS::UInteger baseInstance);
    void         drawPrimitives(MTL::PrimitiveType primitiveType, MTL::GPUAddress indirectBuffer);

    void         executeCommandsInBuffer(const MTL::IndirectCommandBuffer* indirectCommandBuffer, NS::Range executionRange);
    void         executeCommandsInBuffer(const MTL::IndirectCommandBuffer* indirectCommandBuffer, MTL::GPUAddress indirectRangeBuffer);

    void         setArgumentTable(const MTL4::ArgumentTable* argumentTable, MTL::RenderStages stages);

    void         setBlendColor(float red, float green, float blue, float alpha);

    void         setColorAttachmentMap(const MTL::LogicalToPhysicalColorAttachmentMap* mapping);

    void         setColorStoreAction(MTL::StoreAction storeAction, NS::UInteger colorAttachmentIndex);

    void         setCullMode(MTL::CullMode cullMode);

    void         setDepthBias(float depthBias, float slopeScale, float clamp);

    void         setDepthClipMode(MTL::DepthClipMode depthClipMode);

    void         setDepthStencilState(const MTL::DepthStencilState* depthStencilState);

    void         setDepthStoreAction(MTL::StoreAction storeAction);

    void         setDepthTestBounds(float minBound, float maxBound);

    void         setFrontFacingWinding(MTL::Winding frontFacingWinding);

    void         setObjectThreadgroupMemoryLength(NS::UInteger length, NS::UInteger index);

    void         setRenderPipelineState(const MTL::RenderPipelineState* pipelineState);

    void         setScissorRect(MTL::ScissorRect rect);
    void         setScissorRects(const MTL::ScissorRect* scissorRects, NS::UInteger count);

    void         setStencilReferenceValue(uint32_t referenceValue);
    void         setStencilReferenceValues(uint32_t frontReferenceValue, uint32_t backReferenceValue);

    void         setStencilStoreAction(MTL::StoreAction storeAction);

    void         setThreadgroupMemoryLength(NS::UInteger length, NS::UInteger offset, NS::UInteger index);

    void         setTriangleFillMode(MTL::TriangleFillMode fillMode);

    void         setVertexAmplificationCount(NS::UInteger count, const MTL::VertexAmplificationViewMapping* viewMappings);

    void         setViewport(MTL::Viewport viewport);
    void         setViewports(const MTL::Viewport* viewports, NS::UInteger count);

    void         setVisibilityResultMode(MTL::VisibilityResultMode mode, NS::UInteger offset);

    NS::UInteger tileHeight() const;

    NS::UInteger tileWidth() const;

    void         writeTimestamp(MTL4::TimestampGranularity granularity, MTL::RenderStages stage, const MTL4::CounterHeap* counterHeap, NS::UInteger index);
};

}
_MTL_INLINE void MTL4::RenderCommandEncoder::dispatchThreadsPerTile(MTL::Size threadsPerTile)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(dispatchThreadsPerTile_), threadsPerTile);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::drawIndexedPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger indexCount, MTL::IndexType indexType, MTL::GPUAddress indexBuffer, NS::UInteger indexBufferLength)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferLength_), primitiveType, indexCount, indexType, indexBuffer, indexBufferLength);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::drawIndexedPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger indexCount, MTL::IndexType indexType, MTL::GPUAddress indexBuffer, NS::UInteger indexBufferLength, NS::UInteger instanceCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferLength_instanceCount_), primitiveType, indexCount, indexType, indexBuffer, indexBufferLength, instanceCount);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::drawIndexedPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger indexCount, MTL::IndexType indexType, MTL::GPUAddress indexBuffer, NS::UInteger indexBufferLength, NS::UInteger instanceCount, NS::Integer baseVertex, NS::UInteger baseInstance)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferLength_instanceCount_baseVertex_baseInstance_), primitiveType, indexCount, indexType, indexBuffer, indexBufferLength, instanceCount, baseVertex, baseInstance);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::drawIndexedPrimitives(MTL::PrimitiveType primitiveType, MTL::IndexType indexType, MTL::GPUAddress indexBuffer, NS::UInteger indexBufferLength, MTL::GPUAddress indirectBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawIndexedPrimitives_indexType_indexBuffer_indexBufferLength_indirectBuffer_), primitiveType, indexType, indexBuffer, indexBufferLength, indirectBuffer);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::drawMeshThreadgroups(MTL::Size threadgroupsPerGrid, MTL::Size threadsPerObjectThreadgroup, MTL::Size threadsPerMeshThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawMeshThreadgroups_threadsPerObjectThreadgroup_threadsPerMeshThreadgroup_), threadgroupsPerGrid, threadsPerObjectThreadgroup, threadsPerMeshThreadgroup);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::drawMeshThreadgroups(MTL::GPUAddress indirectBuffer, MTL::Size threadsPerObjectThreadgroup, MTL::Size threadsPerMeshThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawMeshThreadgroupsWithIndirectBuffer_threadsPerObjectThreadgroup_threadsPerMeshThreadgroup_), indirectBuffer, threadsPerObjectThreadgroup, threadsPerMeshThreadgroup);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::drawMeshThreads(MTL::Size threadsPerGrid, MTL::Size threadsPerObjectThreadgroup, MTL::Size threadsPerMeshThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawMeshThreads_threadsPerObjectThreadgroup_threadsPerMeshThreadgroup_), threadsPerGrid, threadsPerObjectThreadgroup, threadsPerMeshThreadgroup);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::drawPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger vertexStart, NS::UInteger vertexCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawPrimitives_vertexStart_vertexCount_), primitiveType, vertexStart, vertexCount);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::drawPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger vertexStart, NS::UInteger vertexCount, NS::UInteger instanceCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawPrimitives_vertexStart_vertexCount_instanceCount_), primitiveType, vertexStart, vertexCount, instanceCount);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::drawPrimitives(MTL::PrimitiveType primitiveType, NS::UInteger vertexStart, NS::UInteger vertexCount, NS::UInteger instanceCount, NS::UInteger baseInstance)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawPrimitives_vertexStart_vertexCount_instanceCount_baseInstance_), primitiveType, vertexStart, vertexCount, instanceCount, baseInstance);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::drawPrimitives(MTL::PrimitiveType primitiveType, MTL::GPUAddress indirectBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(drawPrimitives_indirectBuffer_), primitiveType, indirectBuffer);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::executeCommandsInBuffer(const MTL::IndirectCommandBuffer* indirectCommandBuffer, NS::Range executionRange)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(executeCommandsInBuffer_withRange_), indirectCommandBuffer, executionRange);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::executeCommandsInBuffer(const MTL::IndirectCommandBuffer* indirectCommandBuffer, MTL::GPUAddress indirectRangeBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(executeCommandsInBuffer_indirectBuffer_), indirectCommandBuffer, indirectRangeBuffer);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setArgumentTable(const MTL4::ArgumentTable* argumentTable, MTL::RenderStages stages)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setArgumentTable_atStages_), argumentTable, stages);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setBlendColor(float red, float green, float blue, float alpha)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBlendColorRed_green_blue_alpha_), red, green, blue, alpha);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setColorAttachmentMap(const MTL::LogicalToPhysicalColorAttachmentMap* mapping)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setColorAttachmentMap_), mapping);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setColorStoreAction(MTL::StoreAction storeAction, NS::UInteger colorAttachmentIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setColorStoreAction_atIndex_), storeAction, colorAttachmentIndex);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setCullMode(MTL::CullMode cullMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setCullMode_), cullMode);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setDepthBias(float depthBias, float slopeScale, float clamp)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthBias_slopeScale_clamp_), depthBias, slopeScale, clamp);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setDepthClipMode(MTL::DepthClipMode depthClipMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthClipMode_), depthClipMode);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setDepthStencilState(const MTL::DepthStencilState* depthStencilState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthStencilState_), depthStencilState);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setDepthStoreAction(MTL::StoreAction storeAction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthStoreAction_), storeAction);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setDepthTestBounds(float minBound, float maxBound)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthTestMinBound_maxBound_), minBound, maxBound);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setFrontFacingWinding(MTL::Winding frontFacingWinding)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFrontFacingWinding_), frontFacingWinding);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setObjectThreadgroupMemoryLength(NS::UInteger length, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectThreadgroupMemoryLength_atIndex_), length, index);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setRenderPipelineState(const MTL::RenderPipelineState* pipelineState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRenderPipelineState_), pipelineState);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setScissorRect(MTL::ScissorRect rect)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setScissorRect_), rect);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setScissorRects(const MTL::ScissorRect* scissorRects, NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setScissorRects_count_), scissorRects, count);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setStencilReferenceValue(uint32_t referenceValue)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStencilReferenceValue_), referenceValue);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setStencilReferenceValues(uint32_t frontReferenceValue, uint32_t backReferenceValue)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStencilFrontReferenceValue_backReferenceValue_), frontReferenceValue, backReferenceValue);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setStencilStoreAction(MTL::StoreAction storeAction)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStencilStoreAction_), storeAction);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setThreadgroupMemoryLength(NS::UInteger length, NS::UInteger offset, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setThreadgroupMemoryLength_offset_atIndex_), length, offset, index);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setTriangleFillMode(MTL::TriangleFillMode fillMode)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTriangleFillMode_), fillMode);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setVertexAmplificationCount(NS::UInteger count, const MTL::VertexAmplificationViewMapping* viewMappings)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexAmplificationCount_viewMappings_), count, viewMappings);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setViewport(MTL::Viewport viewport)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setViewport_), viewport);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setViewports(const MTL::Viewport* viewports, NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setViewports_count_), viewports, count);
}

_MTL_INLINE void MTL4::RenderCommandEncoder::setVisibilityResultMode(MTL::VisibilityResultMode mode, NS::UInteger offset)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVisibilityResultMode_offset_), mode, offset);
}

_MTL_INLINE NS::UInteger MTL4::RenderCommandEncoder::tileHeight() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(tileHeight));
}

_MTL_INLINE NS::UInteger MTL4::RenderCommandEncoder::tileWidth() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(tileWidth));
}

_MTL_INLINE void MTL4::RenderCommandEncoder::writeTimestamp(MTL4::TimestampGranularity granularity, MTL::RenderStages stage, const MTL4::CounterHeap* counterHeap, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(writeTimestampWithGranularity_afterStage_intoHeap_atIndex_), granularity, stage, counterHeap, index);
}

namespace MTL4
{
class CommandAllocator;
class CommandBufferOptions;
class ComputeCommandEncoder;
class CounterHeap;
class MachineLearningCommandEncoder;
class RenderCommandEncoder;
class RenderPassDescriptor;
}

namespace MTL
{
class Device;
class Fence;
class LogState;
class ResidencySet;
}

namespace MTL4
{
class CommandBufferOptions : public NS::Copying<CommandBufferOptions>
{
public:
    static CommandBufferOptions* alloc();

    CommandBufferOptions*        init();

    MTL::LogState*               logState() const;
    void                         setLogState(const MTL::LogState* logState);
};
class CommandBuffer : public NS::Referencing<CommandBuffer>
{
public:
    void                           beginCommandBuffer(const MTL4::CommandAllocator* allocator);
    void                           beginCommandBuffer(const MTL4::CommandAllocator* allocator, const MTL4::CommandBufferOptions* options);

    ComputeCommandEncoder*         computeCommandEncoder();

    MTL::Device*                   device() const;

    void                           endCommandBuffer();

    NS::String*                    label() const;

    MachineLearningCommandEncoder* machineLearningCommandEncoder();

    void                           popDebugGroup();

    void                           pushDebugGroup(const NS::String* string);

    RenderCommandEncoder*          renderCommandEncoder(const MTL4::RenderPassDescriptor* descriptor);
    RenderCommandEncoder*          renderCommandEncoder(const MTL4::RenderPassDescriptor* descriptor, MTL4::RenderEncoderOptions options);

    void                           resolveCounterHeap(const MTL4::CounterHeap* counterHeap, NS::Range range, const MTL4::BufferRange bufferRange, const MTL::Fence* fenceToWait, const MTL::Fence* fenceToUpdate);

    void                           setLabel(const NS::String* label);

    void                           useResidencySet(const MTL::ResidencySet* residencySet);
    void                           useResidencySets(const MTL::ResidencySet* const residencySets[], NS::UInteger count);

    void                           writeTimestampIntoHeap(const MTL4::CounterHeap* counterHeap, NS::UInteger index);
};

}
_MTL_INLINE MTL4::CommandBufferOptions* MTL4::CommandBufferOptions::alloc()
{
    return NS::Object::alloc<MTL4::CommandBufferOptions>(_MTL_PRIVATE_CLS(MTL4CommandBufferOptions));
}

_MTL_INLINE MTL4::CommandBufferOptions* MTL4::CommandBufferOptions::init()
{
    return NS::Object::init<MTL4::CommandBufferOptions>();
}

_MTL_INLINE MTL::LogState* MTL4::CommandBufferOptions::logState() const
{
    return Object::sendMessage<MTL::LogState*>(this, _MTL_PRIVATE_SEL(logState));
}

_MTL_INLINE void MTL4::CommandBufferOptions::setLogState(const MTL::LogState* logState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLogState_), logState);
}

_MTL_INLINE void MTL4::CommandBuffer::beginCommandBuffer(const MTL4::CommandAllocator* allocator)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(beginCommandBufferWithAllocator_), allocator);
}

_MTL_INLINE void MTL4::CommandBuffer::beginCommandBuffer(const MTL4::CommandAllocator* allocator, const MTL4::CommandBufferOptions* options)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(beginCommandBufferWithAllocator_options_), allocator, options);
}

_MTL_INLINE MTL4::ComputeCommandEncoder* MTL4::CommandBuffer::computeCommandEncoder()
{
    return Object::sendMessage<MTL4::ComputeCommandEncoder*>(this, _MTL_PRIVATE_SEL(computeCommandEncoder));
}

_MTL_INLINE MTL::Device* MTL4::CommandBuffer::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE void MTL4::CommandBuffer::endCommandBuffer()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(endCommandBuffer));
}

_MTL_INLINE NS::String* MTL4::CommandBuffer::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE MTL4::MachineLearningCommandEncoder* MTL4::CommandBuffer::machineLearningCommandEncoder()
{
    return Object::sendMessage<MTL4::MachineLearningCommandEncoder*>(this, _MTL_PRIVATE_SEL(machineLearningCommandEncoder));
}

_MTL_INLINE void MTL4::CommandBuffer::popDebugGroup()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(popDebugGroup));
}

_MTL_INLINE void MTL4::CommandBuffer::pushDebugGroup(const NS::String* string)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(pushDebugGroup_), string);
}

_MTL_INLINE MTL4::RenderCommandEncoder* MTL4::CommandBuffer::renderCommandEncoder(const MTL4::RenderPassDescriptor* descriptor)
{
    return Object::sendMessage<MTL4::RenderCommandEncoder*>(this, _MTL_PRIVATE_SEL(renderCommandEncoderWithDescriptor_), descriptor);
}

_MTL_INLINE MTL4::RenderCommandEncoder* MTL4::CommandBuffer::renderCommandEncoder(const MTL4::RenderPassDescriptor* descriptor, MTL4::RenderEncoderOptions options)
{
    return Object::sendMessage<MTL4::RenderCommandEncoder*>(this, _MTL_PRIVATE_SEL(renderCommandEncoderWithDescriptor_options_), descriptor, options);
}

_MTL_INLINE void MTL4::CommandBuffer::resolveCounterHeap(const MTL4::CounterHeap* counterHeap, NS::Range range, const MTL4::BufferRange bufferRange, const MTL::Fence* fenceToWait, const MTL::Fence* fenceToUpdate)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(resolveCounterHeap_withRange_intoBuffer_waitFence_updateFence_), counterHeap, range, bufferRange, fenceToWait, fenceToUpdate);
}

_MTL_INLINE void MTL4::CommandBuffer::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE void MTL4::CommandBuffer::useResidencySet(const MTL::ResidencySet* residencySet)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useResidencySet_), residencySet);
}

_MTL_INLINE void MTL4::CommandBuffer::useResidencySets(const MTL::ResidencySet* const residencySets[], NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(useResidencySets_count_), residencySets, count);
}

_MTL_INLINE void MTL4::CommandBuffer::writeTimestampIntoHeap(const MTL4::CounterHeap* counterHeap, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(writeTimestampIntoHeap_atIndex_), counterHeap, index);
}

#pragma once

#pragma once

#include <CoreFoundation/CoreFoundation.h>

#include <functional>

namespace MTL4
{
class CommitFeedback;

using CommitFeedbackHandler = void (^)(MTL4::CommitFeedback*);
using CommitFeedbackHandlerFunction = std::function<void(MTL4::CommitFeedback*)>;

class CommitFeedback : public NS::Referencing<CommitFeedback>
{
public:
    CFTimeInterval GPUEndTime() const;

    CFTimeInterval GPUStartTime() const;

    NS::Error*     error() const;
};

}
_MTL_INLINE CFTimeInterval MTL4::CommitFeedback::GPUEndTime() const
{
    return Object::sendMessage<CFTimeInterval>(this, _MTL_PRIVATE_SEL(GPUEndTime));
}

_MTL_INLINE CFTimeInterval MTL4::CommitFeedback::GPUStartTime() const
{
    return Object::sendMessage<CFTimeInterval>(this, _MTL_PRIVATE_SEL(GPUStartTime));
}

_MTL_INLINE NS::Error* MTL4::CommitFeedback::error() const
{
    return Object::sendMessage<NS::Error*>(this, _MTL_PRIVATE_SEL(error));
}

#include <cstdint>
#include <dispatch/dispatch.h>

namespace MTL
{
class Buffer;
class Device;
class Drawable;
class Event;
class Heap;
class ResidencySet;
class Texture;
}

namespace MTL4
{
class CommandBuffer;
class CommandQueueDescriptor;
class CommitOptions;
struct CopySparseBufferMappingOperation;
struct CopySparseTextureMappingOperation;
struct UpdateSparseBufferMappingOperation;
struct UpdateSparseTextureMappingOperation;
_MTL_ENUM(NS::Integer, CommandQueueError) {
    CommandQueueErrorNone = 0,
    CommandQueueErrorTimeout = 1,
    CommandQueueErrorNotPermitted = 2,
    CommandQueueErrorOutOfMemory = 3,
    CommandQueueErrorDeviceRemoved = 4,
    CommandQueueErrorAccessRevoked = 5,
    CommandQueueErrorInternal = 6,
};

struct UpdateSparseTextureMappingOperation
{
    MTL::SparseTextureMappingMode mode;
    MTL::Region                   textureRegion;
    NS::UInteger                  textureLevel;
    NS::UInteger                  textureSlice;
    NS::UInteger                  heapOffset;
} _MTL_PACKED;

struct CopySparseTextureMappingOperation
{
    MTL::Region  sourceRegion;
    NS::UInteger sourceLevel;
    NS::UInteger sourceSlice;
    MTL::Origin  destinationOrigin;
    NS::UInteger destinationLevel;
    NS::UInteger destinationSlice;
} _MTL_PACKED;

struct UpdateSparseBufferMappingOperation
{
    MTL::SparseTextureMappingMode mode;
    NS::Range                     bufferRange;
    NS::UInteger                  heapOffset;
} _MTL_PACKED;

struct CopySparseBufferMappingOperation
{
    NS::Range    sourceRange;
    NS::UInteger destinationOffset;
} _MTL_PACKED;

class CommitOptions : public NS::Referencing<CommitOptions>
{
public:
    void                  addFeedbackHandler(const MTL4::CommitFeedbackHandler block);
    void                  addFeedbackHandler(const MTL4::CommitFeedbackHandlerFunction& function);

    static CommitOptions* alloc();

    CommitOptions*        init();
};
class CommandQueueDescriptor : public NS::Copying<CommandQueueDescriptor>
{
public:
    static CommandQueueDescriptor* alloc();

    dispatch_queue_t               feedbackQueue() const;

    CommandQueueDescriptor*        init();

    NS::String*                    label() const;

    void                           setFeedbackQueue(const dispatch_queue_t feedbackQueue);

    void                           setLabel(const NS::String* label);
};
class CommandQueue : public NS::Referencing<CommandQueue>
{
public:
    void         addResidencySet(const MTL::ResidencySet* residencySet);
    void         addResidencySets(const MTL::ResidencySet* const residencySets[], NS::UInteger count);

    void         commit(const MTL4::CommandBuffer* const commandBuffers[], NS::UInteger count);
    void         commit(const MTL4::CommandBuffer* const commandBuffers[], NS::UInteger count, const MTL4::CommitOptions* options);

    void         copyBufferMappingsFromBuffer(const MTL::Buffer* sourceBuffer, const MTL::Buffer* destinationBuffer, const MTL4::CopySparseBufferMappingOperation* operations, NS::UInteger count);

    void         copyTextureMappingsFromTexture(const MTL::Texture* sourceTexture, const MTL::Texture* destinationTexture, const MTL4::CopySparseTextureMappingOperation* operations, NS::UInteger count);

    MTL::Device* device() const;

    NS::String*  label() const;

    void         removeResidencySet(const MTL::ResidencySet* residencySet);
    void         removeResidencySets(const MTL::ResidencySet* const residencySets[], NS::UInteger count);

    void         signalDrawable(const MTL::Drawable* drawable);

    void         signalEvent(const MTL::Event* event, uint64_t value);

    void         updateBufferMappings(const MTL::Buffer* buffer, const MTL::Heap* heap, const MTL4::UpdateSparseBufferMappingOperation* operations, NS::UInteger count);

    void         updateTextureMappings(const MTL::Texture* texture, const MTL::Heap* heap, const MTL4::UpdateSparseTextureMappingOperation* operations, NS::UInteger count);

    void         wait(const MTL::Event* event, uint64_t value);
    void         wait(const MTL::Drawable* drawable);
};

}

_MTL_INLINE void MTL4::CommitOptions::addFeedbackHandler(const MTL4::CommitFeedbackHandler block)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(addFeedbackHandler_), block);
}

_MTL_INLINE void MTL4::CommitOptions::addFeedbackHandler(const MTL4::CommitFeedbackHandlerFunction& function)
{
    __block MTL4::CommitFeedbackHandlerFunction blockFunction = function;
    addFeedbackHandler(^(MTL4::CommitFeedback* pFeedback) { blockFunction(pFeedback); });
}

_MTL_INLINE MTL4::CommitOptions* MTL4::CommitOptions::alloc()
{
    return NS::Object::alloc<MTL4::CommitOptions>(_MTL_PRIVATE_CLS(MTL4CommitOptions));
}

_MTL_INLINE MTL4::CommitOptions* MTL4::CommitOptions::init()
{
    return NS::Object::init<MTL4::CommitOptions>();
}

_MTL_INLINE MTL4::CommandQueueDescriptor* MTL4::CommandQueueDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::CommandQueueDescriptor>(_MTL_PRIVATE_CLS(MTL4CommandQueueDescriptor));
}

_MTL_INLINE dispatch_queue_t MTL4::CommandQueueDescriptor::feedbackQueue() const
{
    return Object::sendMessage<dispatch_queue_t>(this, _MTL_PRIVATE_SEL(feedbackQueue));
}

_MTL_INLINE MTL4::CommandQueueDescriptor* MTL4::CommandQueueDescriptor::init()
{
    return NS::Object::init<MTL4::CommandQueueDescriptor>();
}

_MTL_INLINE NS::String* MTL4::CommandQueueDescriptor::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE void MTL4::CommandQueueDescriptor::setFeedbackQueue(const dispatch_queue_t feedbackQueue)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFeedbackQueue_), feedbackQueue);
}

_MTL_INLINE void MTL4::CommandQueueDescriptor::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE void MTL4::CommandQueue::addResidencySet(const MTL::ResidencySet* residencySet)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(addResidencySet_), residencySet);
}

_MTL_INLINE void MTL4::CommandQueue::addResidencySets(const MTL::ResidencySet* const residencySets[], NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(addResidencySets_count_), residencySets, count);
}

_MTL_INLINE void MTL4::CommandQueue::commit(const MTL4::CommandBuffer* const commandBuffers[], NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(commit_count_), commandBuffers, count);
}

_MTL_INLINE void MTL4::CommandQueue::commit(const MTL4::CommandBuffer* const commandBuffers[], NS::UInteger count, const MTL4::CommitOptions* options)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(commit_count_options_), commandBuffers, count, options);
}

_MTL_INLINE void MTL4::CommandQueue::copyBufferMappingsFromBuffer(const MTL::Buffer* sourceBuffer, const MTL::Buffer* destinationBuffer, const MTL4::CopySparseBufferMappingOperation* operations, NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyBufferMappingsFromBuffer_toBuffer_operations_count_), sourceBuffer, destinationBuffer, operations, count);
}

_MTL_INLINE void MTL4::CommandQueue::copyTextureMappingsFromTexture(const MTL::Texture* sourceTexture, const MTL::Texture* destinationTexture, const MTL4::CopySparseTextureMappingOperation* operations, NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyTextureMappingsFromTexture_toTexture_operations_count_), sourceTexture, destinationTexture, operations, count);
}

_MTL_INLINE MTL::Device* MTL4::CommandQueue::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE NS::String* MTL4::CommandQueue::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE void MTL4::CommandQueue::removeResidencySet(const MTL::ResidencySet* residencySet)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(removeResidencySet_), residencySet);
}

_MTL_INLINE void MTL4::CommandQueue::removeResidencySets(const MTL::ResidencySet* const residencySets[], NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(removeResidencySets_count_), residencySets, count);
}

_MTL_INLINE void MTL4::CommandQueue::signalDrawable(const MTL::Drawable* drawable)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(signalDrawable_), drawable);
}

_MTL_INLINE void MTL4::CommandQueue::signalEvent(const MTL::Event* event, uint64_t value)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(signalEvent_value_), event, value);
}

_MTL_INLINE void MTL4::CommandQueue::updateBufferMappings(const MTL::Buffer* buffer, const MTL::Heap* heap, const MTL4::UpdateSparseBufferMappingOperation* operations, NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(updateBufferMappings_heap_operations_count_), buffer, heap, operations, count);
}

_MTL_INLINE void MTL4::CommandQueue::updateTextureMappings(const MTL::Texture* texture, const MTL::Heap* heap, const MTL4::UpdateSparseTextureMappingOperation* operations, NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(updateTextureMappings_heap_operations_count_), texture, heap, operations, count);
}

_MTL_INLINE void MTL4::CommandQueue::wait(const MTL::Event* event, uint64_t value)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(waitForEvent_value_), event, value);
}

_MTL_INLINE void MTL4::CommandQueue::wait(const MTL::Drawable* drawable)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(waitForDrawable_), drawable);
}

#pragma once

namespace MTL4
{
class RenderPassDescriptor;
}

namespace MTL
{
class Buffer;
class RasterizationRateMap;
class RenderPassColorAttachmentDescriptorArray;
class RenderPassDepthAttachmentDescriptor;
class RenderPassStencilAttachmentDescriptor;
struct SamplePosition;
}

namespace MTL4
{
class RenderPassDescriptor : public NS::Copying<RenderPassDescriptor>
{
public:
    static RenderPassDescriptor*                   alloc();

    MTL::RenderPassColorAttachmentDescriptorArray* colorAttachments() const;

    NS::UInteger                                   defaultRasterSampleCount() const;

    MTL::RenderPassDepthAttachmentDescriptor*      depthAttachment() const;

    NS::UInteger                                   getSamplePositions(MTL::SamplePosition* positions, NS::UInteger count);

    NS::UInteger                                   imageblockSampleLength() const;

    RenderPassDescriptor*                          init();

    MTL::RasterizationRateMap*                     rasterizationRateMap() const;

    NS::UInteger                                   renderTargetArrayLength() const;

    NS::UInteger                                   renderTargetHeight() const;

    NS::UInteger                                   renderTargetWidth() const;

    void                                           setDefaultRasterSampleCount(NS::UInteger defaultRasterSampleCount);

    void                                           setDepthAttachment(const MTL::RenderPassDepthAttachmentDescriptor* depthAttachment);

    void                                           setImageblockSampleLength(NS::UInteger imageblockSampleLength);

    void                                           setRasterizationRateMap(const MTL::RasterizationRateMap* rasterizationRateMap);

    void                                           setRenderTargetArrayLength(NS::UInteger renderTargetArrayLength);

    void                                           setRenderTargetHeight(NS::UInteger renderTargetHeight);

    void                                           setRenderTargetWidth(NS::UInteger renderTargetWidth);

    void                                           setSamplePositions(const MTL::SamplePosition* positions, NS::UInteger count);

    void                                           setStencilAttachment(const MTL::RenderPassStencilAttachmentDescriptor* stencilAttachment);

    void                                           setSupportColorAttachmentMapping(bool supportColorAttachmentMapping);

    void                                           setThreadgroupMemoryLength(NS::UInteger threadgroupMemoryLength);

    void                                           setTileHeight(NS::UInteger tileHeight);

    void                                           setTileWidth(NS::UInteger tileWidth);

    void                                           setVisibilityResultBuffer(const MTL::Buffer* visibilityResultBuffer);

    void                                           setVisibilityResultType(MTL::VisibilityResultType visibilityResultType);

    MTL::RenderPassStencilAttachmentDescriptor*    stencilAttachment() const;

    bool                                           supportColorAttachmentMapping() const;

    NS::UInteger                                   threadgroupMemoryLength() const;

    NS::UInteger                                   tileHeight() const;

    NS::UInteger                                   tileWidth() const;

    MTL::Buffer*                                   visibilityResultBuffer() const;

    MTL::VisibilityResultType                      visibilityResultType() const;
};

}
_MTL_INLINE MTL4::RenderPassDescriptor* MTL4::RenderPassDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::RenderPassDescriptor>(_MTL_PRIVATE_CLS(MTL4RenderPassDescriptor));
}

_MTL_INLINE MTL::RenderPassColorAttachmentDescriptorArray* MTL4::RenderPassDescriptor::colorAttachments() const
{
    return Object::sendMessage<MTL::RenderPassColorAttachmentDescriptorArray*>(this, _MTL_PRIVATE_SEL(colorAttachments));
}

_MTL_INLINE NS::UInteger MTL4::RenderPassDescriptor::defaultRasterSampleCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(defaultRasterSampleCount));
}

_MTL_INLINE MTL::RenderPassDepthAttachmentDescriptor* MTL4::RenderPassDescriptor::depthAttachment() const
{
    return Object::sendMessage<MTL::RenderPassDepthAttachmentDescriptor*>(this, _MTL_PRIVATE_SEL(depthAttachment));
}

_MTL_INLINE NS::UInteger MTL4::RenderPassDescriptor::getSamplePositions(MTL::SamplePosition* positions, NS::UInteger count)
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(getSamplePositions_count_), positions, count);
}

_MTL_INLINE NS::UInteger MTL4::RenderPassDescriptor::imageblockSampleLength() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(imageblockSampleLength));
}

_MTL_INLINE MTL4::RenderPassDescriptor* MTL4::RenderPassDescriptor::init()
{
    return NS::Object::init<MTL4::RenderPassDescriptor>();
}

_MTL_INLINE MTL::RasterizationRateMap* MTL4::RenderPassDescriptor::rasterizationRateMap() const
{
    return Object::sendMessage<MTL::RasterizationRateMap*>(this, _MTL_PRIVATE_SEL(rasterizationRateMap));
}

_MTL_INLINE NS::UInteger MTL4::RenderPassDescriptor::renderTargetArrayLength() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(renderTargetArrayLength));
}

_MTL_INLINE NS::UInteger MTL4::RenderPassDescriptor::renderTargetHeight() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(renderTargetHeight));
}

_MTL_INLINE NS::UInteger MTL4::RenderPassDescriptor::renderTargetWidth() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(renderTargetWidth));
}

_MTL_INLINE void MTL4::RenderPassDescriptor::setDefaultRasterSampleCount(NS::UInteger defaultRasterSampleCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDefaultRasterSampleCount_), defaultRasterSampleCount);
}

_MTL_INLINE void MTL4::RenderPassDescriptor::setDepthAttachment(const MTL::RenderPassDepthAttachmentDescriptor* depthAttachment)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDepthAttachment_), depthAttachment);
}

_MTL_INLINE void MTL4::RenderPassDescriptor::setImageblockSampleLength(NS::UInteger imageblockSampleLength)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setImageblockSampleLength_), imageblockSampleLength);
}

_MTL_INLINE void MTL4::RenderPassDescriptor::setRasterizationRateMap(const MTL::RasterizationRateMap* rasterizationRateMap)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRasterizationRateMap_), rasterizationRateMap);
}

_MTL_INLINE void MTL4::RenderPassDescriptor::setRenderTargetArrayLength(NS::UInteger renderTargetArrayLength)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRenderTargetArrayLength_), renderTargetArrayLength);
}

_MTL_INLINE void MTL4::RenderPassDescriptor::setRenderTargetHeight(NS::UInteger renderTargetHeight)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRenderTargetHeight_), renderTargetHeight);
}

_MTL_INLINE void MTL4::RenderPassDescriptor::setRenderTargetWidth(NS::UInteger renderTargetWidth)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRenderTargetWidth_), renderTargetWidth);
}

_MTL_INLINE void MTL4::RenderPassDescriptor::setSamplePositions(const MTL::SamplePosition* positions, NS::UInteger count)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSamplePositions_count_), positions, count);
}

_MTL_INLINE void MTL4::RenderPassDescriptor::setStencilAttachment(const MTL::RenderPassStencilAttachmentDescriptor* stencilAttachment)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStencilAttachment_), stencilAttachment);
}

_MTL_INLINE void MTL4::RenderPassDescriptor::setSupportColorAttachmentMapping(bool supportColorAttachmentMapping)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportColorAttachmentMapping_), supportColorAttachmentMapping);
}

_MTL_INLINE void MTL4::RenderPassDescriptor::setThreadgroupMemoryLength(NS::UInteger threadgroupMemoryLength)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setThreadgroupMemoryLength_), threadgroupMemoryLength);
}

_MTL_INLINE void MTL4::RenderPassDescriptor::setTileHeight(NS::UInteger tileHeight)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileHeight_), tileHeight);
}

_MTL_INLINE void MTL4::RenderPassDescriptor::setTileWidth(NS::UInteger tileWidth)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileWidth_), tileWidth);
}

_MTL_INLINE void MTL4::RenderPassDescriptor::setVisibilityResultBuffer(const MTL::Buffer* visibilityResultBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVisibilityResultBuffer_), visibilityResultBuffer);
}

_MTL_INLINE void MTL4::RenderPassDescriptor::setVisibilityResultType(MTL::VisibilityResultType visibilityResultType)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVisibilityResultType_), visibilityResultType);
}

_MTL_INLINE MTL::RenderPassStencilAttachmentDescriptor* MTL4::RenderPassDescriptor::stencilAttachment() const
{
    return Object::sendMessage<MTL::RenderPassStencilAttachmentDescriptor*>(this, _MTL_PRIVATE_SEL(stencilAttachment));
}

_MTL_INLINE bool MTL4::RenderPassDescriptor::supportColorAttachmentMapping() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportColorAttachmentMapping));
}

_MTL_INLINE NS::UInteger MTL4::RenderPassDescriptor::threadgroupMemoryLength() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(threadgroupMemoryLength));
}

_MTL_INLINE NS::UInteger MTL4::RenderPassDescriptor::tileHeight() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(tileHeight));
}

_MTL_INLINE NS::UInteger MTL4::RenderPassDescriptor::tileWidth() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(tileWidth));
}

_MTL_INLINE MTL::Buffer* MTL4::RenderPassDescriptor::visibilityResultBuffer() const
{
    return Object::sendMessage<MTL::Buffer*>(this, _MTL_PRIVATE_SEL(visibilityResultBuffer));
}

_MTL_INLINE MTL::VisibilityResultType MTL4::RenderPassDescriptor::visibilityResultType() const
{
    return Object::sendMessage<MTL::VisibilityResultType>(this, _MTL_PRIVATE_SEL(visibilityResultType));
}

#pragma once

#include <cstdint>

namespace MTL4
{
class AccelerationStructureDescriptor;
class ArgumentTable;
class CounterHeap;
}

namespace MTL
{
class AccelerationStructure;
class Buffer;
class ComputePipelineState;
class IndirectCommandBuffer;
class Tensor;
class TensorExtents;
class Texture;
}

namespace MTL4
{
class ComputeCommandEncoder : public NS::Referencing<ComputeCommandEncoder, CommandEncoder>
{
public:
    void        buildAccelerationStructure(const MTL::AccelerationStructure* accelerationStructure, const MTL4::AccelerationStructureDescriptor* descriptor, const MTL4::BufferRange scratchBuffer);

    void        copyAccelerationStructure(const MTL::AccelerationStructure* sourceAccelerationStructure, const MTL::AccelerationStructure* destinationAccelerationStructure);

    void        copyAndCompactAccelerationStructure(const MTL::AccelerationStructure* sourceAccelerationStructure, const MTL::AccelerationStructure* destinationAccelerationStructure);

    void        copyFromBuffer(const MTL::Buffer* sourceBuffer, NS::UInteger sourceOffset, const MTL::Buffer* destinationBuffer, NS::UInteger destinationOffset, NS::UInteger size);
    void        copyFromBuffer(const MTL::Buffer* sourceBuffer, NS::UInteger sourceOffset, NS::UInteger sourceBytesPerRow, NS::UInteger sourceBytesPerImage, MTL::Size sourceSize, const MTL::Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, MTL::Origin destinationOrigin);
    void        copyFromBuffer(const MTL::Buffer* sourceBuffer, NS::UInteger sourceOffset, NS::UInteger sourceBytesPerRow, NS::UInteger sourceBytesPerImage, MTL::Size sourceSize, const MTL::Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, MTL::Origin destinationOrigin, MTL::BlitOption options);

    void        copyFromTensor(const MTL::Tensor* sourceTensor, const MTL::TensorExtents* sourceOrigin, const MTL::TensorExtents* sourceDimensions, const MTL::Tensor* destinationTensor, const MTL::TensorExtents* destinationOrigin, const MTL::TensorExtents* destinationDimensions);

    void        copyFromTexture(const MTL::Texture* sourceTexture, const MTL::Texture* destinationTexture);
    void        copyFromTexture(const MTL::Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, const MTL::Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, NS::UInteger sliceCount, NS::UInteger levelCount);
    void        copyFromTexture(const MTL::Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, MTL::Origin sourceOrigin, MTL::Size sourceSize, const MTL::Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, MTL::Origin destinationOrigin);
    void        copyFromTexture(const MTL::Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, MTL::Origin sourceOrigin, MTL::Size sourceSize, const MTL::Buffer* destinationBuffer, NS::UInteger destinationOffset, NS::UInteger destinationBytesPerRow, NS::UInteger destinationBytesPerImage);
    void        copyFromTexture(const MTL::Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, MTL::Origin sourceOrigin, MTL::Size sourceSize, const MTL::Buffer* destinationBuffer, NS::UInteger destinationOffset, NS::UInteger destinationBytesPerRow, NS::UInteger destinationBytesPerImage, MTL::BlitOption options);

    void        copyIndirectCommandBuffer(const MTL::IndirectCommandBuffer* source, NS::Range sourceRange, const MTL::IndirectCommandBuffer* destination, NS::UInteger destinationIndex);

    void        dispatchThreadgroups(MTL::Size threadgroupsPerGrid, MTL::Size threadsPerThreadgroup);
    void        dispatchThreadgroups(MTL::GPUAddress indirectBuffer, MTL::Size threadsPerThreadgroup);

    void        dispatchThreads(MTL::Size threadsPerGrid, MTL::Size threadsPerThreadgroup);
    void        dispatchThreads(MTL::GPUAddress indirectBuffer);

    void        executeCommandsInBuffer(const MTL::IndirectCommandBuffer* indirectCommandBuffer, NS::Range executionRange);
    void        executeCommandsInBuffer(const MTL::IndirectCommandBuffer* indirectCommandbuffer, MTL::GPUAddress indirectRangeBuffer);

    void        fillBuffer(const MTL::Buffer* buffer, NS::Range range, uint8_t value);

    void        generateMipmaps(const MTL::Texture* texture);

    void        optimizeContentsForCPUAccess(const MTL::Texture* texture);
    void        optimizeContentsForCPUAccess(const MTL::Texture* texture, NS::UInteger slice, NS::UInteger level);

    void        optimizeContentsForGPUAccess(const MTL::Texture* texture);
    void        optimizeContentsForGPUAccess(const MTL::Texture* texture, NS::UInteger slice, NS::UInteger level);

    void        optimizeIndirectCommandBuffer(const MTL::IndirectCommandBuffer* indirectCommandBuffer, NS::Range range);

    void        refitAccelerationStructure(const MTL::AccelerationStructure* sourceAccelerationStructure, const MTL4::AccelerationStructureDescriptor* descriptor, const MTL::AccelerationStructure* destinationAccelerationStructure, const MTL4::BufferRange scratchBuffer);
    void        refitAccelerationStructure(const MTL::AccelerationStructure* sourceAccelerationStructure, const MTL4::AccelerationStructureDescriptor* descriptor, const MTL::AccelerationStructure* destinationAccelerationStructure, const MTL4::BufferRange scratchBuffer, MTL::AccelerationStructureRefitOptions options);

    void        resetCommandsInBuffer(const MTL::IndirectCommandBuffer* buffer, NS::Range range);

    void        setArgumentTable(const MTL4::ArgumentTable* argumentTable);

    void        setComputePipelineState(const MTL::ComputePipelineState* state);

    void        setImageblockWidth(NS::UInteger width, NS::UInteger height);

    void        setThreadgroupMemoryLength(NS::UInteger length, NS::UInteger index);

    MTL::Stages stages();

    void        writeCompactedAccelerationStructureSize(const MTL::AccelerationStructure* accelerationStructure, const MTL4::BufferRange buffer);

    void        writeTimestamp(MTL4::TimestampGranularity granularity, const MTL4::CounterHeap* counterHeap, NS::UInteger index);
};

}
_MTL_INLINE void MTL4::ComputeCommandEncoder::buildAccelerationStructure(const MTL::AccelerationStructure* accelerationStructure, const MTL4::AccelerationStructureDescriptor* descriptor, const MTL4::BufferRange scratchBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(buildAccelerationStructure_descriptor_scratchBuffer_), accelerationStructure, descriptor, scratchBuffer);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::copyAccelerationStructure(const MTL::AccelerationStructure* sourceAccelerationStructure, const MTL::AccelerationStructure* destinationAccelerationStructure)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyAccelerationStructure_toAccelerationStructure_), sourceAccelerationStructure, destinationAccelerationStructure);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::copyAndCompactAccelerationStructure(const MTL::AccelerationStructure* sourceAccelerationStructure, const MTL::AccelerationStructure* destinationAccelerationStructure)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyAndCompactAccelerationStructure_toAccelerationStructure_), sourceAccelerationStructure, destinationAccelerationStructure);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::copyFromBuffer(const MTL::Buffer* sourceBuffer, NS::UInteger sourceOffset, const MTL::Buffer* destinationBuffer, NS::UInteger destinationOffset, NS::UInteger size)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyFromBuffer_sourceOffset_toBuffer_destinationOffset_size_), sourceBuffer, sourceOffset, destinationBuffer, destinationOffset, size);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::copyFromBuffer(const MTL::Buffer* sourceBuffer, NS::UInteger sourceOffset, NS::UInteger sourceBytesPerRow, NS::UInteger sourceBytesPerImage, MTL::Size sourceSize, const MTL::Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, MTL::Origin destinationOrigin)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyFromBuffer_sourceOffset_sourceBytesPerRow_sourceBytesPerImage_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin_), sourceBuffer, sourceOffset, sourceBytesPerRow, sourceBytesPerImage, sourceSize, destinationTexture, destinationSlice, destinationLevel, destinationOrigin);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::copyFromBuffer(const MTL::Buffer* sourceBuffer, NS::UInteger sourceOffset, NS::UInteger sourceBytesPerRow, NS::UInteger sourceBytesPerImage, MTL::Size sourceSize, const MTL::Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, MTL::Origin destinationOrigin, MTL::BlitOption options)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyFromBuffer_sourceOffset_sourceBytesPerRow_sourceBytesPerImage_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin_options_), sourceBuffer, sourceOffset, sourceBytesPerRow, sourceBytesPerImage, sourceSize, destinationTexture, destinationSlice, destinationLevel, destinationOrigin, options);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::copyFromTensor(const MTL::Tensor* sourceTensor, const MTL::TensorExtents* sourceOrigin, const MTL::TensorExtents* sourceDimensions, const MTL::Tensor* destinationTensor, const MTL::TensorExtents* destinationOrigin, const MTL::TensorExtents* destinationDimensions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyFromTensor_sourceOrigin_sourceDimensions_toTensor_destinationOrigin_destinationDimensions_), sourceTensor, sourceOrigin, sourceDimensions, destinationTensor, destinationOrigin, destinationDimensions);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::copyFromTexture(const MTL::Texture* sourceTexture, const MTL::Texture* destinationTexture)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyFromTexture_toTexture_), sourceTexture, destinationTexture);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::copyFromTexture(const MTL::Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, const MTL::Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, NS::UInteger sliceCount, NS::UInteger levelCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyFromTexture_sourceSlice_sourceLevel_toTexture_destinationSlice_destinationLevel_sliceCount_levelCount_), sourceTexture, sourceSlice, sourceLevel, destinationTexture, destinationSlice, destinationLevel, sliceCount, levelCount);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::copyFromTexture(const MTL::Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, MTL::Origin sourceOrigin, MTL::Size sourceSize, const MTL::Texture* destinationTexture, NS::UInteger destinationSlice, NS::UInteger destinationLevel, MTL::Origin destinationOrigin)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin_), sourceTexture, sourceSlice, sourceLevel, sourceOrigin, sourceSize, destinationTexture, destinationSlice, destinationLevel, destinationOrigin);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::copyFromTexture(const MTL::Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, MTL::Origin sourceOrigin, MTL::Size sourceSize, const MTL::Buffer* destinationBuffer, NS::UInteger destinationOffset, NS::UInteger destinationBytesPerRow, NS::UInteger destinationBytesPerImage)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toBuffer_destinationOffset_destinationBytesPerRow_destinationBytesPerImage_), sourceTexture, sourceSlice, sourceLevel, sourceOrigin, sourceSize, destinationBuffer, destinationOffset, destinationBytesPerRow, destinationBytesPerImage);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::copyFromTexture(const MTL::Texture* sourceTexture, NS::UInteger sourceSlice, NS::UInteger sourceLevel, MTL::Origin sourceOrigin, MTL::Size sourceSize, const MTL::Buffer* destinationBuffer, NS::UInteger destinationOffset, NS::UInteger destinationBytesPerRow, NS::UInteger destinationBytesPerImage, MTL::BlitOption options)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toBuffer_destinationOffset_destinationBytesPerRow_destinationBytesPerImage_options_), sourceTexture, sourceSlice, sourceLevel, sourceOrigin, sourceSize, destinationBuffer, destinationOffset, destinationBytesPerRow, destinationBytesPerImage, options);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::copyIndirectCommandBuffer(const MTL::IndirectCommandBuffer* source, NS::Range sourceRange, const MTL::IndirectCommandBuffer* destination, NS::UInteger destinationIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(copyIndirectCommandBuffer_sourceRange_destination_destinationIndex_), source, sourceRange, destination, destinationIndex);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::dispatchThreadgroups(MTL::Size threadgroupsPerGrid, MTL::Size threadsPerThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(dispatchThreadgroups_threadsPerThreadgroup_), threadgroupsPerGrid, threadsPerThreadgroup);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::dispatchThreadgroups(MTL::GPUAddress indirectBuffer, MTL::Size threadsPerThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(dispatchThreadgroupsWithIndirectBuffer_threadsPerThreadgroup_), indirectBuffer, threadsPerThreadgroup);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::dispatchThreads(MTL::Size threadsPerGrid, MTL::Size threadsPerThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(dispatchThreads_threadsPerThreadgroup_), threadsPerGrid, threadsPerThreadgroup);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::dispatchThreads(MTL::GPUAddress indirectBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(dispatchThreadsWithIndirectBuffer_), indirectBuffer);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::executeCommandsInBuffer(const MTL::IndirectCommandBuffer* indirectCommandBuffer, NS::Range executionRange)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(executeCommandsInBuffer_withRange_), indirectCommandBuffer, executionRange);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::executeCommandsInBuffer(const MTL::IndirectCommandBuffer* indirectCommandbuffer, MTL::GPUAddress indirectRangeBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(executeCommandsInBuffer_indirectBuffer_), indirectCommandbuffer, indirectRangeBuffer);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::fillBuffer(const MTL::Buffer* buffer, NS::Range range, uint8_t value)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(fillBuffer_range_value_), buffer, range, value);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::generateMipmaps(const MTL::Texture* texture)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(generateMipmapsForTexture_), texture);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::optimizeContentsForCPUAccess(const MTL::Texture* texture)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(optimizeContentsForCPUAccess_), texture);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::optimizeContentsForCPUAccess(const MTL::Texture* texture, NS::UInteger slice, NS::UInteger level)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(optimizeContentsForCPUAccess_slice_level_), texture, slice, level);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::optimizeContentsForGPUAccess(const MTL::Texture* texture)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(optimizeContentsForGPUAccess_), texture);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::optimizeContentsForGPUAccess(const MTL::Texture* texture, NS::UInteger slice, NS::UInteger level)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(optimizeContentsForGPUAccess_slice_level_), texture, slice, level);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::optimizeIndirectCommandBuffer(const MTL::IndirectCommandBuffer* indirectCommandBuffer, NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(optimizeIndirectCommandBuffer_withRange_), indirectCommandBuffer, range);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::refitAccelerationStructure(const MTL::AccelerationStructure* sourceAccelerationStructure, const MTL4::AccelerationStructureDescriptor* descriptor, const MTL::AccelerationStructure* destinationAccelerationStructure, const MTL4::BufferRange scratchBuffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(refitAccelerationStructure_descriptor_destination_scratchBuffer_), sourceAccelerationStructure, descriptor, destinationAccelerationStructure, scratchBuffer);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::refitAccelerationStructure(const MTL::AccelerationStructure* sourceAccelerationStructure, const MTL4::AccelerationStructureDescriptor* descriptor, const MTL::AccelerationStructure* destinationAccelerationStructure, const MTL4::BufferRange scratchBuffer, MTL::AccelerationStructureRefitOptions options)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(refitAccelerationStructure_descriptor_destination_scratchBuffer_options_), sourceAccelerationStructure, descriptor, destinationAccelerationStructure, scratchBuffer, options);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::resetCommandsInBuffer(const MTL::IndirectCommandBuffer* buffer, NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(resetCommandsInBuffer_withRange_), buffer, range);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::setArgumentTable(const MTL4::ArgumentTable* argumentTable)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setArgumentTable_), argumentTable);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::setComputePipelineState(const MTL::ComputePipelineState* state)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setComputePipelineState_), state);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::setImageblockWidth(NS::UInteger width, NS::UInteger height)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setImageblockWidth_height_), width, height);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::setThreadgroupMemoryLength(NS::UInteger length, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setThreadgroupMemoryLength_atIndex_), length, index);
}

_MTL_INLINE MTL::Stages MTL4::ComputeCommandEncoder::stages()
{
    return Object::sendMessage<MTL::Stages>(this, _MTL_PRIVATE_SEL(stages));
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::writeCompactedAccelerationStructureSize(const MTL::AccelerationStructure* accelerationStructure, const MTL4::BufferRange buffer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(writeCompactedAccelerationStructureSize_toBuffer_), accelerationStructure, buffer);
}

_MTL_INLINE void MTL4::ComputeCommandEncoder::writeTimestamp(MTL4::TimestampGranularity granularity, const MTL4::CounterHeap* counterHeap, NS::UInteger index)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(writeTimestampWithGranularity_intoHeap_atIndex_), granularity, counterHeap, index);
}

#pragma once

namespace MTL4
{
class ArgumentTable;
class MachineLearningPipelineState;
}

namespace MTL
{
class Heap;
}

namespace MTL4
{
class MachineLearningCommandEncoder : public NS::Referencing<MachineLearningCommandEncoder, CommandEncoder>
{
public:
    void dispatchNetwork(const MTL::Heap* heap);

    void setArgumentTable(const MTL4::ArgumentTable* argumentTable);

    void setPipelineState(const MTL4::MachineLearningPipelineState* pipelineState);
};

}
_MTL_INLINE void MTL4::MachineLearningCommandEncoder::dispatchNetwork(const MTL::Heap* heap)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(dispatchNetworkWithIntermediatesHeap_), heap);
}

_MTL_INLINE void MTL4::MachineLearningCommandEncoder::setArgumentTable(const MTL4::ArgumentTable* argumentTable)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setArgumentTable_), argumentTable);
}

_MTL_INLINE void MTL4::MachineLearningCommandEncoder::setPipelineState(const MTL4::MachineLearningPipelineState* pipelineState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPipelineState_), pipelineState);
}

#pragma once

#include <functional>

namespace MTL4
{
class BinaryFunction;
class BinaryFunctionDescriptor;
class CompilerDescriptor;
class CompilerTask;
class CompilerTaskOptions;
class ComputePipelineDescriptor;
class LibraryDescriptor;
class MachineLearningPipelineDescriptor;
class MachineLearningPipelineState;
class PipelineDataSetSerializer;
class PipelineDescriptor;
class PipelineStageDynamicLinkingDescriptor;
class RenderPipelineDynamicLinkingDescriptor;
}

namespace MTL
{
class ComputePipelineState;
class Device;
class DynamicLibrary;
class Library;
class RenderPipelineState;

using NewDynamicLibraryCompletionHandler = void (^)(MTL::DynamicLibrary*, NS::Error*);
using NewDynamicLibraryCompletionHandlerFunction = std::function<void(MTL::DynamicLibrary*, NS::Error*)>;
}

namespace MTL4
{
using NewComputePipelineStateCompletionHandler = void (^)(MTL::ComputePipelineState*, NS::Error*);
using NewComputePipelineStateCompletionHandlerFunction = std::function<void(MTL::ComputePipelineState*, NS::Error*)>;
using NewRenderPipelineStateCompletionHandler = void (^)(MTL::RenderPipelineState*, NS::Error*);
using NewRenderPipelineStateCompletionHandlerFunction = std::function<void(MTL::RenderPipelineState*, NS::Error*)>;
using NewBinaryFunctionCompletionHandler = void (^)(MTL4::BinaryFunction*, NS::Error*);
using NewBinaryFunctionCompletionHandlerFunction = std::function<void(MTL4::BinaryFunction*, NS::Error*)>;
using NewMachineLearningPipelineStateCompletionHandler = void (^)(MTL4::MachineLearningPipelineState*, NS::Error*);
using NewMachineLearningPipelineStateCompletionHandlerFunction = std::function<void(MTL4::MachineLearningPipelineState*, NS::Error*)>;

class CompilerDescriptor : public NS::Copying<CompilerDescriptor>
{
public:
    static CompilerDescriptor* alloc();

    CompilerDescriptor*        init();

    NS::String*                label() const;

    PipelineDataSetSerializer* pipelineDataSetSerializer() const;

    void                       setLabel(const NS::String* label);

    void                       setPipelineDataSetSerializer(const MTL4::PipelineDataSetSerializer* pipelineDataSetSerializer);
};
class CompilerTaskOptions : public NS::Copying<CompilerTaskOptions>
{
public:
    static CompilerTaskOptions* alloc();

    CompilerTaskOptions*        init();

    NS::Array*                  lookupArchives() const;
    void                        setLookupArchives(const NS::Array* lookupArchives);
};
class Compiler : public NS::Referencing<Compiler>
{
public:
    MTL::Device*                  device() const;

    NS::String*                   label() const;

    BinaryFunction*               newBinaryFunction(const MTL4::BinaryFunctionDescriptor* descriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, NS::Error** error);
    CompilerTask*                 newBinaryFunction(const MTL4::BinaryFunctionDescriptor* descriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, const MTL4::NewBinaryFunctionCompletionHandler completionHandler);

    MTL::ComputePipelineState*    newComputePipelineState(const MTL4::ComputePipelineDescriptor* descriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, NS::Error** error);
    MTL::ComputePipelineState*    newComputePipelineState(const MTL4::ComputePipelineDescriptor* descriptor, const MTL4::PipelineStageDynamicLinkingDescriptor* dynamicLinkingDescriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, NS::Error** error);
    CompilerTask*                 newComputePipelineState(const MTL4::ComputePipelineDescriptor* descriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, const MTL::NewComputePipelineStateCompletionHandler completionHandler);
    CompilerTask*                 newComputePipelineState(const MTL4::ComputePipelineDescriptor* descriptor, const MTL4::PipelineStageDynamicLinkingDescriptor* dynamicLinkingDescriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, const MTL::NewComputePipelineStateCompletionHandler completionHandler);
    CompilerTask*                 newComputePipelineState(const MTL4::ComputePipelineDescriptor* pDescriptor, const MTL4::CompilerTaskOptions* options, const MTL4::NewComputePipelineStateCompletionHandlerFunction& function);

    MTL::DynamicLibrary*          newDynamicLibrary(const MTL::Library* library, NS::Error** error);
    MTL::DynamicLibrary*          newDynamicLibrary(const NS::URL* url, NS::Error** error);
    CompilerTask*                 newDynamicLibrary(const MTL::Library* library, const MTL::NewDynamicLibraryCompletionHandler completionHandler);
    CompilerTask*                 newDynamicLibrary(const NS::URL* url, const MTL::NewDynamicLibraryCompletionHandler completionHandler);
    CompilerTask*                 newDynamicLibrary(const MTL::Library* pLibrary, const MTL::NewDynamicLibraryCompletionHandlerFunction& function);
    CompilerTask*                 newDynamicLibrary(const NS::URL* pURL, const MTL::NewDynamicLibraryCompletionHandlerFunction& function);

    MTL::Library*                 newLibrary(const MTL4::LibraryDescriptor* descriptor, NS::Error** error);
    CompilerTask*                 newLibrary(const MTL4::LibraryDescriptor* descriptor, const MTL::NewLibraryCompletionHandler completionHandler);
    CompilerTask*                 newLibrary(const MTL4::LibraryDescriptor* pDescriptor, const MTL::NewLibraryCompletionHandlerFunction& function);

    MachineLearningPipelineState* newMachineLearningPipelineState(const MTL4::MachineLearningPipelineDescriptor* descriptor, NS::Error** error);
    CompilerTask*                 newMachineLearningPipelineState(const MTL4::MachineLearningPipelineDescriptor* descriptor, const MTL4::NewMachineLearningPipelineStateCompletionHandler completionHandler);
    CompilerTask*                 newMachineLearningPipelineState(const MTL4::MachineLearningPipelineDescriptor* pDescriptor, const MTL4::NewMachineLearningPipelineStateCompletionHandlerFunction& function);

    MTL::RenderPipelineState*     newRenderPipelineState(const MTL4::PipelineDescriptor* descriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, NS::Error** error);
    MTL::RenderPipelineState*     newRenderPipelineState(const MTL4::PipelineDescriptor* descriptor, const MTL4::RenderPipelineDynamicLinkingDescriptor* dynamicLinkingDescriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, NS::Error** error);
    CompilerTask*                 newRenderPipelineState(const MTL4::PipelineDescriptor* descriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, const MTL::NewRenderPipelineStateCompletionHandler completionHandler);
    CompilerTask*                 newRenderPipelineState(const MTL4::PipelineDescriptor* descriptor, const MTL4::RenderPipelineDynamicLinkingDescriptor* dynamicLinkingDescriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, const MTL::NewRenderPipelineStateCompletionHandler completionHandler);
    CompilerTask*                 newRenderPipelineState(const MTL4::PipelineDescriptor* pDescriptor, const MTL4::CompilerTaskOptions* options, const MTL4::NewRenderPipelineStateCompletionHandlerFunction& function);
    MTL::RenderPipelineState*     newRenderPipelineStateBySpecialization(const MTL4::PipelineDescriptor* descriptor, const MTL::RenderPipelineState* pipeline, NS::Error** error);
    CompilerTask*                 newRenderPipelineStateBySpecialization(const MTL4::PipelineDescriptor* descriptor, const MTL::RenderPipelineState* pipeline, const MTL::NewRenderPipelineStateCompletionHandler completionHandler);
    CompilerTask*                 newRenderPipelineStateBySpecialization(const MTL4::PipelineDescriptor* pDescriptor, const MTL::RenderPipelineState* pPipeline, const MTL4::NewRenderPipelineStateCompletionHandlerFunction& function);

    PipelineDataSetSerializer*    pipelineDataSetSerializer() const;
};

}
_MTL_INLINE MTL4::CompilerDescriptor* MTL4::CompilerDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::CompilerDescriptor>(_MTL_PRIVATE_CLS(MTL4CompilerDescriptor));
}

_MTL_INLINE MTL4::CompilerDescriptor* MTL4::CompilerDescriptor::init()
{
    return NS::Object::init<MTL4::CompilerDescriptor>();
}

_MTL_INLINE NS::String* MTL4::CompilerDescriptor::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE MTL4::PipelineDataSetSerializer* MTL4::CompilerDescriptor::pipelineDataSetSerializer() const
{
    return Object::sendMessage<MTL4::PipelineDataSetSerializer*>(this, _MTL_PRIVATE_SEL(pipelineDataSetSerializer));
}

_MTL_INLINE void MTL4::CompilerDescriptor::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE void MTL4::CompilerDescriptor::setPipelineDataSetSerializer(const MTL4::PipelineDataSetSerializer* pipelineDataSetSerializer)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPipelineDataSetSerializer_), pipelineDataSetSerializer);
}

_MTL_INLINE MTL4::CompilerTaskOptions* MTL4::CompilerTaskOptions::alloc()
{
    return NS::Object::alloc<MTL4::CompilerTaskOptions>(_MTL_PRIVATE_CLS(MTL4CompilerTaskOptions));
}

_MTL_INLINE MTL4::CompilerTaskOptions* MTL4::CompilerTaskOptions::init()
{
    return NS::Object::init<MTL4::CompilerTaskOptions>();
}

_MTL_INLINE NS::Array* MTL4::CompilerTaskOptions::lookupArchives() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(lookupArchives));
}

_MTL_INLINE void MTL4::CompilerTaskOptions::setLookupArchives(const NS::Array* lookupArchives)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLookupArchives_), lookupArchives);
}

_MTL_INLINE MTL::Device* MTL4::Compiler::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE NS::String* MTL4::Compiler::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE MTL4::BinaryFunction* MTL4::Compiler::newBinaryFunction(const MTL4::BinaryFunctionDescriptor* descriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, NS::Error** error)
{
    return Object::sendMessage<MTL4::BinaryFunction*>(this, _MTL_PRIVATE_SEL(newBinaryFunctionWithDescriptor_compilerTaskOptions_error_), descriptor, compilerTaskOptions, error);
}

_MTL_INLINE MTL4::CompilerTask* MTL4::Compiler::newBinaryFunction(const MTL4::BinaryFunctionDescriptor* descriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, const MTL4::NewBinaryFunctionCompletionHandler completionHandler)
{
    return Object::sendMessage<MTL4::CompilerTask*>(this, _MTL_PRIVATE_SEL(newBinaryFunctionWithDescriptor_compilerTaskOptions_completionHandler_), descriptor, compilerTaskOptions, completionHandler);
}

_MTL_INLINE MTL::ComputePipelineState* MTL4::Compiler::newComputePipelineState(const MTL4::ComputePipelineDescriptor* descriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, NS::Error** error)
{
    return Object::sendMessage<MTL::ComputePipelineState*>(this, _MTL_PRIVATE_SEL(newComputePipelineStateWithDescriptor_compilerTaskOptions_error_), descriptor, compilerTaskOptions, error);
}

_MTL_INLINE MTL::ComputePipelineState* MTL4::Compiler::newComputePipelineState(const MTL4::ComputePipelineDescriptor* descriptor, const MTL4::PipelineStageDynamicLinkingDescriptor* dynamicLinkingDescriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, NS::Error** error)
{
    return Object::sendMessage<MTL::ComputePipelineState*>(this, _MTL_PRIVATE_SEL(newComputePipelineStateWithDescriptor_dynamicLinkingDescriptor_compilerTaskOptions_error_), descriptor, dynamicLinkingDescriptor, compilerTaskOptions, error);
}

_MTL_INLINE MTL4::CompilerTask* MTL4::Compiler::newComputePipelineState(const MTL4::ComputePipelineDescriptor* descriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, const MTL::NewComputePipelineStateCompletionHandler completionHandler)
{
    return Object::sendMessage<MTL4::CompilerTask*>(this, _MTL_PRIVATE_SEL(newComputePipelineStateWithDescriptor_compilerTaskOptions_completionHandler_), descriptor, compilerTaskOptions, completionHandler);
}

_MTL_INLINE MTL4::CompilerTask* MTL4::Compiler::newComputePipelineState(const MTL4::ComputePipelineDescriptor* descriptor, const MTL4::PipelineStageDynamicLinkingDescriptor* dynamicLinkingDescriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, const MTL::NewComputePipelineStateCompletionHandler completionHandler)
{
    return Object::sendMessage<MTL4::CompilerTask*>(this, _MTL_PRIVATE_SEL(newComputePipelineStateWithDescriptor_dynamicLinkingDescriptor_compilerTaskOptions_completionHandler_), descriptor, dynamicLinkingDescriptor, compilerTaskOptions, completionHandler);
}

_MTL_INLINE MTL4::CompilerTask* MTL4::Compiler::newComputePipelineState(const MTL4::ComputePipelineDescriptor* pDescriptor, const MTL4::CompilerTaskOptions* options, const MTL4::NewComputePipelineStateCompletionHandlerFunction& function)
{
    __block MTL4::NewComputePipelineStateCompletionHandlerFunction blockFunction = function;
    return newComputePipelineState(pDescriptor, options, ^(MTL::ComputePipelineState* pPipeline, NS::Error* pError) { blockFunction(pPipeline, pError); });
}

_MTL_INLINE MTL::DynamicLibrary* MTL4::Compiler::newDynamicLibrary(const MTL::Library* library, NS::Error** error)
{
    return Object::sendMessage<MTL::DynamicLibrary*>(this, _MTL_PRIVATE_SEL(newDynamicLibrary_error_), library, error);
}

_MTL_INLINE MTL::DynamicLibrary* MTL4::Compiler::newDynamicLibrary(const NS::URL* url, NS::Error** error)
{
    return Object::sendMessage<MTL::DynamicLibrary*>(this, _MTL_PRIVATE_SEL(newDynamicLibraryWithURL_error_), url, error);
}

_MTL_INLINE MTL4::CompilerTask* MTL4::Compiler::newDynamicLibrary(const MTL::Library* library, const MTL::NewDynamicLibraryCompletionHandler completionHandler)
{
    return Object::sendMessage<MTL4::CompilerTask*>(this, _MTL_PRIVATE_SEL(newDynamicLibrary_completionHandler_), library, completionHandler);
}

_MTL_INLINE MTL4::CompilerTask* MTL4::Compiler::newDynamicLibrary(const NS::URL* url, const MTL::NewDynamicLibraryCompletionHandler completionHandler)
{
    return Object::sendMessage<MTL4::CompilerTask*>(this, _MTL_PRIVATE_SEL(newDynamicLibraryWithURL_completionHandler_), url, completionHandler);
}

_MTL_INLINE MTL4::CompilerTask* MTL4::Compiler::newDynamicLibrary(const MTL::Library* pLibrary, const MTL::NewDynamicLibraryCompletionHandlerFunction& function)
{
    __block MTL::NewDynamicLibraryCompletionHandlerFunction blockFunction = function;
    return newDynamicLibrary(pLibrary, ^(MTL::DynamicLibrary* pLibraryRef, NS::Error* pError) { blockFunction(pLibraryRef, pError); });
}

_MTL_INLINE MTL4::CompilerTask* MTL4::Compiler::newDynamicLibrary(const NS::URL* pURL, const MTL::NewDynamicLibraryCompletionHandlerFunction& function)
{
    __block MTL::NewDynamicLibraryCompletionHandlerFunction blockFunction = function;
    return newDynamicLibrary(pURL, ^(MTL::DynamicLibrary* pLibrary, NS::Error* pError) { blockFunction(pLibrary, pError); });
}

_MTL_INLINE MTL::Library* MTL4::Compiler::newLibrary(const MTL4::LibraryDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL::Library*>(this, _MTL_PRIVATE_SEL(newLibraryWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE MTL4::CompilerTask* MTL4::Compiler::newLibrary(const MTL4::LibraryDescriptor* descriptor, const MTL::NewLibraryCompletionHandler completionHandler)
{
    return Object::sendMessage<MTL4::CompilerTask*>(this, _MTL_PRIVATE_SEL(newLibraryWithDescriptor_completionHandler_), descriptor, completionHandler);
}

_MTL_INLINE MTL4::CompilerTask* MTL4::Compiler::newLibrary(const MTL4::LibraryDescriptor* pDescriptor, const MTL::NewLibraryCompletionHandlerFunction& function)
{
    __block MTL::NewLibraryCompletionHandlerFunction blockFunction = function;
    return newLibrary(pDescriptor, ^(MTL::Library* pLibrary, NS::Error* pError) { blockFunction(pLibrary, pError); });
}

_MTL_INLINE MTL4::MachineLearningPipelineState* MTL4::Compiler::newMachineLearningPipelineState(const MTL4::MachineLearningPipelineDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL4::MachineLearningPipelineState*>(this, _MTL_PRIVATE_SEL(newMachineLearningPipelineStateWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE MTL4::CompilerTask* MTL4::Compiler::newMachineLearningPipelineState(const MTL4::MachineLearningPipelineDescriptor* descriptor, const MTL4::NewMachineLearningPipelineStateCompletionHandler completionHandler)
{
    return Object::sendMessage<MTL4::CompilerTask*>(this, _MTL_PRIVATE_SEL(newMachineLearningPipelineStateWithDescriptor_completionHandler_), descriptor, completionHandler);
}

_MTL_INLINE MTL4::CompilerTask* MTL4::Compiler::newMachineLearningPipelineState(const MTL4::MachineLearningPipelineDescriptor* pDescriptor, const MTL4::NewMachineLearningPipelineStateCompletionHandlerFunction& function)
{
    __block MTL4::NewMachineLearningPipelineStateCompletionHandlerFunction blockFunction = function;
    return newMachineLearningPipelineState(pDescriptor, ^(MTL4::MachineLearningPipelineState* pPipeline, NS::Error* pError) { blockFunction(pPipeline, pError); });
}

_MTL_INLINE MTL::RenderPipelineState* MTL4::Compiler::newRenderPipelineState(const MTL4::PipelineDescriptor* descriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, NS::Error** error)
{
    return Object::sendMessage<MTL::RenderPipelineState*>(this, _MTL_PRIVATE_SEL(newRenderPipelineStateWithDescriptor_compilerTaskOptions_error_), descriptor, compilerTaskOptions, error);
}

_MTL_INLINE MTL::RenderPipelineState* MTL4::Compiler::newRenderPipelineState(const MTL4::PipelineDescriptor* descriptor, const MTL4::RenderPipelineDynamicLinkingDescriptor* dynamicLinkingDescriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, NS::Error** error)
{
    return Object::sendMessage<MTL::RenderPipelineState*>(this, _MTL_PRIVATE_SEL(newRenderPipelineStateWithDescriptor_dynamicLinkingDescriptor_compilerTaskOptions_error_), descriptor, dynamicLinkingDescriptor, compilerTaskOptions, error);
}

_MTL_INLINE MTL4::CompilerTask* MTL4::Compiler::newRenderPipelineState(const MTL4::PipelineDescriptor* descriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, const MTL::NewRenderPipelineStateCompletionHandler completionHandler)
{
    return Object::sendMessage<MTL4::CompilerTask*>(this, _MTL_PRIVATE_SEL(newRenderPipelineStateWithDescriptor_compilerTaskOptions_completionHandler_), descriptor, compilerTaskOptions, completionHandler);
}

_MTL_INLINE MTL4::CompilerTask* MTL4::Compiler::newRenderPipelineState(const MTL4::PipelineDescriptor* descriptor, const MTL4::RenderPipelineDynamicLinkingDescriptor* dynamicLinkingDescriptor, const MTL4::CompilerTaskOptions* compilerTaskOptions, const MTL::NewRenderPipelineStateCompletionHandler completionHandler)
{
    return Object::sendMessage<MTL4::CompilerTask*>(this, _MTL_PRIVATE_SEL(newRenderPipelineStateWithDescriptor_dynamicLinkingDescriptor_compilerTaskOptions_completionHandler_), descriptor, dynamicLinkingDescriptor, compilerTaskOptions, completionHandler);
}

_MTL_INLINE MTL4::CompilerTask* MTL4::Compiler::newRenderPipelineState(const MTL4::PipelineDescriptor* pDescriptor, const MTL4::CompilerTaskOptions* options, const MTL4::NewRenderPipelineStateCompletionHandlerFunction& function)
{
    __block MTL4::NewRenderPipelineStateCompletionHandlerFunction blockFunction = function;
    return newRenderPipelineState(pDescriptor, options, ^(MTL::RenderPipelineState* pPipeline, NS::Error* pError) { blockFunction(pPipeline, pError); });
}

_MTL_INLINE MTL::RenderPipelineState* MTL4::Compiler::newRenderPipelineStateBySpecialization(const MTL4::PipelineDescriptor* descriptor, const MTL::RenderPipelineState* pipeline, NS::Error** error)
{
    return Object::sendMessage<MTL::RenderPipelineState*>(this, _MTL_PRIVATE_SEL(newRenderPipelineStateBySpecializationWithDescriptor_pipeline_error_), descriptor, pipeline, error);
}

_MTL_INLINE MTL4::CompilerTask* MTL4::Compiler::newRenderPipelineStateBySpecialization(const MTL4::PipelineDescriptor* descriptor, const MTL::RenderPipelineState* pipeline, const MTL::NewRenderPipelineStateCompletionHandler completionHandler)
{
    return Object::sendMessage<MTL4::CompilerTask*>(this, _MTL_PRIVATE_SEL(newRenderPipelineStateBySpecializationWithDescriptor_pipeline_completionHandler_), descriptor, pipeline, completionHandler);
}

_MTL_INLINE MTL4::CompilerTask* MTL4::Compiler::newRenderPipelineStateBySpecialization(const MTL4::PipelineDescriptor* pDescriptor, const MTL::RenderPipelineState* pPipeline, const MTL4::NewRenderPipelineStateCompletionHandlerFunction& function)
{
    __block MTL4::NewRenderPipelineStateCompletionHandlerFunction blockFunction = function;
    return newRenderPipelineStateBySpecialization(pDescriptor, pPipeline, ^(MTL::RenderPipelineState* pPipelineRef, NS::Error* pError) { blockFunction(pPipelineRef, pError); });
}

_MTL_INLINE MTL4::PipelineDataSetSerializer* MTL4::Compiler::pipelineDataSetSerializer() const
{
    return Object::sendMessage<MTL4::PipelineDataSetSerializer*>(this, _MTL_PRIVATE_SEL(pipelineDataSetSerializer));
}

#pragma once

namespace MTL4
{
class Compiler;
_MTL_ENUM(NS::Integer, CompilerTaskStatus) {
    CompilerTaskStatusNone = 0,
    CompilerTaskStatusScheduled = 1,
    CompilerTaskStatusCompiling = 2,
    CompilerTaskStatusFinished = 3,
};

class CompilerTask : public NS::Referencing<CompilerTask>
{
public:
    Compiler*          compiler() const;

    CompilerTaskStatus status() const;

    void               waitUntilCompleted();
};

}

_MTL_INLINE MTL4::Compiler* MTL4::CompilerTask::compiler() const
{
    return Object::sendMessage<MTL4::Compiler*>(this, _MTL_PRIVATE_SEL(compiler));
}

_MTL_INLINE MTL4::CompilerTaskStatus MTL4::CompilerTask::status() const
{
    return Object::sendMessage<MTL4::CompilerTaskStatus>(this, _MTL_PRIVATE_SEL(status));
}

_MTL_INLINE void MTL4::CompilerTask::waitUntilCompleted()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(waitUntilCompleted));
}

#pragma once

namespace MTL4
{
class LibraryDescriptor;
}

namespace MTL
{
class CompileOptions;
}

namespace MTL4
{
class LibraryDescriptor : public NS::Copying<LibraryDescriptor>
{
public:
    static LibraryDescriptor* alloc();

    LibraryDescriptor*        init();

    NS::String*               name() const;

    MTL::CompileOptions*      options() const;

    void                      setName(const NS::String* name);

    void                      setOptions(const MTL::CompileOptions* options);

    void                      setSource(const NS::String* source);
    NS::String*               source() const;
};

}
_MTL_INLINE MTL4::LibraryDescriptor* MTL4::LibraryDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::LibraryDescriptor>(_MTL_PRIVATE_CLS(MTL4LibraryDescriptor));
}

_MTL_INLINE MTL4::LibraryDescriptor* MTL4::LibraryDescriptor::init()
{
    return NS::Object::init<MTL4::LibraryDescriptor>();
}

_MTL_INLINE NS::String* MTL4::LibraryDescriptor::name() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(name));
}

_MTL_INLINE MTL::CompileOptions* MTL4::LibraryDescriptor::options() const
{
    return Object::sendMessage<MTL::CompileOptions*>(this, _MTL_PRIVATE_SEL(options));
}

_MTL_INLINE void MTL4::LibraryDescriptor::setName(const NS::String* name)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setName_), name);
}

_MTL_INLINE void MTL4::LibraryDescriptor::setOptions(const MTL::CompileOptions* options)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setOptions_), options);
}

_MTL_INLINE void MTL4::LibraryDescriptor::setSource(const NS::String* source)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSource_), source);
}

_MTL_INLINE NS::String* MTL4::LibraryDescriptor::source() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(source));
}

#pragma once

namespace MTL4
{
class FunctionDescriptor;

class FunctionDescriptor : public NS::Copying<FunctionDescriptor>
{
public:
    static FunctionDescriptor* alloc();

    FunctionDescriptor*        init();
};

}
_MTL_INLINE MTL4::FunctionDescriptor* MTL4::FunctionDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::FunctionDescriptor>(_MTL_PRIVATE_CLS(MTL4FunctionDescriptor));
}

_MTL_INLINE MTL4::FunctionDescriptor* MTL4::FunctionDescriptor::init()
{
    return NS::Object::init<MTL4::FunctionDescriptor>();
}

#pragma once

namespace MTL4
{
class LibraryFunctionDescriptor;
}

namespace MTL
{
class Library;
}

namespace MTL4
{
class LibraryFunctionDescriptor : public NS::Copying<LibraryFunctionDescriptor, FunctionDescriptor>
{
public:
    static LibraryFunctionDescriptor* alloc();

    LibraryFunctionDescriptor*        init();

    MTL::Library*                     library() const;

    NS::String*                       name() const;

    void                              setLibrary(const MTL::Library* library);

    void                              setName(const NS::String* name);
};

}
_MTL_INLINE MTL4::LibraryFunctionDescriptor* MTL4::LibraryFunctionDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::LibraryFunctionDescriptor>(_MTL_PRIVATE_CLS(MTL4LibraryFunctionDescriptor));
}

_MTL_INLINE MTL4::LibraryFunctionDescriptor* MTL4::LibraryFunctionDescriptor::init()
{
    return NS::Object::init<MTL4::LibraryFunctionDescriptor>();
}

_MTL_INLINE MTL::Library* MTL4::LibraryFunctionDescriptor::library() const
{
    return Object::sendMessage<MTL::Library*>(this, _MTL_PRIVATE_SEL(library));
}

_MTL_INLINE NS::String* MTL4::LibraryFunctionDescriptor::name() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(name));
}

_MTL_INLINE void MTL4::LibraryFunctionDescriptor::setLibrary(const MTL::Library* library)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLibrary_), library);
}

_MTL_INLINE void MTL4::LibraryFunctionDescriptor::setName(const NS::String* name)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setName_), name);
}

#pragma once

namespace MTL4
{
class FunctionDescriptor;
class SpecializedFunctionDescriptor;
}

namespace MTL
{
class FunctionConstantValues;
}

namespace MTL4
{
class SpecializedFunctionDescriptor : public NS::Copying<SpecializedFunctionDescriptor, FunctionDescriptor>
{
public:
    static SpecializedFunctionDescriptor* alloc();

    MTL::FunctionConstantValues*          constantValues() const;

    FunctionDescriptor*                   functionDescriptor() const;

    SpecializedFunctionDescriptor*        init();

    void                                  setConstantValues(const MTL::FunctionConstantValues* constantValues);

    void                                  setFunctionDescriptor(const MTL4::FunctionDescriptor* functionDescriptor);

    void                                  setSpecializedName(const NS::String* specializedName);
    NS::String*                           specializedName() const;
};

}
_MTL_INLINE MTL4::SpecializedFunctionDescriptor* MTL4::SpecializedFunctionDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::SpecializedFunctionDescriptor>(_MTL_PRIVATE_CLS(MTL4SpecializedFunctionDescriptor));
}

_MTL_INLINE MTL::FunctionConstantValues* MTL4::SpecializedFunctionDescriptor::constantValues() const
{
    return Object::sendMessage<MTL::FunctionConstantValues*>(this, _MTL_PRIVATE_SEL(constantValues));
}

_MTL_INLINE MTL4::FunctionDescriptor* MTL4::SpecializedFunctionDescriptor::functionDescriptor() const
{
    return Object::sendMessage<MTL4::FunctionDescriptor*>(this, _MTL_PRIVATE_SEL(functionDescriptor));
}

_MTL_INLINE MTL4::SpecializedFunctionDescriptor* MTL4::SpecializedFunctionDescriptor::init()
{
    return NS::Object::init<MTL4::SpecializedFunctionDescriptor>();
}

_MTL_INLINE void MTL4::SpecializedFunctionDescriptor::setConstantValues(const MTL::FunctionConstantValues* constantValues)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setConstantValues_), constantValues);
}

_MTL_INLINE void MTL4::SpecializedFunctionDescriptor::setFunctionDescriptor(const MTL4::FunctionDescriptor* functionDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFunctionDescriptor_), functionDescriptor);
}

_MTL_INLINE void MTL4::SpecializedFunctionDescriptor::setSpecializedName(const NS::String* specializedName)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSpecializedName_), specializedName);
}

_MTL_INLINE NS::String* MTL4::SpecializedFunctionDescriptor::specializedName() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(specializedName));
}

#pragma once

namespace MTL4
{
class StitchedFunctionDescriptor;
}

namespace MTL
{
class FunctionStitchingGraph;
}

namespace MTL4
{
class StitchedFunctionDescriptor : public NS::Copying<StitchedFunctionDescriptor, FunctionDescriptor>
{
public:
    static StitchedFunctionDescriptor* alloc();

    NS::Array*                         functionDescriptors() const;

    MTL::FunctionStitchingGraph*       functionGraph() const;

    StitchedFunctionDescriptor*        init();

    void                               setFunctionDescriptors(const NS::Array* functionDescriptors);

    void                               setFunctionGraph(const MTL::FunctionStitchingGraph* functionGraph);
};

}
_MTL_INLINE MTL4::StitchedFunctionDescriptor* MTL4::StitchedFunctionDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::StitchedFunctionDescriptor>(_MTL_PRIVATE_CLS(MTL4StitchedFunctionDescriptor));
}

_MTL_INLINE NS::Array* MTL4::StitchedFunctionDescriptor::functionDescriptors() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(functionDescriptors));
}

_MTL_INLINE MTL::FunctionStitchingGraph* MTL4::StitchedFunctionDescriptor::functionGraph() const
{
    return Object::sendMessage<MTL::FunctionStitchingGraph*>(this, _MTL_PRIVATE_SEL(functionGraph));
}

_MTL_INLINE MTL4::StitchedFunctionDescriptor* MTL4::StitchedFunctionDescriptor::init()
{
    return NS::Object::init<MTL4::StitchedFunctionDescriptor>();
}

_MTL_INLINE void MTL4::StitchedFunctionDescriptor::setFunctionDescriptors(const NS::Array* functionDescriptors)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFunctionDescriptors_), functionDescriptors);
}

_MTL_INLINE void MTL4::StitchedFunctionDescriptor::setFunctionGraph(const MTL::FunctionStitchingGraph* functionGraph)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFunctionGraph_), functionGraph);
}

#pragma once

namespace MTL4
{
class PipelineDescriptor;
class PipelineOptions;
_MTL_ENUM(NS::Integer, AlphaToOneState) {
    AlphaToOneStateDisabled = 0,
    AlphaToOneStateEnabled = 1,
};

_MTL_ENUM(NS::Integer, AlphaToCoverageState) {
    AlphaToCoverageStateDisabled = 0,
    AlphaToCoverageStateEnabled = 1,
};

_MTL_ENUM(NS::Integer, BlendState) {
    BlendStateDisabled = 0,
    BlendStateEnabled = 1,
    BlendStateUnspecialized = 2,
};

_MTL_ENUM(NS::Integer, IndirectCommandBufferSupportState) {
    IndirectCommandBufferSupportStateDisabled = 0,
    IndirectCommandBufferSupportStateEnabled = 1,
};

_MTL_OPTIONS(NS::UInteger, ShaderReflection) {
    ShaderReflectionNone = 0,
    ShaderReflectionBindingInfo = 1,
    ShaderReflectionBufferTypeInfo = 1 << 1,
};

class PipelineOptions : public NS::Copying<PipelineOptions>
{
public:
    static PipelineOptions* alloc();

    PipelineOptions*        init();

    void                    setShaderReflection(MTL4::ShaderReflection shaderReflection);

    void                    setShaderValidation(MTL::ShaderValidation shaderValidation);

    ShaderReflection        shaderReflection() const;

    MTL::ShaderValidation   shaderValidation() const;
};
class PipelineDescriptor : public NS::Copying<PipelineDescriptor>
{
public:
    static PipelineDescriptor* alloc();

    PipelineDescriptor*        init();

    NS::String*                label() const;

    PipelineOptions*           options() const;

    void                       setLabel(const NS::String* label);

    void                       setOptions(const MTL4::PipelineOptions* options);
};

}
_MTL_INLINE MTL4::PipelineOptions* MTL4::PipelineOptions::alloc()
{
    return NS::Object::alloc<MTL4::PipelineOptions>(_MTL_PRIVATE_CLS(MTL4PipelineOptions));
}

_MTL_INLINE MTL4::PipelineOptions* MTL4::PipelineOptions::init()
{
    return NS::Object::init<MTL4::PipelineOptions>();
}

_MTL_INLINE void MTL4::PipelineOptions::setShaderReflection(MTL4::ShaderReflection shaderReflection)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setShaderReflection_), shaderReflection);
}

_MTL_INLINE void MTL4::PipelineOptions::setShaderValidation(MTL::ShaderValidation shaderValidation)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setShaderValidation_), shaderValidation);
}

_MTL_INLINE MTL4::ShaderReflection MTL4::PipelineOptions::shaderReflection() const
{
    return Object::sendMessage<MTL4::ShaderReflection>(this, _MTL_PRIVATE_SEL(shaderReflection));
}

_MTL_INLINE MTL::ShaderValidation MTL4::PipelineOptions::shaderValidation() const
{
    return Object::sendMessage<MTL::ShaderValidation>(this, _MTL_PRIVATE_SEL(shaderValidation));
}

_MTL_INLINE MTL4::PipelineDescriptor* MTL4::PipelineDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::PipelineDescriptor>(_MTL_PRIVATE_CLS(MTL4PipelineDescriptor));
}

_MTL_INLINE MTL4::PipelineDescriptor* MTL4::PipelineDescriptor::init()
{
    return NS::Object::init<MTL4::PipelineDescriptor>();
}

_MTL_INLINE NS::String* MTL4::PipelineDescriptor::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE MTL4::PipelineOptions* MTL4::PipelineDescriptor::options() const
{
    return Object::sendMessage<MTL4::PipelineOptions*>(this, _MTL_PRIVATE_SEL(options));
}

_MTL_INLINE void MTL4::PipelineDescriptor::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE void MTL4::PipelineDescriptor::setOptions(const MTL4::PipelineOptions* options)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setOptions_), options);
}

#pragma once

namespace MTL4
{
class ComputePipelineDescriptor;
class FunctionDescriptor;
class StaticLinkingDescriptor;

class ComputePipelineDescriptor : public NS::Copying<ComputePipelineDescriptor, PipelineDescriptor>
{
public:
    static ComputePipelineDescriptor* alloc();

    FunctionDescriptor*               computeFunctionDescriptor() const;

    ComputePipelineDescriptor*        init();

    NS::UInteger                      maxTotalThreadsPerThreadgroup() const;

    MTL::Size                         requiredThreadsPerThreadgroup() const;

    void                              reset();

    void                              setComputeFunctionDescriptor(const MTL4::FunctionDescriptor* computeFunctionDescriptor);

    void                              setMaxTotalThreadsPerThreadgroup(NS::UInteger maxTotalThreadsPerThreadgroup);

    void                              setRequiredThreadsPerThreadgroup(MTL::Size requiredThreadsPerThreadgroup);

    void                              setStaticLinkingDescriptor(const MTL4::StaticLinkingDescriptor* staticLinkingDescriptor);

    void                              setSupportBinaryLinking(bool supportBinaryLinking);

    void                              setSupportIndirectCommandBuffers(MTL4::IndirectCommandBufferSupportState supportIndirectCommandBuffers);

    void                              setThreadGroupSizeIsMultipleOfThreadExecutionWidth(bool threadGroupSizeIsMultipleOfThreadExecutionWidth);

    StaticLinkingDescriptor*          staticLinkingDescriptor() const;

    bool                              supportBinaryLinking() const;

    IndirectCommandBufferSupportState supportIndirectCommandBuffers() const;

    bool                              threadGroupSizeIsMultipleOfThreadExecutionWidth() const;
};

}
_MTL_INLINE MTL4::ComputePipelineDescriptor* MTL4::ComputePipelineDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::ComputePipelineDescriptor>(_MTL_PRIVATE_CLS(MTL4ComputePipelineDescriptor));
}

_MTL_INLINE MTL4::FunctionDescriptor* MTL4::ComputePipelineDescriptor::computeFunctionDescriptor() const
{
    return Object::sendMessage<MTL4::FunctionDescriptor*>(this, _MTL_PRIVATE_SEL(computeFunctionDescriptor));
}

_MTL_INLINE MTL4::ComputePipelineDescriptor* MTL4::ComputePipelineDescriptor::init()
{
    return NS::Object::init<MTL4::ComputePipelineDescriptor>();
}

_MTL_INLINE NS::UInteger MTL4::ComputePipelineDescriptor::maxTotalThreadsPerThreadgroup() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxTotalThreadsPerThreadgroup));
}

_MTL_INLINE MTL::Size MTL4::ComputePipelineDescriptor::requiredThreadsPerThreadgroup() const
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(requiredThreadsPerThreadgroup));
}

_MTL_INLINE void MTL4::ComputePipelineDescriptor::reset()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(reset));
}

_MTL_INLINE void MTL4::ComputePipelineDescriptor::setComputeFunctionDescriptor(const MTL4::FunctionDescriptor* computeFunctionDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setComputeFunctionDescriptor_), computeFunctionDescriptor);
}

_MTL_INLINE void MTL4::ComputePipelineDescriptor::setMaxTotalThreadsPerThreadgroup(NS::UInteger maxTotalThreadsPerThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxTotalThreadsPerThreadgroup_), maxTotalThreadsPerThreadgroup);
}

_MTL_INLINE void MTL4::ComputePipelineDescriptor::setRequiredThreadsPerThreadgroup(MTL::Size requiredThreadsPerThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRequiredThreadsPerThreadgroup_), requiredThreadsPerThreadgroup);
}

_MTL_INLINE void MTL4::ComputePipelineDescriptor::setStaticLinkingDescriptor(const MTL4::StaticLinkingDescriptor* staticLinkingDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStaticLinkingDescriptor_), staticLinkingDescriptor);
}

_MTL_INLINE void MTL4::ComputePipelineDescriptor::setSupportBinaryLinking(bool supportBinaryLinking)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportBinaryLinking_), supportBinaryLinking);
}

_MTL_INLINE void MTL4::ComputePipelineDescriptor::setSupportIndirectCommandBuffers(MTL4::IndirectCommandBufferSupportState supportIndirectCommandBuffers)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportIndirectCommandBuffers_), supportIndirectCommandBuffers);
}

_MTL_INLINE void MTL4::ComputePipelineDescriptor::setThreadGroupSizeIsMultipleOfThreadExecutionWidth(bool threadGroupSizeIsMultipleOfThreadExecutionWidth)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setThreadGroupSizeIsMultipleOfThreadExecutionWidth_), threadGroupSizeIsMultipleOfThreadExecutionWidth);
}

_MTL_INLINE MTL4::StaticLinkingDescriptor* MTL4::ComputePipelineDescriptor::staticLinkingDescriptor() const
{
    return Object::sendMessage<MTL4::StaticLinkingDescriptor*>(this, _MTL_PRIVATE_SEL(staticLinkingDescriptor));
}

_MTL_INLINE bool MTL4::ComputePipelineDescriptor::supportBinaryLinking() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportBinaryLinking));
}

_MTL_INLINE MTL4::IndirectCommandBufferSupportState MTL4::ComputePipelineDescriptor::supportIndirectCommandBuffers() const
{
    return Object::sendMessage<MTL4::IndirectCommandBufferSupportState>(this, _MTL_PRIVATE_SEL(supportIndirectCommandBuffers));
}

_MTL_INLINE bool MTL4::ComputePipelineDescriptor::threadGroupSizeIsMultipleOfThreadExecutionWidth() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(threadGroupSizeIsMultipleOfThreadExecutionWidth));
}

#pragma once

namespace MTL4
{
class FunctionDescriptor;
class RenderPipelineBinaryFunctionsDescriptor;
class RenderPipelineColorAttachmentDescriptor;
class RenderPipelineColorAttachmentDescriptorArray;
class RenderPipelineDescriptor;
class StaticLinkingDescriptor;
}

namespace MTL
{
class VertexDescriptor;
}

namespace MTL4
{
_MTL_ENUM(NS::Integer, LogicalToPhysicalColorAttachmentMappingState) {
    LogicalToPhysicalColorAttachmentMappingStateIdentity = 0,
    LogicalToPhysicalColorAttachmentMappingStateInherited = 1,
};

class RenderPipelineColorAttachmentDescriptor : public NS::Copying<RenderPipelineColorAttachmentDescriptor>
{
public:
    static RenderPipelineColorAttachmentDescriptor* alloc();

    MTL::BlendOperation                             alphaBlendOperation() const;

    BlendState                                      blendingState() const;

    MTL::BlendFactor                                destinationAlphaBlendFactor() const;

    MTL::BlendFactor                                destinationRGBBlendFactor() const;

    RenderPipelineColorAttachmentDescriptor*        init();

    MTL::PixelFormat                                pixelFormat() const;

    void                                            reset();

    MTL::BlendOperation                             rgbBlendOperation() const;

    void                                            setAlphaBlendOperation(MTL::BlendOperation alphaBlendOperation);

    void                                            setBlendingState(MTL4::BlendState blendingState);

    void                                            setDestinationAlphaBlendFactor(MTL::BlendFactor destinationAlphaBlendFactor);

    void                                            setDestinationRGBBlendFactor(MTL::BlendFactor destinationRGBBlendFactor);

    void                                            setPixelFormat(MTL::PixelFormat pixelFormat);

    void                                            setRgbBlendOperation(MTL::BlendOperation rgbBlendOperation);

    void                                            setSourceAlphaBlendFactor(MTL::BlendFactor sourceAlphaBlendFactor);

    void                                            setSourceRGBBlendFactor(MTL::BlendFactor sourceRGBBlendFactor);

    void                                            setWriteMask(MTL::ColorWriteMask writeMask);

    MTL::BlendFactor                                sourceAlphaBlendFactor() const;

    MTL::BlendFactor                                sourceRGBBlendFactor() const;

    MTL::ColorWriteMask                             writeMask() const;
};

class RenderPipelineColorAttachmentDescriptorArray : public NS::Copying<RenderPipelineColorAttachmentDescriptorArray>
{
public:
    static RenderPipelineColorAttachmentDescriptorArray* alloc();

    RenderPipelineColorAttachmentDescriptorArray*        init();

    RenderPipelineColorAttachmentDescriptor*             object(NS::UInteger attachmentIndex);

    void                                                 reset();

    void                                                 setObject(const MTL4::RenderPipelineColorAttachmentDescriptor* attachment, NS::UInteger attachmentIndex);
};

class RenderPipelineBinaryFunctionsDescriptor : public NS::Copying<RenderPipelineBinaryFunctionsDescriptor>
{
public:
    static RenderPipelineBinaryFunctionsDescriptor* alloc();

    NS::Array*                                      fragmentAdditionalBinaryFunctions() const;

    RenderPipelineBinaryFunctionsDescriptor*        init();

    NS::Array*                                      meshAdditionalBinaryFunctions() const;

    NS::Array*                                      objectAdditionalBinaryFunctions() const;

    void                                            reset();

    void                                            setFragmentAdditionalBinaryFunctions(const NS::Array* fragmentAdditionalBinaryFunctions);

    void                                            setMeshAdditionalBinaryFunctions(const NS::Array* meshAdditionalBinaryFunctions);

    void                                            setObjectAdditionalBinaryFunctions(const NS::Array* objectAdditionalBinaryFunctions);

    void                                            setTileAdditionalBinaryFunctions(const NS::Array* tileAdditionalBinaryFunctions);

    void                                            setVertexAdditionalBinaryFunctions(const NS::Array* vertexAdditionalBinaryFunctions);

    NS::Array*                                      tileAdditionalBinaryFunctions() const;

    NS::Array*                                      vertexAdditionalBinaryFunctions() const;
};

class RenderPipelineDescriptor : public NS::Copying<RenderPipelineDescriptor, PipelineDescriptor>
{
public:
    static RenderPipelineDescriptor*              alloc();

    AlphaToCoverageState                          alphaToCoverageState() const;

    AlphaToOneState                               alphaToOneState() const;

    LogicalToPhysicalColorAttachmentMappingState  colorAttachmentMappingState() const;

    RenderPipelineColorAttachmentDescriptorArray* colorAttachments() const;

    FunctionDescriptor*                           fragmentFunctionDescriptor() const;

    StaticLinkingDescriptor*                      fragmentStaticLinkingDescriptor() const;

    RenderPipelineDescriptor*                     init();

    MTL::PrimitiveTopologyClass                   inputPrimitiveTopology() const;

    bool                                          isRasterizationEnabled() const;

    NS::UInteger                                  maxVertexAmplificationCount() const;

    NS::UInteger                                  rasterSampleCount() const;

    [[deprecated("please use isRasterizationEnabled instead")]]
    bool                              rasterizationEnabled() const;

    void                              reset();

    void                              setAlphaToCoverageState(MTL4::AlphaToCoverageState alphaToCoverageState);

    void                              setAlphaToOneState(MTL4::AlphaToOneState alphaToOneState);

    void                              setColorAttachmentMappingState(MTL4::LogicalToPhysicalColorAttachmentMappingState colorAttachmentMappingState);

    void                              setFragmentFunctionDescriptor(const MTL4::FunctionDescriptor* fragmentFunctionDescriptor);

    void                              setFragmentStaticLinkingDescriptor(const MTL4::StaticLinkingDescriptor* fragmentStaticLinkingDescriptor);

    void                              setInputPrimitiveTopology(MTL::PrimitiveTopologyClass inputPrimitiveTopology);

    void                              setMaxVertexAmplificationCount(NS::UInteger maxVertexAmplificationCount);

    void                              setRasterSampleCount(NS::UInteger rasterSampleCount);

    void                              setRasterizationEnabled(bool rasterizationEnabled);

    void                              setSupportFragmentBinaryLinking(bool supportFragmentBinaryLinking);

    void                              setSupportIndirectCommandBuffers(MTL4::IndirectCommandBufferSupportState supportIndirectCommandBuffers);

    void                              setSupportVertexBinaryLinking(bool supportVertexBinaryLinking);

    void                              setVertexDescriptor(const MTL::VertexDescriptor* vertexDescriptor);

    void                              setVertexFunctionDescriptor(const MTL4::FunctionDescriptor* vertexFunctionDescriptor);

    void                              setVertexStaticLinkingDescriptor(const MTL4::StaticLinkingDescriptor* vertexStaticLinkingDescriptor);

    bool                              supportFragmentBinaryLinking() const;

    IndirectCommandBufferSupportState supportIndirectCommandBuffers() const;

    bool                              supportVertexBinaryLinking() const;

    MTL::VertexDescriptor*            vertexDescriptor() const;

    FunctionDescriptor*               vertexFunctionDescriptor() const;

    StaticLinkingDescriptor*          vertexStaticLinkingDescriptor() const;
};

}
_MTL_INLINE MTL4::RenderPipelineColorAttachmentDescriptor* MTL4::RenderPipelineColorAttachmentDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::RenderPipelineColorAttachmentDescriptor>(_MTL_PRIVATE_CLS(MTL4RenderPipelineColorAttachmentDescriptor));
}

_MTL_INLINE MTL::BlendOperation MTL4::RenderPipelineColorAttachmentDescriptor::alphaBlendOperation() const
{
    return Object::sendMessage<MTL::BlendOperation>(this, _MTL_PRIVATE_SEL(alphaBlendOperation));
}

_MTL_INLINE MTL4::BlendState MTL4::RenderPipelineColorAttachmentDescriptor::blendingState() const
{
    return Object::sendMessage<MTL4::BlendState>(this, _MTL_PRIVATE_SEL(blendingState));
}

_MTL_INLINE MTL::BlendFactor MTL4::RenderPipelineColorAttachmentDescriptor::destinationAlphaBlendFactor() const
{
    return Object::sendMessage<MTL::BlendFactor>(this, _MTL_PRIVATE_SEL(destinationAlphaBlendFactor));
}

_MTL_INLINE MTL::BlendFactor MTL4::RenderPipelineColorAttachmentDescriptor::destinationRGBBlendFactor() const
{
    return Object::sendMessage<MTL::BlendFactor>(this, _MTL_PRIVATE_SEL(destinationRGBBlendFactor));
}

_MTL_INLINE MTL4::RenderPipelineColorAttachmentDescriptor* MTL4::RenderPipelineColorAttachmentDescriptor::init()
{
    return NS::Object::init<MTL4::RenderPipelineColorAttachmentDescriptor>();
}

_MTL_INLINE MTL::PixelFormat MTL4::RenderPipelineColorAttachmentDescriptor::pixelFormat() const
{
    return Object::sendMessage<MTL::PixelFormat>(this, _MTL_PRIVATE_SEL(pixelFormat));
}

_MTL_INLINE void MTL4::RenderPipelineColorAttachmentDescriptor::reset()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(reset));
}

_MTL_INLINE MTL::BlendOperation MTL4::RenderPipelineColorAttachmentDescriptor::rgbBlendOperation() const
{
    return Object::sendMessage<MTL::BlendOperation>(this, _MTL_PRIVATE_SEL(rgbBlendOperation));
}

_MTL_INLINE void MTL4::RenderPipelineColorAttachmentDescriptor::setAlphaBlendOperation(MTL::BlendOperation alphaBlendOperation)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setAlphaBlendOperation_), alphaBlendOperation);
}

_MTL_INLINE void MTL4::RenderPipelineColorAttachmentDescriptor::setBlendingState(MTL4::BlendState blendingState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBlendingState_), blendingState);
}

_MTL_INLINE void MTL4::RenderPipelineColorAttachmentDescriptor::setDestinationAlphaBlendFactor(MTL::BlendFactor destinationAlphaBlendFactor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDestinationAlphaBlendFactor_), destinationAlphaBlendFactor);
}

_MTL_INLINE void MTL4::RenderPipelineColorAttachmentDescriptor::setDestinationRGBBlendFactor(MTL::BlendFactor destinationRGBBlendFactor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setDestinationRGBBlendFactor_), destinationRGBBlendFactor);
}

_MTL_INLINE void MTL4::RenderPipelineColorAttachmentDescriptor::setPixelFormat(MTL::PixelFormat pixelFormat)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPixelFormat_), pixelFormat);
}

_MTL_INLINE void MTL4::RenderPipelineColorAttachmentDescriptor::setRgbBlendOperation(MTL::BlendOperation rgbBlendOperation)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRgbBlendOperation_), rgbBlendOperation);
}

_MTL_INLINE void MTL4::RenderPipelineColorAttachmentDescriptor::setSourceAlphaBlendFactor(MTL::BlendFactor sourceAlphaBlendFactor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSourceAlphaBlendFactor_), sourceAlphaBlendFactor);
}

_MTL_INLINE void MTL4::RenderPipelineColorAttachmentDescriptor::setSourceRGBBlendFactor(MTL::BlendFactor sourceRGBBlendFactor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSourceRGBBlendFactor_), sourceRGBBlendFactor);
}

_MTL_INLINE void MTL4::RenderPipelineColorAttachmentDescriptor::setWriteMask(MTL::ColorWriteMask writeMask)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setWriteMask_), writeMask);
}

_MTL_INLINE MTL::BlendFactor MTL4::RenderPipelineColorAttachmentDescriptor::sourceAlphaBlendFactor() const
{
    return Object::sendMessage<MTL::BlendFactor>(this, _MTL_PRIVATE_SEL(sourceAlphaBlendFactor));
}

_MTL_INLINE MTL::BlendFactor MTL4::RenderPipelineColorAttachmentDescriptor::sourceRGBBlendFactor() const
{
    return Object::sendMessage<MTL::BlendFactor>(this, _MTL_PRIVATE_SEL(sourceRGBBlendFactor));
}

_MTL_INLINE MTL::ColorWriteMask MTL4::RenderPipelineColorAttachmentDescriptor::writeMask() const
{
    return Object::sendMessage<MTL::ColorWriteMask>(this, _MTL_PRIVATE_SEL(writeMask));
}

_MTL_INLINE MTL4::RenderPipelineColorAttachmentDescriptorArray* MTL4::RenderPipelineColorAttachmentDescriptorArray::alloc()
{
    return NS::Object::alloc<MTL4::RenderPipelineColorAttachmentDescriptorArray>(_MTL_PRIVATE_CLS(MTL4RenderPipelineColorAttachmentDescriptorArray));
}

_MTL_INLINE MTL4::RenderPipelineColorAttachmentDescriptorArray* MTL4::RenderPipelineColorAttachmentDescriptorArray::init()
{
    return NS::Object::init<MTL4::RenderPipelineColorAttachmentDescriptorArray>();
}

_MTL_INLINE MTL4::RenderPipelineColorAttachmentDescriptor* MTL4::RenderPipelineColorAttachmentDescriptorArray::object(NS::UInteger attachmentIndex)
{
    return Object::sendMessage<MTL4::RenderPipelineColorAttachmentDescriptor*>(this, _MTL_PRIVATE_SEL(objectAtIndexedSubscript_), attachmentIndex);
}

_MTL_INLINE void MTL4::RenderPipelineColorAttachmentDescriptorArray::reset()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(reset));
}

_MTL_INLINE void MTL4::RenderPipelineColorAttachmentDescriptorArray::setObject(const MTL4::RenderPipelineColorAttachmentDescriptor* attachment, NS::UInteger attachmentIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObject_atIndexedSubscript_), attachment, attachmentIndex);
}

_MTL_INLINE MTL4::RenderPipelineBinaryFunctionsDescriptor* MTL4::RenderPipelineBinaryFunctionsDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::RenderPipelineBinaryFunctionsDescriptor>(_MTL_PRIVATE_CLS(MTL4RenderPipelineBinaryFunctionsDescriptor));
}

_MTL_INLINE NS::Array* MTL4::RenderPipelineBinaryFunctionsDescriptor::fragmentAdditionalBinaryFunctions() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(fragmentAdditionalBinaryFunctions));
}

_MTL_INLINE MTL4::RenderPipelineBinaryFunctionsDescriptor* MTL4::RenderPipelineBinaryFunctionsDescriptor::init()
{
    return NS::Object::init<MTL4::RenderPipelineBinaryFunctionsDescriptor>();
}

_MTL_INLINE NS::Array* MTL4::RenderPipelineBinaryFunctionsDescriptor::meshAdditionalBinaryFunctions() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(meshAdditionalBinaryFunctions));
}

_MTL_INLINE NS::Array* MTL4::RenderPipelineBinaryFunctionsDescriptor::objectAdditionalBinaryFunctions() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(objectAdditionalBinaryFunctions));
}

_MTL_INLINE void MTL4::RenderPipelineBinaryFunctionsDescriptor::reset()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(reset));
}

_MTL_INLINE void MTL4::RenderPipelineBinaryFunctionsDescriptor::setFragmentAdditionalBinaryFunctions(const NS::Array* fragmentAdditionalBinaryFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentAdditionalBinaryFunctions_), fragmentAdditionalBinaryFunctions);
}

_MTL_INLINE void MTL4::RenderPipelineBinaryFunctionsDescriptor::setMeshAdditionalBinaryFunctions(const NS::Array* meshAdditionalBinaryFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMeshAdditionalBinaryFunctions_), meshAdditionalBinaryFunctions);
}

_MTL_INLINE void MTL4::RenderPipelineBinaryFunctionsDescriptor::setObjectAdditionalBinaryFunctions(const NS::Array* objectAdditionalBinaryFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectAdditionalBinaryFunctions_), objectAdditionalBinaryFunctions);
}

_MTL_INLINE void MTL4::RenderPipelineBinaryFunctionsDescriptor::setTileAdditionalBinaryFunctions(const NS::Array* tileAdditionalBinaryFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileAdditionalBinaryFunctions_), tileAdditionalBinaryFunctions);
}

_MTL_INLINE void MTL4::RenderPipelineBinaryFunctionsDescriptor::setVertexAdditionalBinaryFunctions(const NS::Array* vertexAdditionalBinaryFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexAdditionalBinaryFunctions_), vertexAdditionalBinaryFunctions);
}

_MTL_INLINE NS::Array* MTL4::RenderPipelineBinaryFunctionsDescriptor::tileAdditionalBinaryFunctions() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(tileAdditionalBinaryFunctions));
}

_MTL_INLINE NS::Array* MTL4::RenderPipelineBinaryFunctionsDescriptor::vertexAdditionalBinaryFunctions() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(vertexAdditionalBinaryFunctions));
}

_MTL_INLINE MTL4::RenderPipelineDescriptor* MTL4::RenderPipelineDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::RenderPipelineDescriptor>(_MTL_PRIVATE_CLS(MTL4RenderPipelineDescriptor));
}

_MTL_INLINE MTL4::AlphaToCoverageState MTL4::RenderPipelineDescriptor::alphaToCoverageState() const
{
    return Object::sendMessage<MTL4::AlphaToCoverageState>(this, _MTL_PRIVATE_SEL(alphaToCoverageState));
}

_MTL_INLINE MTL4::AlphaToOneState MTL4::RenderPipelineDescriptor::alphaToOneState() const
{
    return Object::sendMessage<MTL4::AlphaToOneState>(this, _MTL_PRIVATE_SEL(alphaToOneState));
}

_MTL_INLINE MTL4::LogicalToPhysicalColorAttachmentMappingState MTL4::RenderPipelineDescriptor::colorAttachmentMappingState() const
{
    return Object::sendMessage<MTL4::LogicalToPhysicalColorAttachmentMappingState>(this, _MTL_PRIVATE_SEL(colorAttachmentMappingState));
}

_MTL_INLINE MTL4::RenderPipelineColorAttachmentDescriptorArray* MTL4::RenderPipelineDescriptor::colorAttachments() const
{
    return Object::sendMessage<MTL4::RenderPipelineColorAttachmentDescriptorArray*>(this, _MTL_PRIVATE_SEL(colorAttachments));
}

_MTL_INLINE MTL4::FunctionDescriptor* MTL4::RenderPipelineDescriptor::fragmentFunctionDescriptor() const
{
    return Object::sendMessage<MTL4::FunctionDescriptor*>(this, _MTL_PRIVATE_SEL(fragmentFunctionDescriptor));
}

_MTL_INLINE MTL4::StaticLinkingDescriptor* MTL4::RenderPipelineDescriptor::fragmentStaticLinkingDescriptor() const
{
    return Object::sendMessage<MTL4::StaticLinkingDescriptor*>(this, _MTL_PRIVATE_SEL(fragmentStaticLinkingDescriptor));
}

_MTL_INLINE MTL4::RenderPipelineDescriptor* MTL4::RenderPipelineDescriptor::init()
{
    return NS::Object::init<MTL4::RenderPipelineDescriptor>();
}

_MTL_INLINE MTL::PrimitiveTopologyClass MTL4::RenderPipelineDescriptor::inputPrimitiveTopology() const
{
    return Object::sendMessage<MTL::PrimitiveTopologyClass>(this, _MTL_PRIVATE_SEL(inputPrimitiveTopology));
}

_MTL_INLINE bool MTL4::RenderPipelineDescriptor::isRasterizationEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isRasterizationEnabled));
}

_MTL_INLINE NS::UInteger MTL4::RenderPipelineDescriptor::maxVertexAmplificationCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxVertexAmplificationCount));
}

_MTL_INLINE NS::UInteger MTL4::RenderPipelineDescriptor::rasterSampleCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(rasterSampleCount));
}

_MTL_INLINE bool MTL4::RenderPipelineDescriptor::rasterizationEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isRasterizationEnabled));
}

_MTL_INLINE void MTL4::RenderPipelineDescriptor::reset()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(reset));
}

_MTL_INLINE void MTL4::RenderPipelineDescriptor::setAlphaToCoverageState(MTL4::AlphaToCoverageState alphaToCoverageState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setAlphaToCoverageState_), alphaToCoverageState);
}

_MTL_INLINE void MTL4::RenderPipelineDescriptor::setAlphaToOneState(MTL4::AlphaToOneState alphaToOneState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setAlphaToOneState_), alphaToOneState);
}

_MTL_INLINE void MTL4::RenderPipelineDescriptor::setColorAttachmentMappingState(MTL4::LogicalToPhysicalColorAttachmentMappingState colorAttachmentMappingState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setColorAttachmentMappingState_), colorAttachmentMappingState);
}

_MTL_INLINE void MTL4::RenderPipelineDescriptor::setFragmentFunctionDescriptor(const MTL4::FunctionDescriptor* fragmentFunctionDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentFunctionDescriptor_), fragmentFunctionDescriptor);
}

_MTL_INLINE void MTL4::RenderPipelineDescriptor::setFragmentStaticLinkingDescriptor(const MTL4::StaticLinkingDescriptor* fragmentStaticLinkingDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentStaticLinkingDescriptor_), fragmentStaticLinkingDescriptor);
}

_MTL_INLINE void MTL4::RenderPipelineDescriptor::setInputPrimitiveTopology(MTL::PrimitiveTopologyClass inputPrimitiveTopology)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInputPrimitiveTopology_), inputPrimitiveTopology);
}

_MTL_INLINE void MTL4::RenderPipelineDescriptor::setMaxVertexAmplificationCount(NS::UInteger maxVertexAmplificationCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxVertexAmplificationCount_), maxVertexAmplificationCount);
}

_MTL_INLINE void MTL4::RenderPipelineDescriptor::setRasterSampleCount(NS::UInteger rasterSampleCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRasterSampleCount_), rasterSampleCount);
}

_MTL_INLINE void MTL4::RenderPipelineDescriptor::setRasterizationEnabled(bool rasterizationEnabled)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRasterizationEnabled_), rasterizationEnabled);
}

_MTL_INLINE void MTL4::RenderPipelineDescriptor::setSupportFragmentBinaryLinking(bool supportFragmentBinaryLinking)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportFragmentBinaryLinking_), supportFragmentBinaryLinking);
}

_MTL_INLINE void MTL4::RenderPipelineDescriptor::setSupportIndirectCommandBuffers(MTL4::IndirectCommandBufferSupportState supportIndirectCommandBuffers)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportIndirectCommandBuffers_), supportIndirectCommandBuffers);
}

_MTL_INLINE void MTL4::RenderPipelineDescriptor::setSupportVertexBinaryLinking(bool supportVertexBinaryLinking)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportVertexBinaryLinking_), supportVertexBinaryLinking);
}

_MTL_INLINE void MTL4::RenderPipelineDescriptor::setVertexDescriptor(const MTL::VertexDescriptor* vertexDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexDescriptor_), vertexDescriptor);
}

_MTL_INLINE void MTL4::RenderPipelineDescriptor::setVertexFunctionDescriptor(const MTL4::FunctionDescriptor* vertexFunctionDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexFunctionDescriptor_), vertexFunctionDescriptor);
}

_MTL_INLINE void MTL4::RenderPipelineDescriptor::setVertexStaticLinkingDescriptor(const MTL4::StaticLinkingDescriptor* vertexStaticLinkingDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setVertexStaticLinkingDescriptor_), vertexStaticLinkingDescriptor);
}

_MTL_INLINE bool MTL4::RenderPipelineDescriptor::supportFragmentBinaryLinking() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportFragmentBinaryLinking));
}

_MTL_INLINE MTL4::IndirectCommandBufferSupportState MTL4::RenderPipelineDescriptor::supportIndirectCommandBuffers() const
{
    return Object::sendMessage<MTL4::IndirectCommandBufferSupportState>(this, _MTL_PRIVATE_SEL(supportIndirectCommandBuffers));
}

_MTL_INLINE bool MTL4::RenderPipelineDescriptor::supportVertexBinaryLinking() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportVertexBinaryLinking));
}

_MTL_INLINE MTL::VertexDescriptor* MTL4::RenderPipelineDescriptor::vertexDescriptor() const
{
    return Object::sendMessage<MTL::VertexDescriptor*>(this, _MTL_PRIVATE_SEL(vertexDescriptor));
}

_MTL_INLINE MTL4::FunctionDescriptor* MTL4::RenderPipelineDescriptor::vertexFunctionDescriptor() const
{
    return Object::sendMessage<MTL4::FunctionDescriptor*>(this, _MTL_PRIVATE_SEL(vertexFunctionDescriptor));
}

_MTL_INLINE MTL4::StaticLinkingDescriptor* MTL4::RenderPipelineDescriptor::vertexStaticLinkingDescriptor() const
{
    return Object::sendMessage<MTL4::StaticLinkingDescriptor*>(this, _MTL_PRIVATE_SEL(vertexStaticLinkingDescriptor));
}

#pragma once

namespace MTL4
{
class FunctionDescriptor;
class MachineLearningPipelineDescriptor;
class MachineLearningPipelineReflection;
}

namespace MTL
{
class Device;
class TensorExtents;
}

namespace MTL4
{
class MachineLearningPipelineDescriptor : public NS::Copying<MachineLearningPipelineDescriptor, PipelineDescriptor>
{
public:
    static MachineLearningPipelineDescriptor* alloc();

    MachineLearningPipelineDescriptor*        init();

    MTL::TensorExtents*                       inputDimensionsAtBufferIndex(NS::Integer bufferIndex);

    NS::String*                               label() const;

    FunctionDescriptor*                       machineLearningFunctionDescriptor() const;

    void                                      reset();

    void                                      setInputDimensions(const MTL::TensorExtents* dimensions, NS::Integer bufferIndex);
    void                                      setInputDimensions(const NS::Array* dimensions, NS::Range range);

    void                                      setLabel(const NS::String* label);

    void                                      setMachineLearningFunctionDescriptor(const MTL4::FunctionDescriptor* machineLearningFunctionDescriptor);
};
class MachineLearningPipelineReflection : public NS::Referencing<MachineLearningPipelineReflection>
{
public:
    static MachineLearningPipelineReflection* alloc();

    NS::Array*                                bindings() const;

    MachineLearningPipelineReflection*        init();
};
class MachineLearningPipelineState : public NS::Referencing<MachineLearningPipelineState, MTL::Allocation>
{
public:
    MTL::Device*                       device() const;

    NS::UInteger                       intermediatesHeapSize() const;

    NS::String*                        label() const;

    MachineLearningPipelineReflection* reflection() const;
};

}
_MTL_INLINE MTL4::MachineLearningPipelineDescriptor* MTL4::MachineLearningPipelineDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::MachineLearningPipelineDescriptor>(_MTL_PRIVATE_CLS(MTL4MachineLearningPipelineDescriptor));
}

_MTL_INLINE MTL4::MachineLearningPipelineDescriptor* MTL4::MachineLearningPipelineDescriptor::init()
{
    return NS::Object::init<MTL4::MachineLearningPipelineDescriptor>();
}

_MTL_INLINE MTL::TensorExtents* MTL4::MachineLearningPipelineDescriptor::inputDimensionsAtBufferIndex(NS::Integer bufferIndex)
{
    return Object::sendMessage<MTL::TensorExtents*>(this, _MTL_PRIVATE_SEL(inputDimensionsAtBufferIndex_), bufferIndex);
}

_MTL_INLINE NS::String* MTL4::MachineLearningPipelineDescriptor::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE MTL4::FunctionDescriptor* MTL4::MachineLearningPipelineDescriptor::machineLearningFunctionDescriptor() const
{
    return Object::sendMessage<MTL4::FunctionDescriptor*>(this, _MTL_PRIVATE_SEL(machineLearningFunctionDescriptor));
}

_MTL_INLINE void MTL4::MachineLearningPipelineDescriptor::reset()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(reset));
}

_MTL_INLINE void MTL4::MachineLearningPipelineDescriptor::setInputDimensions(const MTL::TensorExtents* dimensions, NS::Integer bufferIndex)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInputDimensions_atBufferIndex_), dimensions, bufferIndex);
}

_MTL_INLINE void MTL4::MachineLearningPipelineDescriptor::setInputDimensions(const NS::Array* dimensions, NS::Range range)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setInputDimensions_withRange_), dimensions, range);
}

_MTL_INLINE void MTL4::MachineLearningPipelineDescriptor::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

_MTL_INLINE void MTL4::MachineLearningPipelineDescriptor::setMachineLearningFunctionDescriptor(const MTL4::FunctionDescriptor* machineLearningFunctionDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMachineLearningFunctionDescriptor_), machineLearningFunctionDescriptor);
}

_MTL_INLINE MTL4::MachineLearningPipelineReflection* MTL4::MachineLearningPipelineReflection::alloc()
{
    return NS::Object::alloc<MTL4::MachineLearningPipelineReflection>(_MTL_PRIVATE_CLS(MTL4MachineLearningPipelineReflection));
}

_MTL_INLINE NS::Array* MTL4::MachineLearningPipelineReflection::bindings() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(bindings));
}

_MTL_INLINE MTL4::MachineLearningPipelineReflection* MTL4::MachineLearningPipelineReflection::init()
{
    return NS::Object::init<MTL4::MachineLearningPipelineReflection>();
}

_MTL_INLINE MTL::Device* MTL4::MachineLearningPipelineState::device() const
{
    return Object::sendMessage<MTL::Device*>(this, _MTL_PRIVATE_SEL(device));
}

_MTL_INLINE NS::UInteger MTL4::MachineLearningPipelineState::intermediatesHeapSize() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(intermediatesHeapSize));
}

_MTL_INLINE NS::String* MTL4::MachineLearningPipelineState::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE MTL4::MachineLearningPipelineReflection* MTL4::MachineLearningPipelineState::reflection() const
{
    return Object::sendMessage<MTL4::MachineLearningPipelineReflection*>(this, _MTL_PRIVATE_SEL(reflection));
}

#pragma once

namespace MTL4
{
class FunctionDescriptor;
class StaticLinkingDescriptor;
class TileRenderPipelineDescriptor;
}

namespace MTL
{
class TileRenderPipelineColorAttachmentDescriptorArray;
}

namespace MTL4
{
class TileRenderPipelineDescriptor : public NS::Copying<TileRenderPipelineDescriptor, PipelineDescriptor>
{
public:
    static TileRenderPipelineDescriptor*                   alloc();

    MTL::TileRenderPipelineColorAttachmentDescriptorArray* colorAttachments() const;

    TileRenderPipelineDescriptor*                          init();

    NS::UInteger                                           maxTotalThreadsPerThreadgroup() const;

    NS::UInteger                                           rasterSampleCount() const;

    MTL::Size                                              requiredThreadsPerThreadgroup() const;

    void                                                   reset();

    void                                                   setMaxTotalThreadsPerThreadgroup(NS::UInteger maxTotalThreadsPerThreadgroup);

    void                                                   setRasterSampleCount(NS::UInteger rasterSampleCount);

    void                                                   setRequiredThreadsPerThreadgroup(MTL::Size requiredThreadsPerThreadgroup);

    void                                                   setStaticLinkingDescriptor(const MTL4::StaticLinkingDescriptor* staticLinkingDescriptor);

    void                                                   setSupportBinaryLinking(bool supportBinaryLinking);

    void                                                   setThreadgroupSizeMatchesTileSize(bool threadgroupSizeMatchesTileSize);

    void                                                   setTileFunctionDescriptor(const MTL4::FunctionDescriptor* tileFunctionDescriptor);

    StaticLinkingDescriptor*                               staticLinkingDescriptor() const;

    bool                                                   supportBinaryLinking() const;

    bool                                                   threadgroupSizeMatchesTileSize() const;

    FunctionDescriptor*                                    tileFunctionDescriptor() const;
};

}
_MTL_INLINE MTL4::TileRenderPipelineDescriptor* MTL4::TileRenderPipelineDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::TileRenderPipelineDescriptor>(_MTL_PRIVATE_CLS(MTL4TileRenderPipelineDescriptor));
}

_MTL_INLINE MTL::TileRenderPipelineColorAttachmentDescriptorArray* MTL4::TileRenderPipelineDescriptor::colorAttachments() const
{
    return Object::sendMessage<MTL::TileRenderPipelineColorAttachmentDescriptorArray*>(this, _MTL_PRIVATE_SEL(colorAttachments));
}

_MTL_INLINE MTL4::TileRenderPipelineDescriptor* MTL4::TileRenderPipelineDescriptor::init()
{
    return NS::Object::init<MTL4::TileRenderPipelineDescriptor>();
}

_MTL_INLINE NS::UInteger MTL4::TileRenderPipelineDescriptor::maxTotalThreadsPerThreadgroup() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxTotalThreadsPerThreadgroup));
}

_MTL_INLINE NS::UInteger MTL4::TileRenderPipelineDescriptor::rasterSampleCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(rasterSampleCount));
}

_MTL_INLINE MTL::Size MTL4::TileRenderPipelineDescriptor::requiredThreadsPerThreadgroup() const
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(requiredThreadsPerThreadgroup));
}

_MTL_INLINE void MTL4::TileRenderPipelineDescriptor::reset()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(reset));
}

_MTL_INLINE void MTL4::TileRenderPipelineDescriptor::setMaxTotalThreadsPerThreadgroup(NS::UInteger maxTotalThreadsPerThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxTotalThreadsPerThreadgroup_), maxTotalThreadsPerThreadgroup);
}

_MTL_INLINE void MTL4::TileRenderPipelineDescriptor::setRasterSampleCount(NS::UInteger rasterSampleCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRasterSampleCount_), rasterSampleCount);
}

_MTL_INLINE void MTL4::TileRenderPipelineDescriptor::setRequiredThreadsPerThreadgroup(MTL::Size requiredThreadsPerThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRequiredThreadsPerThreadgroup_), requiredThreadsPerThreadgroup);
}

_MTL_INLINE void MTL4::TileRenderPipelineDescriptor::setStaticLinkingDescriptor(const MTL4::StaticLinkingDescriptor* staticLinkingDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setStaticLinkingDescriptor_), staticLinkingDescriptor);
}

_MTL_INLINE void MTL4::TileRenderPipelineDescriptor::setSupportBinaryLinking(bool supportBinaryLinking)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportBinaryLinking_), supportBinaryLinking);
}

_MTL_INLINE void MTL4::TileRenderPipelineDescriptor::setThreadgroupSizeMatchesTileSize(bool threadgroupSizeMatchesTileSize)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setThreadgroupSizeMatchesTileSize_), threadgroupSizeMatchesTileSize);
}

_MTL_INLINE void MTL4::TileRenderPipelineDescriptor::setTileFunctionDescriptor(const MTL4::FunctionDescriptor* tileFunctionDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setTileFunctionDescriptor_), tileFunctionDescriptor);
}

_MTL_INLINE MTL4::StaticLinkingDescriptor* MTL4::TileRenderPipelineDescriptor::staticLinkingDescriptor() const
{
    return Object::sendMessage<MTL4::StaticLinkingDescriptor*>(this, _MTL_PRIVATE_SEL(staticLinkingDescriptor));
}

_MTL_INLINE bool MTL4::TileRenderPipelineDescriptor::supportBinaryLinking() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportBinaryLinking));
}

_MTL_INLINE bool MTL4::TileRenderPipelineDescriptor::threadgroupSizeMatchesTileSize() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(threadgroupSizeMatchesTileSize));
}

_MTL_INLINE MTL4::FunctionDescriptor* MTL4::TileRenderPipelineDescriptor::tileFunctionDescriptor() const
{
    return Object::sendMessage<MTL4::FunctionDescriptor*>(this, _MTL_PRIVATE_SEL(tileFunctionDescriptor));
}

#pragma once

namespace MTL4
{
class FunctionDescriptor;
class MeshRenderPipelineDescriptor;
class RenderPipelineColorAttachmentDescriptorArray;
class StaticLinkingDescriptor;

class MeshRenderPipelineDescriptor : public NS::Copying<MeshRenderPipelineDescriptor, PipelineDescriptor>
{
public:
    static MeshRenderPipelineDescriptor*          alloc();

    AlphaToCoverageState                          alphaToCoverageState() const;

    AlphaToOneState                               alphaToOneState() const;

    LogicalToPhysicalColorAttachmentMappingState  colorAttachmentMappingState() const;

    RenderPipelineColorAttachmentDescriptorArray* colorAttachments() const;

    FunctionDescriptor*                           fragmentFunctionDescriptor() const;

    StaticLinkingDescriptor*                      fragmentStaticLinkingDescriptor() const;

    MeshRenderPipelineDescriptor*                 init();

    bool                                          isRasterizationEnabled() const;

    NS::UInteger                                  maxTotalThreadgroupsPerMeshGrid() const;

    NS::UInteger                                  maxTotalThreadsPerMeshThreadgroup() const;

    NS::UInteger                                  maxTotalThreadsPerObjectThreadgroup() const;

    NS::UInteger                                  maxVertexAmplificationCount() const;

    FunctionDescriptor*                           meshFunctionDescriptor() const;

    StaticLinkingDescriptor*                      meshStaticLinkingDescriptor() const;

    bool                                          meshThreadgroupSizeIsMultipleOfThreadExecutionWidth() const;

    FunctionDescriptor*                           objectFunctionDescriptor() const;

    StaticLinkingDescriptor*                      objectStaticLinkingDescriptor() const;

    bool                                          objectThreadgroupSizeIsMultipleOfThreadExecutionWidth() const;

    NS::UInteger                                  payloadMemoryLength() const;

    NS::UInteger                                  rasterSampleCount() const;

    [[deprecated("please use isRasterizationEnabled instead")]]
    bool                              rasterizationEnabled() const;

    MTL::Size                         requiredThreadsPerMeshThreadgroup() const;

    MTL::Size                         requiredThreadsPerObjectThreadgroup() const;

    void                              reset();

    void                              setAlphaToCoverageState(MTL4::AlphaToCoverageState alphaToCoverageState);

    void                              setAlphaToOneState(MTL4::AlphaToOneState alphaToOneState);

    void                              setColorAttachmentMappingState(MTL4::LogicalToPhysicalColorAttachmentMappingState colorAttachmentMappingState);

    void                              setFragmentFunctionDescriptor(const MTL4::FunctionDescriptor* fragmentFunctionDescriptor);

    void                              setFragmentStaticLinkingDescriptor(const MTL4::StaticLinkingDescriptor* fragmentStaticLinkingDescriptor);

    void                              setMaxTotalThreadgroupsPerMeshGrid(NS::UInteger maxTotalThreadgroupsPerMeshGrid);

    void                              setMaxTotalThreadsPerMeshThreadgroup(NS::UInteger maxTotalThreadsPerMeshThreadgroup);

    void                              setMaxTotalThreadsPerObjectThreadgroup(NS::UInteger maxTotalThreadsPerObjectThreadgroup);

    void                              setMaxVertexAmplificationCount(NS::UInteger maxVertexAmplificationCount);

    void                              setMeshFunctionDescriptor(const MTL4::FunctionDescriptor* meshFunctionDescriptor);

    void                              setMeshStaticLinkingDescriptor(const MTL4::StaticLinkingDescriptor* meshStaticLinkingDescriptor);

    void                              setMeshThreadgroupSizeIsMultipleOfThreadExecutionWidth(bool meshThreadgroupSizeIsMultipleOfThreadExecutionWidth);

    void                              setObjectFunctionDescriptor(const MTL4::FunctionDescriptor* objectFunctionDescriptor);

    void                              setObjectStaticLinkingDescriptor(const MTL4::StaticLinkingDescriptor* objectStaticLinkingDescriptor);

    void                              setObjectThreadgroupSizeIsMultipleOfThreadExecutionWidth(bool objectThreadgroupSizeIsMultipleOfThreadExecutionWidth);

    void                              setPayloadMemoryLength(NS::UInteger payloadMemoryLength);

    void                              setRasterSampleCount(NS::UInteger rasterSampleCount);

    void                              setRasterizationEnabled(bool rasterizationEnabled);

    void                              setRequiredThreadsPerMeshThreadgroup(MTL::Size requiredThreadsPerMeshThreadgroup);

    void                              setRequiredThreadsPerObjectThreadgroup(MTL::Size requiredThreadsPerObjectThreadgroup);

    void                              setSupportFragmentBinaryLinking(bool supportFragmentBinaryLinking);

    void                              setSupportIndirectCommandBuffers(MTL4::IndirectCommandBufferSupportState supportIndirectCommandBuffers);

    void                              setSupportMeshBinaryLinking(bool supportMeshBinaryLinking);

    void                              setSupportObjectBinaryLinking(bool supportObjectBinaryLinking);

    bool                              supportFragmentBinaryLinking() const;

    IndirectCommandBufferSupportState supportIndirectCommandBuffers() const;

    bool                              supportMeshBinaryLinking() const;

    bool                              supportObjectBinaryLinking() const;
};

}
_MTL_INLINE MTL4::MeshRenderPipelineDescriptor* MTL4::MeshRenderPipelineDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::MeshRenderPipelineDescriptor>(_MTL_PRIVATE_CLS(MTL4MeshRenderPipelineDescriptor));
}

_MTL_INLINE MTL4::AlphaToCoverageState MTL4::MeshRenderPipelineDescriptor::alphaToCoverageState() const
{
    return Object::sendMessage<MTL4::AlphaToCoverageState>(this, _MTL_PRIVATE_SEL(alphaToCoverageState));
}

_MTL_INLINE MTL4::AlphaToOneState MTL4::MeshRenderPipelineDescriptor::alphaToOneState() const
{
    return Object::sendMessage<MTL4::AlphaToOneState>(this, _MTL_PRIVATE_SEL(alphaToOneState));
}

_MTL_INLINE MTL4::LogicalToPhysicalColorAttachmentMappingState MTL4::MeshRenderPipelineDescriptor::colorAttachmentMappingState() const
{
    return Object::sendMessage<MTL4::LogicalToPhysicalColorAttachmentMappingState>(this, _MTL_PRIVATE_SEL(colorAttachmentMappingState));
}

_MTL_INLINE MTL4::RenderPipelineColorAttachmentDescriptorArray* MTL4::MeshRenderPipelineDescriptor::colorAttachments() const
{
    return Object::sendMessage<MTL4::RenderPipelineColorAttachmentDescriptorArray*>(this, _MTL_PRIVATE_SEL(colorAttachments));
}

_MTL_INLINE MTL4::FunctionDescriptor* MTL4::MeshRenderPipelineDescriptor::fragmentFunctionDescriptor() const
{
    return Object::sendMessage<MTL4::FunctionDescriptor*>(this, _MTL_PRIVATE_SEL(fragmentFunctionDescriptor));
}

_MTL_INLINE MTL4::StaticLinkingDescriptor* MTL4::MeshRenderPipelineDescriptor::fragmentStaticLinkingDescriptor() const
{
    return Object::sendMessage<MTL4::StaticLinkingDescriptor*>(this, _MTL_PRIVATE_SEL(fragmentStaticLinkingDescriptor));
}

_MTL_INLINE MTL4::MeshRenderPipelineDescriptor* MTL4::MeshRenderPipelineDescriptor::init()
{
    return NS::Object::init<MTL4::MeshRenderPipelineDescriptor>();
}

_MTL_INLINE bool MTL4::MeshRenderPipelineDescriptor::isRasterizationEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isRasterizationEnabled));
}

_MTL_INLINE NS::UInteger MTL4::MeshRenderPipelineDescriptor::maxTotalThreadgroupsPerMeshGrid() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxTotalThreadgroupsPerMeshGrid));
}

_MTL_INLINE NS::UInteger MTL4::MeshRenderPipelineDescriptor::maxTotalThreadsPerMeshThreadgroup() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxTotalThreadsPerMeshThreadgroup));
}

_MTL_INLINE NS::UInteger MTL4::MeshRenderPipelineDescriptor::maxTotalThreadsPerObjectThreadgroup() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxTotalThreadsPerObjectThreadgroup));
}

_MTL_INLINE NS::UInteger MTL4::MeshRenderPipelineDescriptor::maxVertexAmplificationCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxVertexAmplificationCount));
}

_MTL_INLINE MTL4::FunctionDescriptor* MTL4::MeshRenderPipelineDescriptor::meshFunctionDescriptor() const
{
    return Object::sendMessage<MTL4::FunctionDescriptor*>(this, _MTL_PRIVATE_SEL(meshFunctionDescriptor));
}

_MTL_INLINE MTL4::StaticLinkingDescriptor* MTL4::MeshRenderPipelineDescriptor::meshStaticLinkingDescriptor() const
{
    return Object::sendMessage<MTL4::StaticLinkingDescriptor*>(this, _MTL_PRIVATE_SEL(meshStaticLinkingDescriptor));
}

_MTL_INLINE bool MTL4::MeshRenderPipelineDescriptor::meshThreadgroupSizeIsMultipleOfThreadExecutionWidth() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(meshThreadgroupSizeIsMultipleOfThreadExecutionWidth));
}

_MTL_INLINE MTL4::FunctionDescriptor* MTL4::MeshRenderPipelineDescriptor::objectFunctionDescriptor() const
{
    return Object::sendMessage<MTL4::FunctionDescriptor*>(this, _MTL_PRIVATE_SEL(objectFunctionDescriptor));
}

_MTL_INLINE MTL4::StaticLinkingDescriptor* MTL4::MeshRenderPipelineDescriptor::objectStaticLinkingDescriptor() const
{
    return Object::sendMessage<MTL4::StaticLinkingDescriptor*>(this, _MTL_PRIVATE_SEL(objectStaticLinkingDescriptor));
}

_MTL_INLINE bool MTL4::MeshRenderPipelineDescriptor::objectThreadgroupSizeIsMultipleOfThreadExecutionWidth() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(objectThreadgroupSizeIsMultipleOfThreadExecutionWidth));
}

_MTL_INLINE NS::UInteger MTL4::MeshRenderPipelineDescriptor::payloadMemoryLength() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(payloadMemoryLength));
}

_MTL_INLINE NS::UInteger MTL4::MeshRenderPipelineDescriptor::rasterSampleCount() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(rasterSampleCount));
}

_MTL_INLINE bool MTL4::MeshRenderPipelineDescriptor::rasterizationEnabled() const
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(isRasterizationEnabled));
}

_MTL_INLINE MTL::Size MTL4::MeshRenderPipelineDescriptor::requiredThreadsPerMeshThreadgroup() const
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(requiredThreadsPerMeshThreadgroup));
}

_MTL_INLINE MTL::Size MTL4::MeshRenderPipelineDescriptor::requiredThreadsPerObjectThreadgroup() const
{
    return Object::sendMessage<MTL::Size>(this, _MTL_PRIVATE_SEL(requiredThreadsPerObjectThreadgroup));
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::reset()
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(reset));
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setAlphaToCoverageState(MTL4::AlphaToCoverageState alphaToCoverageState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setAlphaToCoverageState_), alphaToCoverageState);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setAlphaToOneState(MTL4::AlphaToOneState alphaToOneState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setAlphaToOneState_), alphaToOneState);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setColorAttachmentMappingState(MTL4::LogicalToPhysicalColorAttachmentMappingState colorAttachmentMappingState)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setColorAttachmentMappingState_), colorAttachmentMappingState);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setFragmentFunctionDescriptor(const MTL4::FunctionDescriptor* fragmentFunctionDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentFunctionDescriptor_), fragmentFunctionDescriptor);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setFragmentStaticLinkingDescriptor(const MTL4::StaticLinkingDescriptor* fragmentStaticLinkingDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFragmentStaticLinkingDescriptor_), fragmentStaticLinkingDescriptor);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setMaxTotalThreadgroupsPerMeshGrid(NS::UInteger maxTotalThreadgroupsPerMeshGrid)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxTotalThreadgroupsPerMeshGrid_), maxTotalThreadgroupsPerMeshGrid);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setMaxTotalThreadsPerMeshThreadgroup(NS::UInteger maxTotalThreadsPerMeshThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxTotalThreadsPerMeshThreadgroup_), maxTotalThreadsPerMeshThreadgroup);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setMaxTotalThreadsPerObjectThreadgroup(NS::UInteger maxTotalThreadsPerObjectThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxTotalThreadsPerObjectThreadgroup_), maxTotalThreadsPerObjectThreadgroup);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setMaxVertexAmplificationCount(NS::UInteger maxVertexAmplificationCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxVertexAmplificationCount_), maxVertexAmplificationCount);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setMeshFunctionDescriptor(const MTL4::FunctionDescriptor* meshFunctionDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMeshFunctionDescriptor_), meshFunctionDescriptor);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setMeshStaticLinkingDescriptor(const MTL4::StaticLinkingDescriptor* meshStaticLinkingDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMeshStaticLinkingDescriptor_), meshStaticLinkingDescriptor);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setMeshThreadgroupSizeIsMultipleOfThreadExecutionWidth(bool meshThreadgroupSizeIsMultipleOfThreadExecutionWidth)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMeshThreadgroupSizeIsMultipleOfThreadExecutionWidth_), meshThreadgroupSizeIsMultipleOfThreadExecutionWidth);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setObjectFunctionDescriptor(const MTL4::FunctionDescriptor* objectFunctionDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectFunctionDescriptor_), objectFunctionDescriptor);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setObjectStaticLinkingDescriptor(const MTL4::StaticLinkingDescriptor* objectStaticLinkingDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectStaticLinkingDescriptor_), objectStaticLinkingDescriptor);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setObjectThreadgroupSizeIsMultipleOfThreadExecutionWidth(bool objectThreadgroupSizeIsMultipleOfThreadExecutionWidth)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setObjectThreadgroupSizeIsMultipleOfThreadExecutionWidth_), objectThreadgroupSizeIsMultipleOfThreadExecutionWidth);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setPayloadMemoryLength(NS::UInteger payloadMemoryLength)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPayloadMemoryLength_), payloadMemoryLength);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setRasterSampleCount(NS::UInteger rasterSampleCount)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRasterSampleCount_), rasterSampleCount);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setRasterizationEnabled(bool rasterizationEnabled)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRasterizationEnabled_), rasterizationEnabled);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setRequiredThreadsPerMeshThreadgroup(MTL::Size requiredThreadsPerMeshThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRequiredThreadsPerMeshThreadgroup_), requiredThreadsPerMeshThreadgroup);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setRequiredThreadsPerObjectThreadgroup(MTL::Size requiredThreadsPerObjectThreadgroup)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setRequiredThreadsPerObjectThreadgroup_), requiredThreadsPerObjectThreadgroup);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setSupportFragmentBinaryLinking(bool supportFragmentBinaryLinking)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportFragmentBinaryLinking_), supportFragmentBinaryLinking);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setSupportIndirectCommandBuffers(MTL4::IndirectCommandBufferSupportState supportIndirectCommandBuffers)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportIndirectCommandBuffers_), supportIndirectCommandBuffers);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setSupportMeshBinaryLinking(bool supportMeshBinaryLinking)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportMeshBinaryLinking_), supportMeshBinaryLinking);
}

_MTL_INLINE void MTL4::MeshRenderPipelineDescriptor::setSupportObjectBinaryLinking(bool supportObjectBinaryLinking)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setSupportObjectBinaryLinking_), supportObjectBinaryLinking);
}

_MTL_INLINE bool MTL4::MeshRenderPipelineDescriptor::supportFragmentBinaryLinking() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportFragmentBinaryLinking));
}

_MTL_INLINE MTL4::IndirectCommandBufferSupportState MTL4::MeshRenderPipelineDescriptor::supportIndirectCommandBuffers() const
{
    return Object::sendMessage<MTL4::IndirectCommandBufferSupportState>(this, _MTL_PRIVATE_SEL(supportIndirectCommandBuffers));
}

_MTL_INLINE bool MTL4::MeshRenderPipelineDescriptor::supportMeshBinaryLinking() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportMeshBinaryLinking));
}

_MTL_INLINE bool MTL4::MeshRenderPipelineDescriptor::supportObjectBinaryLinking() const
{
    return Object::sendMessageSafe<bool>(this, _MTL_PRIVATE_SEL(supportObjectBinaryLinking));
}

#pragma once

namespace MTL4
{
class PipelineDataSetSerializerDescriptor;

_MTL_OPTIONS(NS::UInteger, PipelineDataSetSerializerConfiguration) {
    PipelineDataSetSerializerConfigurationCaptureDescriptors = 1,
    PipelineDataSetSerializerConfigurationCaptureBinaries = 1 << 1,
};

class PipelineDataSetSerializerDescriptor : public NS::Copying<PipelineDataSetSerializerDescriptor>
{
public:
    static PipelineDataSetSerializerDescriptor* alloc();

    PipelineDataSetSerializerConfiguration      configuration() const;

    PipelineDataSetSerializerDescriptor*        init();

    void                                        setConfiguration(MTL4::PipelineDataSetSerializerConfiguration configuration);
};
class PipelineDataSetSerializer : public NS::Referencing<PipelineDataSetSerializer>
{
public:
    bool      serializeAsArchiveAndFlushToURL(const NS::URL* url, NS::Error** error);

    NS::Data* serializeAsPipelinesScript(NS::Error** error);
};

}
_MTL_INLINE MTL4::PipelineDataSetSerializerDescriptor* MTL4::PipelineDataSetSerializerDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::PipelineDataSetSerializerDescriptor>(_MTL_PRIVATE_CLS(MTL4PipelineDataSetSerializerDescriptor));
}

_MTL_INLINE MTL4::PipelineDataSetSerializerConfiguration MTL4::PipelineDataSetSerializerDescriptor::configuration() const
{
    return Object::sendMessage<MTL4::PipelineDataSetSerializerConfiguration>(this, _MTL_PRIVATE_SEL(configuration));
}

_MTL_INLINE MTL4::PipelineDataSetSerializerDescriptor* MTL4::PipelineDataSetSerializerDescriptor::init()
{
    return NS::Object::init<MTL4::PipelineDataSetSerializerDescriptor>();
}

_MTL_INLINE void MTL4::PipelineDataSetSerializerDescriptor::setConfiguration(MTL4::PipelineDataSetSerializerConfiguration configuration)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setConfiguration_), configuration);
}

_MTL_INLINE bool MTL4::PipelineDataSetSerializer::serializeAsArchiveAndFlushToURL(const NS::URL* url, NS::Error** error)
{
    return Object::sendMessage<bool>(this, _MTL_PRIVATE_SEL(serializeAsArchiveAndFlushToURL_error_), url, error);
}

_MTL_INLINE NS::Data* MTL4::PipelineDataSetSerializer::serializeAsPipelinesScript(NS::Error** error)
{
    return Object::sendMessage<NS::Data*>(this, _MTL_PRIVATE_SEL(serializeAsPipelinesScriptWithError_), error);
}

#pragma once

namespace MTL
{
class ComputePipelineState;
class RenderPipelineState;
}

namespace MTL4
{
class BinaryFunction;
class BinaryFunctionDescriptor;
class ComputePipelineDescriptor;
class PipelineDescriptor;
class PipelineStageDynamicLinkingDescriptor;
class RenderPipelineDynamicLinkingDescriptor;

class Archive : public NS::Referencing<Archive>
{
public:
    NS::String*                label() const;

    BinaryFunction*            newBinaryFunction(const MTL4::BinaryFunctionDescriptor* descriptor, NS::Error** error);

    MTL::ComputePipelineState* newComputePipelineState(const MTL4::ComputePipelineDescriptor* descriptor, NS::Error** error);
    MTL::ComputePipelineState* newComputePipelineState(const MTL4::ComputePipelineDescriptor* descriptor, const MTL4::PipelineStageDynamicLinkingDescriptor* dynamicLinkingDescriptor, NS::Error** error);

    MTL::RenderPipelineState*  newRenderPipelineState(const MTL4::PipelineDescriptor* descriptor, NS::Error** error);
    MTL::RenderPipelineState*  newRenderPipelineState(const MTL4::PipelineDescriptor* descriptor, const MTL4::RenderPipelineDynamicLinkingDescriptor* dynamicLinkingDescriptor, NS::Error** error);

    void                       setLabel(const NS::String* label);
};

}
_MTL_INLINE NS::String* MTL4::Archive::label() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(label));
}

_MTL_INLINE MTL4::BinaryFunction* MTL4::Archive::newBinaryFunction(const MTL4::BinaryFunctionDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL4::BinaryFunction*>(this, _MTL_PRIVATE_SEL(newBinaryFunctionWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE MTL::ComputePipelineState* MTL4::Archive::newComputePipelineState(const MTL4::ComputePipelineDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL::ComputePipelineState*>(this, _MTL_PRIVATE_SEL(newComputePipelineStateWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE MTL::ComputePipelineState* MTL4::Archive::newComputePipelineState(const MTL4::ComputePipelineDescriptor* descriptor, const MTL4::PipelineStageDynamicLinkingDescriptor* dynamicLinkingDescriptor, NS::Error** error)
{
    return Object::sendMessage<MTL::ComputePipelineState*>(this, _MTL_PRIVATE_SEL(newComputePipelineStateWithDescriptor_dynamicLinkingDescriptor_error_), descriptor, dynamicLinkingDescriptor, error);
}

_MTL_INLINE MTL::RenderPipelineState* MTL4::Archive::newRenderPipelineState(const MTL4::PipelineDescriptor* descriptor, NS::Error** error)
{
    return Object::sendMessage<MTL::RenderPipelineState*>(this, _MTL_PRIVATE_SEL(newRenderPipelineStateWithDescriptor_error_), descriptor, error);
}

_MTL_INLINE MTL::RenderPipelineState* MTL4::Archive::newRenderPipelineState(const MTL4::PipelineDescriptor* descriptor, const MTL4::RenderPipelineDynamicLinkingDescriptor* dynamicLinkingDescriptor, NS::Error** error)
{
    return Object::sendMessage<MTL::RenderPipelineState*>(this, _MTL_PRIVATE_SEL(newRenderPipelineStateWithDescriptor_dynamicLinkingDescriptor_error_), descriptor, dynamicLinkingDescriptor, error);
}

_MTL_INLINE void MTL4::Archive::setLabel(const NS::String* label)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setLabel_), label);
}

#pragma once

namespace MTL4
{
class BinaryFunctionDescriptor;
class FunctionDescriptor;

_MTL_OPTIONS(NS::UInteger, BinaryFunctionOptions) {
    BinaryFunctionOptionNone = 0,
    BinaryFunctionOptionPipelineIndependent = 1 << 1,
};

class BinaryFunctionDescriptor : public NS::Copying<BinaryFunctionDescriptor>
{
public:
    static BinaryFunctionDescriptor* alloc();

    FunctionDescriptor*              functionDescriptor() const;

    BinaryFunctionDescriptor*        init();

    NS::String*                      name() const;

    BinaryFunctionOptions            options() const;

    void                             setFunctionDescriptor(const MTL4::FunctionDescriptor* functionDescriptor);

    void                             setName(const NS::String* name);

    void                             setOptions(MTL4::BinaryFunctionOptions options);
};

}
_MTL_INLINE MTL4::BinaryFunctionDescriptor* MTL4::BinaryFunctionDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::BinaryFunctionDescriptor>(_MTL_PRIVATE_CLS(MTL4BinaryFunctionDescriptor));
}

_MTL_INLINE MTL4::FunctionDescriptor* MTL4::BinaryFunctionDescriptor::functionDescriptor() const
{
    return Object::sendMessage<MTL4::FunctionDescriptor*>(this, _MTL_PRIVATE_SEL(functionDescriptor));
}

_MTL_INLINE MTL4::BinaryFunctionDescriptor* MTL4::BinaryFunctionDescriptor::init()
{
    return NS::Object::init<MTL4::BinaryFunctionDescriptor>();
}

_MTL_INLINE NS::String* MTL4::BinaryFunctionDescriptor::name() const
{
    return Object::sendMessage<NS::String*>(this, _MTL_PRIVATE_SEL(name));
}

_MTL_INLINE MTL4::BinaryFunctionOptions MTL4::BinaryFunctionDescriptor::options() const
{
    return Object::sendMessage<MTL4::BinaryFunctionOptions>(this, _MTL_PRIVATE_SEL(options));
}

_MTL_INLINE void MTL4::BinaryFunctionDescriptor::setFunctionDescriptor(const MTL4::FunctionDescriptor* functionDescriptor)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFunctionDescriptor_), functionDescriptor);
}

_MTL_INLINE void MTL4::BinaryFunctionDescriptor::setName(const NS::String* name)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setName_), name);
}

_MTL_INLINE void MTL4::BinaryFunctionDescriptor::setOptions(MTL4::BinaryFunctionOptions options)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setOptions_), options);
}

#pragma once

namespace MTL4
{
class PipelineStageDynamicLinkingDescriptor;
class RenderPipelineDynamicLinkingDescriptor;
class StaticLinkingDescriptor;

class StaticLinkingDescriptor : public NS::Copying<StaticLinkingDescriptor>
{
public:
    static StaticLinkingDescriptor* alloc();

    NS::Array*                      functionDescriptors() const;

    NS::Dictionary*                 groups() const;

    StaticLinkingDescriptor*        init();

    NS::Array*                      privateFunctionDescriptors() const;

    void                            setFunctionDescriptors(const NS::Array* functionDescriptors);

    void                            setGroups(const NS::Dictionary* groups);

    void                            setPrivateFunctionDescriptors(const NS::Array* privateFunctionDescriptors);
};
class PipelineStageDynamicLinkingDescriptor : public NS::Copying<PipelineStageDynamicLinkingDescriptor>
{
public:
    static PipelineStageDynamicLinkingDescriptor* alloc();

    NS::Array*                                    binaryLinkedFunctions() const;

    PipelineStageDynamicLinkingDescriptor*        init();

    NS::UInteger                                  maxCallStackDepth() const;

    NS::Array*                                    preloadedLibraries() const;

    void                                          setBinaryLinkedFunctions(const NS::Array* binaryLinkedFunctions);

    void                                          setMaxCallStackDepth(NS::UInteger maxCallStackDepth);

    void                                          setPreloadedLibraries(const NS::Array* preloadedLibraries);
};
class RenderPipelineDynamicLinkingDescriptor : public NS::Copying<RenderPipelineDynamicLinkingDescriptor>
{
public:
    static RenderPipelineDynamicLinkingDescriptor* alloc();

    PipelineStageDynamicLinkingDescriptor*         fragmentLinkingDescriptor() const;

    RenderPipelineDynamicLinkingDescriptor*        init();

    PipelineStageDynamicLinkingDescriptor*         meshLinkingDescriptor() const;

    PipelineStageDynamicLinkingDescriptor*         objectLinkingDescriptor() const;

    PipelineStageDynamicLinkingDescriptor*         tileLinkingDescriptor() const;

    PipelineStageDynamicLinkingDescriptor*         vertexLinkingDescriptor() const;
};

}
_MTL_INLINE MTL4::StaticLinkingDescriptor* MTL4::StaticLinkingDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::StaticLinkingDescriptor>(_MTL_PRIVATE_CLS(MTL4StaticLinkingDescriptor));
}

_MTL_INLINE NS::Array* MTL4::StaticLinkingDescriptor::functionDescriptors() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(functionDescriptors));
}

_MTL_INLINE NS::Dictionary* MTL4::StaticLinkingDescriptor::groups() const
{
    return Object::sendMessage<NS::Dictionary*>(this, _MTL_PRIVATE_SEL(groups));
}

_MTL_INLINE MTL4::StaticLinkingDescriptor* MTL4::StaticLinkingDescriptor::init()
{
    return NS::Object::init<MTL4::StaticLinkingDescriptor>();
}

_MTL_INLINE NS::Array* MTL4::StaticLinkingDescriptor::privateFunctionDescriptors() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(privateFunctionDescriptors));
}

_MTL_INLINE void MTL4::StaticLinkingDescriptor::setFunctionDescriptors(const NS::Array* functionDescriptors)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setFunctionDescriptors_), functionDescriptors);
}

_MTL_INLINE void MTL4::StaticLinkingDescriptor::setGroups(const NS::Dictionary* groups)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setGroups_), groups);
}

_MTL_INLINE void MTL4::StaticLinkingDescriptor::setPrivateFunctionDescriptors(const NS::Array* privateFunctionDescriptors)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPrivateFunctionDescriptors_), privateFunctionDescriptors);
}

_MTL_INLINE MTL4::PipelineStageDynamicLinkingDescriptor* MTL4::PipelineStageDynamicLinkingDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::PipelineStageDynamicLinkingDescriptor>(_MTL_PRIVATE_CLS(MTL4PipelineStageDynamicLinkingDescriptor));
}

_MTL_INLINE NS::Array* MTL4::PipelineStageDynamicLinkingDescriptor::binaryLinkedFunctions() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(binaryLinkedFunctions));
}

_MTL_INLINE MTL4::PipelineStageDynamicLinkingDescriptor* MTL4::PipelineStageDynamicLinkingDescriptor::init()
{
    return NS::Object::init<MTL4::PipelineStageDynamicLinkingDescriptor>();
}

_MTL_INLINE NS::UInteger MTL4::PipelineStageDynamicLinkingDescriptor::maxCallStackDepth() const
{
    return Object::sendMessage<NS::UInteger>(this, _MTL_PRIVATE_SEL(maxCallStackDepth));
}

_MTL_INLINE NS::Array* MTL4::PipelineStageDynamicLinkingDescriptor::preloadedLibraries() const
{
    return Object::sendMessage<NS::Array*>(this, _MTL_PRIVATE_SEL(preloadedLibraries));
}

_MTL_INLINE void MTL4::PipelineStageDynamicLinkingDescriptor::setBinaryLinkedFunctions(const NS::Array* binaryLinkedFunctions)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setBinaryLinkedFunctions_), binaryLinkedFunctions);
}

_MTL_INLINE void MTL4::PipelineStageDynamicLinkingDescriptor::setMaxCallStackDepth(NS::UInteger maxCallStackDepth)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setMaxCallStackDepth_), maxCallStackDepth);
}

_MTL_INLINE void MTL4::PipelineStageDynamicLinkingDescriptor::setPreloadedLibraries(const NS::Array* preloadedLibraries)
{
    Object::sendMessage<void>(this, _MTL_PRIVATE_SEL(setPreloadedLibraries_), preloadedLibraries);
}

_MTL_INLINE MTL4::RenderPipelineDynamicLinkingDescriptor* MTL4::RenderPipelineDynamicLinkingDescriptor::alloc()
{
    return NS::Object::alloc<MTL4::RenderPipelineDynamicLinkingDescriptor>(_MTL_PRIVATE_CLS(MTL4RenderPipelineDynamicLinkingDescriptor));
}

_MTL_INLINE MTL4::PipelineStageDynamicLinkingDescriptor* MTL4::RenderPipelineDynamicLinkingDescriptor::fragmentLinkingDescriptor() const
{
    return Object::sendMessage<MTL4::PipelineStageDynamicLinkingDescriptor*>(this, _MTL_PRIVATE_SEL(fragmentLinkingDescriptor));
}

_MTL_INLINE MTL4::RenderPipelineDynamicLinkingDescriptor* MTL4::RenderPipelineDynamicLinkingDescriptor::init()
{
    return NS::Object::init<MTL4::RenderPipelineDynamicLinkingDescriptor>();
}

_MTL_INLINE MTL4::PipelineStageDynamicLinkingDescriptor* MTL4::RenderPipelineDynamicLinkingDescriptor::meshLinkingDescriptor() const
{
    return Object::sendMessage<MTL4::PipelineStageDynamicLinkingDescriptor*>(this, _MTL_PRIVATE_SEL(meshLinkingDescriptor));
}

_MTL_INLINE MTL4::PipelineStageDynamicLinkingDescriptor* MTL4::RenderPipelineDynamicLinkingDescriptor::objectLinkingDescriptor() const
{
    return Object::sendMessage<MTL4::PipelineStageDynamicLinkingDescriptor*>(this, _MTL_PRIVATE_SEL(objectLinkingDescriptor));
}

_MTL_INLINE MTL4::PipelineStageDynamicLinkingDescriptor* MTL4::RenderPipelineDynamicLinkingDescriptor::tileLinkingDescriptor() const
{
    return Object::sendMessage<MTL4::PipelineStageDynamicLinkingDescriptor*>(this, _MTL_PRIVATE_SEL(tileLinkingDescriptor));
}

_MTL_INLINE MTL4::PipelineStageDynamicLinkingDescriptor* MTL4::RenderPipelineDynamicLinkingDescriptor::vertexLinkingDescriptor() const
{
    return Object::sendMessage<MTL4::PipelineStageDynamicLinkingDescriptor*>(this, _MTL_PRIVATE_SEL(vertexLinkingDescriptor));
}

#define _MTLFX_EXPORT                           _NS_EXPORT
#define _MTLFX_EXTERN                           _NS_EXTERN
#define _MTLFX_INLINE                           _NS_INLINE
#define _MTLFX_PACKED                           _NS_PACKED

#define _MTLFX_CONST( type, name )              _NS_CONST( type, name )
#define _MTLFX_ENUM( type, name )               _NS_ENUM( type, name )
#define _MTLFX_OPTIONS( type, name )            _NS_OPTIONS( type, name )

#define _MTLFX_VALIDATE_SIZE( mtlfx, name )     _NS_VALIDATE_SIZE( mtlfx, name )
#define _MTLFX_VALIDATE_ENUM( mtlfx, name )     _NS_VALIDATE_ENUM( mtlfx, name )

#include <objc/runtime.h>

#define _MTLFX_PRIVATE_CLS( symbol )                    ( MTLFX::Private::Class::s_k##symbol )
#define _MTLFX_PRIVATE_SEL( accessor )                  ( MTLFX::Private::Selector::s_k##accessor )

#if defined( MTLFX_PRIVATE_IMPLEMENTATION )

#if defined( METALCPP_SYMBOL_VISIBILITY_HIDDEN )
#define _MTLFX_PRIVATE_VISIBILITY                       __attribute__( ( visibility("hidden" ) ) )
#else
#define _MTLFX_PRIVATE_VISIBILITY                       __attribute__( ( visibility("default" ) ) )
#endif // METALCPP_SYMBOL_VISIBILITY_HIDDEN

#define _MTLFX_PRIVATE_IMPORT                           __attribute__( ( weak_import ) )

#ifdef __OBJC__
#define _MTLFX_PRIVATE_OBJC_LOOKUP_CLASS( symbol )      ( ( __bridge void* ) objc_lookUpClass( #symbol ) )
#define _MTLFX_PRIVATE_OBJC_GET_PROTOCOL( symbol )      ( ( __bridge void* ) objc_getProtocol( #symbol ) )
#else
#define _MTLFX_PRIVATE_OBJC_LOOKUP_CLASS( symbol )      objc_lookUpClass(#symbol)
#define _MTLFX_PRIVATE_OBJC_GET_PROTOCOL( symbol )      objc_getProtocol(#symbol)
#endif // __OBJC__

#define _MTLFX_PRIVATE_DEF_CLS( symbol )                void* s_k##symbol _MTLFX_PRIVATE_VISIBILITY = _MTLFX_PRIVATE_OBJC_LOOKUP_CLASS( symbol )
#define _MTLFX_PRIVATE_DEF_PRO( symbol )                void* s_k##symbol _MTLFX_PRIVATE_VISIBILITY = _MTLFX_PRIVATE_OBJC_GET_PROTOCOL( symbol )
#define _MTLFX_PRIVATE_DEF_SEL( accessor, symbol )       SEL s_k##accessor _MTLFX_PRIVATE_VISIBILITY = sel_registerName( symbol )

#include <dlfcn.h>
#define MTLFX_DEF_FUNC( name, signature )               using Fn##name = signature; \
                                                        Fn##name name = reinterpret_cast< Fn##name >( dlsym( RTLD_DEFAULT, #name ) )

namespace MTLFX::Private
{
    template <typename _Type>

    inline _Type const LoadSymbol(const char* pSymbol)
    {
        const _Type* pAddress = static_cast<_Type*>(dlsym(RTLD_DEFAULT, pSymbol));

        return pAddress ? *pAddress : nullptr;
    }
} // MTLFX::Private

#if defined(__MAC_26_0) || defined(__IPHONE_26_0) || defined(__TVOS_26_0)

#define _MTLFX_PRIVATE_DEF_STR( type, symbol )                                                                                  \
    _MTLFX_EXTERN type const                            MTLFX##symbol _MTLFX_PRIVATE_IMPORT;                                    \
    type const                                          MTLFX::symbol = ( nullptr != &MTLFX##symbol ) ? MTLFX##ssymbol : nullptr

#define _MTLFX_PRIVATE_DEF_CONST( type, symbol )                                                                                \
    _MTLFX_EXTERN type const                            MTLFX##ssymbol _MTLFX_PRIVATE_IMPORT;                                   \
    type const                                          MTLFX::symbol = (nullptr != &MTLFX##ssymbol) ? MTLFX##ssymbol : nullptr

#define _MTLFX_PRIVATE_DEF_WEAK_CONST( type, symbol )                                                                           \
    _MTLFX_EXTERN type const                            MTLFX##ssymbol;                                                         \
    type const                                          MTLFX::symbol = Private::LoadSymbol< type >( "MTLFX" #symbol )

#else

#define _MTLFX_PRIVATE_DEF_STR( type, symbol )                                                                                  \
    _MTLFX_EXTERN type const                            MTLFX##ssymbol;                                                         \
    type const                                          MTLFX::symbol = Private::LoadSymbol< type >( "MTLFX" #symbol )

#define _MTLFX_PRIVATE_DEF_CONST( type, symbol )                                                                                \
    _MTLFX_EXTERN type const                            MTLFX##ssymbol;                                                         \
    type const                                          MTLFX::symbol = Private::LoadSymbol< type >( "MTLFX" #symbol )

#define _MTLFX_PRIVATE_DEF_WEAK_CONST( type, symbol )   _MTLFX_PRIVATE_DEF_CONST( type, symbol )

#endif

#else

#define _MTLFX_PRIVATE_DEF_CLS( symbol )                extern void* s_k##symbol
#define _MTLFX_PRIVATE_DEF_PRO( symbol )                extern void* s_k##symbol
#define _MTLFX_PRIVATE_DEF_SEL( accessor, symbol )      extern SEL s_k##accessor
#define _MTLFX_PRIVATE_DEF_STR( type, symbol )          extern type const MTLFX::symbol
#define _MTLFX_PRIVATE_DEF_CONST( type, symbol )        extern type const MTLFX::symbol
#define _MTLFX_PRIVATE_DEF_WEAK_CONST( type, symbol )   extern type const MTLFX::symbol

#endif // MTLFX_PRIVATE_IMPLEMENTATION

namespace MTLFX
{
    namespace Private
    {
        namespace Class
        {
            _MTLFX_PRIVATE_DEF_CLS( MTLFXSpatialScalerDescriptor );
            _MTLFX_PRIVATE_DEF_CLS( MTLFXTemporalScalerDescriptor );
            _MTLFX_PRIVATE_DEF_CLS( MTLFXFrameInterpolatorDescriptor );
            _MTLFX_PRIVATE_DEF_CLS( MTLFXTemporalDenoisedScalerDescriptor );

            _MTLFX_PRIVATE_DEF_CLS( MTL4FXSpatialScalerDescriptor );
            _MTLFX_PRIVATE_DEF_CLS( MTL4FXTemporalScalerDescriptor );
            _MTLFX_PRIVATE_DEF_CLS( MTL4FXFrameInterpolatorDescriptor );
            _MTLFX_PRIVATE_DEF_CLS( MTL4FXTemporalDenoisedScalerDescriptor );
        } // Class
    } // Private
} // MTLFX

namespace MTLFX
{
    namespace Private
    {
        namespace Protocol
        {
            _MTLFX_PRIVATE_DEF_PRO( MTLFXSpatialScaler );
            _MTLFX_PRIVATE_DEF_PRO( MTLFXTemporalScaler );
        } // Protocol
    } // Private
} // MTLFX

namespace MTLFX
{
    namespace Private
    {
        namespace Selector
        {
            _MTLFX_PRIVATE_DEF_SEL( aspectRatio,
                                    "aspectRatio" );
            _MTLFX_PRIVATE_DEF_SEL( colorProcessingMode,
                                    "colorProcessingMode" );
            _MTLFX_PRIVATE_DEF_SEL( colorTexture,
                                    "colorTexture" );
            _MTLFX_PRIVATE_DEF_SEL( colorTextureFormat,
                                    "colorTextureFormat" );
            _MTLFX_PRIVATE_DEF_SEL( colorTextureUsage,
                                    "colorTextureUsage" );
            _MTLFX_PRIVATE_DEF_SEL( deltaTime,
                                    "deltaTime" );
            _MTLFX_PRIVATE_DEF_SEL( denoiseStrengthMaskTexture,
                                    "denoiseStrengthMaskTexture" );
            _MTLFX_PRIVATE_DEF_SEL( denoiseStrengthMaskTextureFormat,
                                    "denoiseStrengthMaskTextureFormat" );
            _MTLFX_PRIVATE_DEF_SEL( denoiseStrengthMaskTextureUsage,
                                    "denoiseStrengthMaskTextureUsage" );
            _MTLFX_PRIVATE_DEF_SEL( depthTexture,
                                    "depthTexture" );
            _MTLFX_PRIVATE_DEF_SEL( depthTextureFormat,
                                    "depthTextureFormat" );
            _MTLFX_PRIVATE_DEF_SEL( depthTextureUsage,
                                    "depthTextureUsage" );
            _MTLFX_PRIVATE_DEF_SEL( diffuseAlbedoTexture,
                                    "diffuseAlbedoTexture" );
            _MTLFX_PRIVATE_DEF_SEL( diffuseAlbedoTextureFormat,
                                    "diffuseAlbedoTextureFormat" );
            _MTLFX_PRIVATE_DEF_SEL( diffuseAlbedoTextureUsage,
                                    "diffuseAlbedoTextureUsage" );
            _MTLFX_PRIVATE_DEF_SEL( encodeToCommandBuffer_,
                                    "encodeToCommandBuffer:" );
            _MTLFX_PRIVATE_DEF_SEL( exposureTexture,
                                    "exposureTexture" );
            _MTLFX_PRIVATE_DEF_SEL( farPlane,
                                    "farPlane" );
            _MTLFX_PRIVATE_DEF_SEL( fence,
                                    "fence" );
            _MTLFX_PRIVATE_DEF_SEL( fieldOfView,
                                    "fieldOfView" );
            _MTLFX_PRIVATE_DEF_SEL( height,
                                    "height" );
            _MTLFX_PRIVATE_DEF_SEL( inputContentHeight,
                                    "inputContentHeight" );
            _MTLFX_PRIVATE_DEF_SEL( inputContentMaxScale,
                                    "inputContentMaxScale" );
            _MTLFX_PRIVATE_DEF_SEL( inputContentMinScale,
                                    "inputContentMinScale" );
            _MTLFX_PRIVATE_DEF_SEL( inputContentWidth,
                                    "inputContentWidth" );
            _MTLFX_PRIVATE_DEF_SEL( inputHeight,
                                    "inputHeight" );
            _MTLFX_PRIVATE_DEF_SEL( inputWidth,
                                    "inputWidth" );
            _MTLFX_PRIVATE_DEF_SEL( isAutoExposureEnabled,
                                    "isAutoExposureEnabled" );
            _MTLFX_PRIVATE_DEF_SEL( isDenoiseStrengthMaskTextureEnabled,
                                    "isDenoiseStrengthMaskTextureEnabled" );
            _MTLFX_PRIVATE_DEF_SEL( isDepthReversed,
                                    "isDepthReversed" );
            _MTLFX_PRIVATE_DEF_SEL( isInputContentPropertiesEnabled,
                                    "isInputContentPropertiesEnabled" );
            _MTLFX_PRIVATE_DEF_SEL( isTransparencyOverlayTextureEnabled,
                                    "isTransparencyOverlayTextureEnabled" );
            _MTLFX_PRIVATE_DEF_SEL( isReactiveMaskTextureEnabled,
                                    "isReactiveMaskTextureEnabled" );
            _MTLFX_PRIVATE_DEF_SEL( isSpecularHitDistanceTextureEnabled,
                                    "isSpecularHitDistanceTextureEnabled" );
            _MTLFX_PRIVATE_DEF_SEL( isUITextureComposited,
                                    "isUITextureComposited" );
            _MTLFX_PRIVATE_DEF_SEL( jitterOffsetX,
                                    "jitterOffsetX" );
            _MTLFX_PRIVATE_DEF_SEL( jitterOffsetY,
                                    "jitterOffsetY" );
            _MTLFX_PRIVATE_DEF_SEL( maskTexture,
                                    "maskTexture" );
            _MTLFX_PRIVATE_DEF_SEL( maskTextureFormat,
                                    "maskTextureFormat" );
            _MTLFX_PRIVATE_DEF_SEL( maskTextureUsage,
                                    "maskTextureUsage" );
            _MTLFX_PRIVATE_DEF_SEL( motionTexture,
                                    "motionTexture" );
            _MTLFX_PRIVATE_DEF_SEL( motionTextureFormat,
                                    "motionTextureFormat" );
            _MTLFX_PRIVATE_DEF_SEL( motionTextureUsage,
                                    "motionTextureUsage" );
            _MTLFX_PRIVATE_DEF_SEL( motionVectorScaleX,
                                    "motionVectorScaleX" );
            _MTLFX_PRIVATE_DEF_SEL( motionVectorScaleY,
                                    "motionVectorScaleY" );
            _MTLFX_PRIVATE_DEF_SEL( nearPlane,
                                    "nearPlane" );
            _MTLFX_PRIVATE_DEF_SEL( newFrameInterpolatorWithDevice_,
                                    "newFrameInterpolatorWithDevice:" );
            _MTLFX_PRIVATE_DEF_SEL( newFrameInterpolatorWithDevice_compiler_,
                                    "newFrameInterpolatorWithDevice:compiler:" );
            _MTLFX_PRIVATE_DEF_SEL( newTemporalDenoisedScalerWithDevice_,
                                    "newTemporalDenoisedScalerWithDevice:" );
            _MTLFX_PRIVATE_DEF_SEL( newTemporalDenoisedScalerWithDevice_compiler_,
                                    "newTemporalDenoisedScalerWithDevice:compiler:" );
            _MTLFX_PRIVATE_DEF_SEL( newSpatialScalerWithDevice_,
                                    "newSpatialScalerWithDevice:" );
            _MTLFX_PRIVATE_DEF_SEL( newSpatialScalerWithDevice_compiler_,
                                    "newSpatialScalerWithDevice:compiler:" );
            _MTLFX_PRIVATE_DEF_SEL( newTemporalScalerWithDevice_,
                                    "newTemporalScalerWithDevice:" );
            _MTLFX_PRIVATE_DEF_SEL( newTemporalScalerWithDevice_compiler_,
                                    "newTemporalScalerWithDevice:compiler:" );
            _MTLFX_PRIVATE_DEF_SEL( normalTexture,
                                    "normalTexture" );
            _MTLFX_PRIVATE_DEF_SEL( normalTextureFormat,
                                    "normalTextureFormat" );
            _MTLFX_PRIVATE_DEF_SEL( normalTextureUsage,
                                    "normalTextureUsage" );
            _MTLFX_PRIVATE_DEF_SEL( outputHeight,
                                    "outputHeight" );
            _MTLFX_PRIVATE_DEF_SEL( outputTexture,
                                    "outputTexture" );
            _MTLFX_PRIVATE_DEF_SEL( outputTextureFormat,
                                    "outputTextureFormat" );
            _MTLFX_PRIVATE_DEF_SEL( outputTextureUsage,
                                    "outputTextureUsage" );
            _MTLFX_PRIVATE_DEF_SEL( outputWidth,
                                    "outputWidth" );
            _MTLFX_PRIVATE_DEF_SEL( preExposure,
                                    "preExposure" );
            _MTLFX_PRIVATE_DEF_SEL( transparencyOverlayTextureFormat,
                                    "transparencyOverlayTextureFormat" );
            _MTLFX_PRIVATE_DEF_SEL( transparencyOverlayTextureUsage,
                                    "transparencyOverlayTextureUsage" );
            _MTLFX_PRIVATE_DEF_SEL( prevColorTexture,
                                    "prevColorTexture" );
            _MTLFX_PRIVATE_DEF_SEL( reactiveMaskTextureFormat,
                                    "reactiveMaskTextureFormat" );
            _MTLFX_PRIVATE_DEF_SEL( reactiveTextureUsage,
                                    "reactiveTextureUsage" );
            _MTLFX_PRIVATE_DEF_SEL( reactiveMaskTexture,
                                    "reactiveMaskTexture" );
            _MTLFX_PRIVATE_DEF_SEL( reset,
                                    "reset" );
            _MTLFX_PRIVATE_DEF_SEL( requiresSynchronousInitialization,
                                    "requiresSynchronousInitialization" );
            _MTLFX_PRIVATE_DEF_SEL( roughnessTextureFormat,
                                    "roughnessTextureFormat" );
            _MTLFX_PRIVATE_DEF_SEL( roughnessTextureUsage,
                                    "roughnessTextureUsage" );
            _MTLFX_PRIVATE_DEF_SEL( scaler,
                                    "scaler" );
            _MTLFX_PRIVATE_DEF_SEL( scaler4,
                                    "scaler4" );
            _MTLFX_PRIVATE_DEF_SEL( setAspectRatio_,
                                    "setAspectRatio:" );
            _MTLFX_PRIVATE_DEF_SEL( setAutoExposureEnabled_,
                                    "setAutoExposureEnabled:" );
            _MTLFX_PRIVATE_DEF_SEL( setColorProcessingMode_,
                                    "setColorProcessingMode:" );
            _MTLFX_PRIVATE_DEF_SEL( setColorTexture_,
                                    "setColorTexture:" );
            _MTLFX_PRIVATE_DEF_SEL( setColorTextureFormat_,
                                    "setColorTextureFormat:" );
            _MTLFX_PRIVATE_DEF_SEL( setDeltaTime_,
                                    "setDeltaTime:" );
            _MTLFX_PRIVATE_DEF_SEL( setDenoiseStrengthMaskTexture_,
                                    "setDenoiseStrengthMaskTexture:" );
            _MTLFX_PRIVATE_DEF_SEL( setDenoiseStrengthMaskTextureEnabled_,
                                    "setDenoiseStrengthMaskTextureEnabled:" );
            _MTLFX_PRIVATE_DEF_SEL( setDenoiseStrengthMaskTextureFormat_,
                                    "setDenoiseStrengthMaskTextureFormat:" );
            _MTLFX_PRIVATE_DEF_SEL( setDepthInverted_,
                                    "setDepthInverted:" );
            _MTLFX_PRIVATE_DEF_SEL( setDepthReversed_,
                                    "setDepthReversed:" );
            _MTLFX_PRIVATE_DEF_SEL( setDepthTexture_,
                                    "setDepthTexture:" );
            _MTLFX_PRIVATE_DEF_SEL( setDepthTextureFormat_,
                                    "setDepthTextureFormat:" );
            _MTLFX_PRIVATE_DEF_SEL( setDiffuseAlbedoTexture_,
                                    "setDiffuseAlbedoTexture:" );
            _MTLFX_PRIVATE_DEF_SEL( setDiffuseAlbedoTextureFormat_,
                                    "setDiffuseAlbedoTextureFormat:" );
            _MTLFX_PRIVATE_DEF_SEL( setExposureTexture_,
                                    "setExposureTexture:" );
            _MTLFX_PRIVATE_DEF_SEL( setFarPlane_,
                                    "setFarPlane:" );
            _MTLFX_PRIVATE_DEF_SEL( setFence_,
                                    "setFence:" );
            _MTLFX_PRIVATE_DEF_SEL( setFieldOfView_,
                                    "setFieldOfView:" );
            _MTLFX_PRIVATE_DEF_SEL( setHeight_,
                                    "setHeight:" );
            _MTLFX_PRIVATE_DEF_SEL( setInputContentHeight_,
                                    "setInputContentHeight:" );
            _MTLFX_PRIVATE_DEF_SEL( setInputContentMaxScale_,
                                    "setInputContentMaxScale:" );
            _MTLFX_PRIVATE_DEF_SEL( setInputContentMinScale_,
                                    "setInputContentMinScale:" );
            _MTLFX_PRIVATE_DEF_SEL( setInputContentPropertiesEnabled_,
                                    "setInputContentPropertiesEnabled:" );
            _MTLFX_PRIVATE_DEF_SEL( setInputContentWidth_,
                                    "setInputContentWidth:" );
            _MTLFX_PRIVATE_DEF_SEL( setInputHeight_,
                                    "setInputHeight:" );
            _MTLFX_PRIVATE_DEF_SEL( setInputWidth_,
                                    "setInputWidth:" );
            _MTLFX_PRIVATE_DEF_SEL( setIsUITextureComposited_,
                                    "setIsUITextureComposited:" );
            _MTLFX_PRIVATE_DEF_SEL( setJitterOffsetX_,
                                    "setJitterOffsetX:" );
            _MTLFX_PRIVATE_DEF_SEL( setJitterOffsetY_,
                                    "setJitterOffsetY:" );
            _MTLFX_PRIVATE_DEF_SEL( setNearPlane_,
                                    "setNearPlane:" );
            _MTLFX_PRIVATE_DEF_SEL( setMaskTexture_,
                                    "setMaskTexture:" );
            _MTLFX_PRIVATE_DEF_SEL( setMaskTextureFormat_,
                                    "setMaskTextureFormat:" );
            _MTLFX_PRIVATE_DEF_SEL( setMotionTexture_,
                                    "setMotionTexture:" );
            _MTLFX_PRIVATE_DEF_SEL( setMotionTextureFormat_,
                                    "setMotionTextureFormat:" );
            _MTLFX_PRIVATE_DEF_SEL( setMotionVectorScaleX_,
                                    "setMotionVectorScaleX:" );
            _MTLFX_PRIVATE_DEF_SEL( setMotionVectorScaleY_,
                                    "setMotionVectorScaleY:" );
            _MTLFX_PRIVATE_DEF_SEL( setNormalTexture_,
                                    "setNormalTexture:" );
            _MTLFX_PRIVATE_DEF_SEL( setNormalTextureFormat_,
                                    "setNormalTextureFormat:" );
            _MTLFX_PRIVATE_DEF_SEL( setOutputHeight_,
                                    "setOutputHeight:" );
            _MTLFX_PRIVATE_DEF_SEL( setOutputTexture_,
                                    "setOutputTexture:" );
            _MTLFX_PRIVATE_DEF_SEL( setOutputTextureFormat_,
                                    "setOutputTextureFormat:" );
            _MTLFX_PRIVATE_DEF_SEL( setOutputWidth_,
                                    "setOutputWidth:" );
            _MTLFX_PRIVATE_DEF_SEL( transparencyOverlayTexture,
                                    "transparencyOverlayTexture" );
            _MTLFX_PRIVATE_DEF_SEL( setTransparencyOverlayTexture_,
                                    "setTransparencyOverlayTexture:" );
            _MTLFX_PRIVATE_DEF_SEL( setTransparencyOverlayTextureEnabled_,
                                    "setTransparencyOverlayTextureEnabled:" );
            _MTLFX_PRIVATE_DEF_SEL( setPreExposure_,
                                    "setPreExposure:" );
            _MTLFX_PRIVATE_DEF_SEL( setTransparencyOverlayTextureFormat_,
                                    "setTransparencyOverlayTextureFormat:" );
            _MTLFX_PRIVATE_DEF_SEL( setPrevColorTexture_,
                                    "setPrevColorTexture:" );
            _MTLFX_PRIVATE_DEF_SEL( setReactiveMaskTexture_,
                                    "setReactiveMaskTexture:" );
            _MTLFX_PRIVATE_DEF_SEL( setReactiveMaskTextureEnabled_,
                                    "setReactiveMaskTextureEnabled:" );
            _MTLFX_PRIVATE_DEF_SEL( setReactiveMaskTextureFormat_,
                                    "setReactiveMaskTextureFormat:" );
            _MTLFX_PRIVATE_DEF_SEL( setRequiresSynchronousInitialization_,
                                    "setRequiresSynchronousInitialization:" );
            _MTLFX_PRIVATE_DEF_SEL( setReset_,
                                    "setReset:" );
            _MTLFX_PRIVATE_DEF_SEL( roughnessTexture,
                                    "roughnessTexture" );
            _MTLFX_PRIVATE_DEF_SEL( setRoughnessTexture_,
                                    "setRoughnessTexture:" );
            _MTLFX_PRIVATE_DEF_SEL( setRoughnessTextureFormat_,
                                    "setRoughnessTextureFormat:" );
            _MTLFX_PRIVATE_DEF_SEL( setScaler_,
                                    "setScaler:" );
            _MTLFX_PRIVATE_DEF_SEL( setShouldResetHistory_,
                                    "setShouldResetHistory:" );
            _MTLFX_PRIVATE_DEF_SEL( specularHitDistanceTexture,
                                    "specularHitDistanceTexture" );
            _MTLFX_PRIVATE_DEF_SEL( setSpecularHitDistanceTexture_,
                                    "setSpecularHitDistanceTexture:" );
            _MTLFX_PRIVATE_DEF_SEL( setSpecularHitDistanceTextureEnabled_,
                                    "setSpecularHitDistanceTextureEnabled:" );
            _MTLFX_PRIVATE_DEF_SEL( setSpecularAlbedoTexture_,
                                    "setSpecularAlbedoTexture:" );
            _MTLFX_PRIVATE_DEF_SEL( setSpecularAlbedoTextureFormat_,
                                    "setSpecularAlbedoTextureFormat:" );
            _MTLFX_PRIVATE_DEF_SEL( setSpecularHitDistanceTextureFormat_,
                                    "setSpecularHitDistanceTextureFormat:" );
            _MTLFX_PRIVATE_DEF_SEL( setUITexture_,
                                    "setUITexture:" );
            _MTLFX_PRIVATE_DEF_SEL( setUITextureFormat_,
                                    "setUITextureFormat:" );
            _MTLFX_PRIVATE_DEF_SEL( setViewToClipMatrix_,
                                    "setViewToClipMatrix:" );
            _MTLFX_PRIVATE_DEF_SEL( setWidth_,
                                    "setWidth:" );
            _MTLFX_PRIVATE_DEF_SEL( setWorldToViewMatrix_,
                                    "setWorldToViewMatrix:" );
            _MTLFX_PRIVATE_DEF_SEL( shouldResetHistory,
                                    "shouldResetHistory" );
            _MTLFX_PRIVATE_DEF_SEL( specularAlbedoTexture,
                                    "specularAlbedoTexture" );
            _MTLFX_PRIVATE_DEF_SEL( specularAlbedoTextureFormat,
                                    "specularAlbedoTextureFormat" );
            _MTLFX_PRIVATE_DEF_SEL( specularAlbedoTextureUsage,
                                    "specularAlbedoTextureUsage" );
            _MTLFX_PRIVATE_DEF_SEL( specularHitDistanceTextureFormat,
                                    "specularHitDistanceTextureFormat" );
            _MTLFX_PRIVATE_DEF_SEL( specularHitDistanceTextureUsage,
                                    "specularHitDistanceTextureUsage" );
            _MTLFX_PRIVATE_DEF_SEL( supportedInputContentMaxScaleForDevice_,
                                    "supportedInputContentMaxScaleForDevice:" );
            _MTLFX_PRIVATE_DEF_SEL( supportedInputContentMinScaleForDevice_,
                                    "supportedInputContentMinScaleForDevice:" );
            _MTLFX_PRIVATE_DEF_SEL( supportsDevice_,
                                    "supportsDevice:" );
            _MTLFX_PRIVATE_DEF_SEL( supportsMetal4FX_,
                                    "supportsMetal4FX:" );
            _MTLFX_PRIVATE_DEF_SEL( uiTexture,
                                    "uiTexture" );
            _MTLFX_PRIVATE_DEF_SEL( uiTextureFormat,
                                    "uiTextureFormat" );
            _MTLFX_PRIVATE_DEF_SEL( uiTextureUsage,
                                    "uiTextureFormat" );
            _MTLFX_PRIVATE_DEF_SEL( viewToClipMatrix,
                                    "viewToClipMatrix" );
            _MTLFX_PRIVATE_DEF_SEL( width,
                                    "width" );
            _MTLFX_PRIVATE_DEF_SEL( worldToViewMatrix,
                                    "worldToViewMatrix" );
        } // Selector
    } // Private
} // MTLFX

namespace MTL4FX
{
    class SpatialScaler;
}

namespace MTLFX
{
    _MTLFX_ENUM( NS::Integer, SpatialScalerColorProcessingMode )
    {
        SpatialScalerColorProcessingModePerceptual  = 0,
        SpatialScalerColorProcessingModeLinear      = 1,
        SpatialScalerColorProcessingModeHDR         = 2
    };

    class SpatialScalerDescriptor : public NS::Copying< SpatialScalerDescriptor >
    {
    public:
        static class SpatialScalerDescriptor*       alloc();
        class SpatialScalerDescriptor*              init();

        MTL::PixelFormat                            colorTextureFormat() const;
        void                                        setColorTextureFormat( MTL::PixelFormat format );

        MTL::PixelFormat                            outputTextureFormat() const;
        void                                        setOutputTextureFormat( MTL::PixelFormat format );

        NS::UInteger                                inputWidth() const;
        void                                        setInputWidth( NS::UInteger width );

        NS::UInteger                                inputHeight() const;
        void                                        setInputHeight( NS::UInteger height );

        NS::UInteger                                outputWidth() const;
        void                                        setOutputWidth( NS::UInteger width );

        NS::UInteger                                outputHeight() const;
        void                                        setOutputHeight( NS::UInteger height );

        SpatialScalerColorProcessingMode            colorProcessingMode() const;
        void                                        setColorProcessingMode( SpatialScalerColorProcessingMode mode );

        class SpatialScaler*                        newSpatialScaler( const MTL::Device* pDevice ) const;
        MTL4FX::SpatialScaler*                      newSpatialScaler( const MTL::Device* pDevice, const MTL4::Compiler* pCompiler ) const;

        static bool                                 supportsDevice( const MTL::Device* pDevice);
        static bool                                 supportsMetal4FX( const MTL::Device* pDevice );
    };

    class SpatialScalerBase : public NS::Referencing< SpatialScaler >
    {
    public:
        MTL::TextureUsage                           colorTextureUsage() const;
        MTL::TextureUsage                           outputTextureUsage() const;

        NS::UInteger                                inputContentWidth() const;
        void                                        setInputContentWidth( NS::UInteger width );

        NS::UInteger                                inputContentHeight() const;
        void                                        setInputContentHeight( NS::UInteger height );

        MTL::Texture*                               colorTexture() const;
        void                                        setColorTexture( MTL::Texture* pTexture );

        MTL::Texture*                               outputTexture() const;
        void                                        setOutputTexture( MTL::Texture* pTexture );

        MTL::PixelFormat                            colorTextureFormat() const;
        MTL::PixelFormat                            outputTextureFormat() const;
        NS::UInteger                                inputWidth() const;
        NS::UInteger                                inputHeight() const;
        NS::UInteger                                outputWidth() const;
        NS::UInteger                                outputHeight() const;
        SpatialScalerColorProcessingMode            colorProcessingMode() const;

        MTL::Fence*                                 fence() const;
        void                                        setFence( MTL::Fence* pFence );
    };

    class SpatialScaler : public NS::Referencing< SpatialScaler, SpatialScalerBase >
    {
    public:
        void                                        encodeToCommandBuffer( MTL::CommandBuffer* pCommandBuffer );
    };
}

_MTLFX_INLINE MTLFX::SpatialScalerDescriptor* MTLFX::SpatialScalerDescriptor::alloc()
{
    return NS::Object::alloc< SpatialScalerDescriptor >( _MTLFX_PRIVATE_CLS( MTLFXSpatialScalerDescriptor ) );
}

_MTLFX_INLINE MTLFX::SpatialScalerDescriptor* MTLFX::SpatialScalerDescriptor::init()
{
    return NS::Object::init< SpatialScalerDescriptor >();
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::SpatialScalerDescriptor::colorTextureFormat() const
{
    return Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( colorTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::SpatialScalerDescriptor::setColorTextureFormat( MTL::PixelFormat format )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setColorTextureFormat_ ), format );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::SpatialScalerDescriptor::outputTextureFormat() const
{
    return Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( outputTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::SpatialScalerDescriptor::setOutputTextureFormat( MTL::PixelFormat format )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setOutputTextureFormat_ ), format );
}

_MTLFX_INLINE NS::UInteger MTLFX::SpatialScalerDescriptor::inputWidth() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputWidth ) );
}

_MTLFX_INLINE void MTLFX::SpatialScalerDescriptor::setInputWidth( NS::UInteger width )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setInputWidth_ ), width );
}

_MTLFX_INLINE NS::UInteger MTLFX::SpatialScalerDescriptor::inputHeight() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputHeight ) );
}

_MTLFX_INLINE void MTLFX::SpatialScalerDescriptor::setInputHeight( NS::UInteger height )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setInputHeight_ ), height );
}

_MTLFX_INLINE NS::UInteger MTLFX::SpatialScalerDescriptor::outputWidth() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( outputWidth ) );
}

_MTLFX_INLINE void MTLFX::SpatialScalerDescriptor::setOutputWidth( NS::UInteger width )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setOutputWidth_ ), width );
}

_MTLFX_INLINE NS::UInteger MTLFX::SpatialScalerDescriptor::outputHeight() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( outputHeight ) );
}

_MTLFX_INLINE void MTLFX::SpatialScalerDescriptor::setOutputHeight( NS::UInteger height )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setOutputHeight_ ), height );
}

_MTLFX_INLINE MTLFX::SpatialScalerColorProcessingMode MTLFX::SpatialScalerDescriptor::colorProcessingMode() const
{
    return Object::sendMessage< SpatialScalerColorProcessingMode >( this, _MTLFX_PRIVATE_SEL( colorProcessingMode ) );
}

_MTLFX_INLINE void MTLFX::SpatialScalerDescriptor::setColorProcessingMode( SpatialScalerColorProcessingMode mode )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setColorProcessingMode_ ), mode );
}

_MTLFX_INLINE MTLFX::SpatialScaler* MTLFX::SpatialScalerDescriptor::newSpatialScaler( const MTL::Device* pDevice ) const
{
    return Object::sendMessage< SpatialScaler* >( this, _MTLFX_PRIVATE_SEL( newSpatialScalerWithDevice_ ), pDevice );
}

_MTLFX_INLINE MTL4FX::SpatialScaler* MTLFX::SpatialScalerDescriptor::newSpatialScaler( const MTL::Device* pDevice, const MTL4::Compiler* pCompiler ) const
{
    return Object::sendMessage< MTL4FX::SpatialScaler* >( this, _MTLFX_PRIVATE_SEL( newSpatialScalerWithDevice_compiler_ ), pDevice, pCompiler );
}

_MTLFX_INLINE bool MTLFX::SpatialScalerDescriptor::supportsDevice( const MTL::Device* pDevice )
{
    return Object::sendMessageSafe< bool >( _NS_PRIVATE_CLS( MTLFXSpatialScalerDescriptor ), _MTLFX_PRIVATE_SEL( supportsDevice_ ), pDevice );
}

_MTLFX_INLINE bool MTLFX::SpatialScalerDescriptor::supportsMetal4FX( const MTL::Device* pDevice )
{
    return Object::sendMessageSafe< bool >( _NS_PRIVATE_CLS( MTLFXSpatialScalerDescriptor ), _MTLFX_PRIVATE_SEL( supportsMetal4FX_ ), pDevice );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::SpatialScalerBase::colorTextureUsage() const
{
    return Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( colorTextureUsage ) );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::SpatialScalerBase::outputTextureUsage() const
{
    return Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( outputTextureUsage ) );
}

_MTLFX_INLINE NS::UInteger MTLFX::SpatialScalerBase::inputContentWidth() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputContentWidth ) );
}

_MTLFX_INLINE void MTLFX::SpatialScalerBase::setInputContentWidth( NS::UInteger width )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setInputContentWidth_ ), width );
}

_MTLFX_INLINE NS::UInteger MTLFX::SpatialScalerBase::inputContentHeight() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputContentHeight ) );
}

_MTLFX_INLINE void MTLFX::SpatialScalerBase::setInputContentHeight( NS::UInteger height )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setInputContentHeight_ ), height );
}

_MTLFX_INLINE MTL::Texture* MTLFX::SpatialScalerBase::colorTexture() const
{
    return Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( colorTexture ) );
}

_MTLFX_INLINE void MTLFX::SpatialScalerBase::setColorTexture( MTL::Texture* pTexture )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setColorTexture_ ), pTexture );
}

_MTLFX_INLINE MTL::Texture* MTLFX::SpatialScalerBase::outputTexture() const
{
    return Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( outputTexture ) );
}

_MTLFX_INLINE void MTLFX::SpatialScalerBase::setOutputTexture( MTL::Texture* pTexture )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setOutputTexture_ ), pTexture );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::SpatialScalerBase::colorTextureFormat() const
{
    return Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( colorTextureFormat ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::SpatialScalerBase::outputTextureFormat() const
{
    return Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( outputTextureFormat ) );
}

_MTLFX_INLINE NS::UInteger MTLFX::SpatialScalerBase::inputWidth() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputWidth ) );
}

_MTLFX_INLINE NS::UInteger MTLFX::SpatialScalerBase::inputHeight() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputHeight ) );
}

_MTLFX_INLINE NS::UInteger MTLFX::SpatialScalerBase::outputWidth() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( outputWidth ) );
}

_MTLFX_INLINE NS::UInteger MTLFX::SpatialScalerBase::outputHeight() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( outputHeight ) );
}

_MTLFX_INLINE MTLFX::SpatialScalerColorProcessingMode MTLFX::SpatialScalerBase::colorProcessingMode() const
{
    return Object::sendMessage< SpatialScalerColorProcessingMode >( this, _MTLFX_PRIVATE_SEL( colorProcessingMode ) );
}

_MTLFX_INLINE MTL::Fence* MTLFX::SpatialScalerBase::fence() const
{
    return Object::sendMessage< MTL::Fence* >( this, _MTLFX_PRIVATE_SEL( fence ) );
}

_MTLFX_INLINE void MTLFX::SpatialScalerBase::setFence( MTL::Fence* pFence )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setFence_ ), pFence );
}

_MTLFX_INLINE void MTLFX::SpatialScaler::encodeToCommandBuffer( MTL::CommandBuffer* pCommandBuffer )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( encodeToCommandBuffer_ ), pCommandBuffer );
}

namespace MTL4FX
{
    class TemporalScaler;
}

namespace MTLFX
{
    class TemporalScalerDescriptor : public NS::Copying< TemporalScalerDescriptor >
    {
    public:
        static class TemporalScalerDescriptor*      alloc();
        class TemporalScalerDescriptor*             init();

        MTL::PixelFormat                            colorTextureFormat() const;
        void                                        setColorTextureFormat( MTL::PixelFormat format );

        MTL::PixelFormat                            depthTextureFormat() const;
        void                                        setDepthTextureFormat( MTL::PixelFormat format );

        MTL::PixelFormat                            motionTextureFormat() const;
        void                                        setMotionTextureFormat( MTL::PixelFormat format );

        MTL::PixelFormat                            outputTextureFormat() const;
        void                                        setOutputTextureFormat( MTL::PixelFormat format );

        NS::UInteger                                inputWidth() const;
        void                                        setInputWidth( NS::UInteger width );

        NS::UInteger                                inputHeight() const;
        void                                        setInputHeight( NS::UInteger height );

        NS::UInteger                                outputWidth() const;
        void                                        setOutputWidth( NS::UInteger width );

        NS::UInteger                                outputHeight() const;
        void                                        setOutputHeight( NS::UInteger height );

        bool                                        isAutoExposureEnabled() const;
        void                                        setAutoExposureEnabled( bool enabled );

        bool                                        isInputContentPropertiesEnabled() const;
        void                                        setInputContentPropertiesEnabled( bool enabled );

        bool                                        requiresSynchronousInitialization() const;
        void                                        setRequiresSynchronousInitialization(bool requiresSynchronousInitialization);

        bool                                        isReactiveMaskTextureEnabled() const;
        void                                        setReactiveMaskTextureEnabled( bool enabled );

        MTL::PixelFormat                            reactiveMaskTextureFormat() const;
        void                                        setReactiveMaskTextureFormat( MTL::PixelFormat pixelFormat );

        float                                       inputContentMinScale() const;
        void                                        setInputContentMinScale( float scale );

        float                                       inputContentMaxScale() const;
        void                                        setInputContentMaxScale( float scale );

        class TemporalScaler*                       newTemporalScaler( const MTL::Device* pDevice ) const;
        MTL4FX::TemporalScaler*                     newTemporalScaler( const MTL::Device* pDevice, const MTL4::Compiler* pCompiler) const;

        static float                                supportedInputContentMinScale( const MTL::Device* pDevice );
        static float                                supportedInputContentMaxScale( const MTL::Device* pDevice );

        static bool                                 supportsDevice( const MTL::Device* pDevice );
        static bool                                 supportsMetal4FX( const MTL::Device* pDevice );
    };

    class FrameInterpolatableScaler : public NS::Copying< FrameInterpolatableScaler >
    {
	};

    class TemporalScalerBase : public NS::Referencing< TemporalScaler, FrameInterpolatableScaler >
    {
    public:
        MTL::TextureUsage                           colorTextureUsage() const;
        MTL::TextureUsage                           depthTextureUsage() const;
        MTL::TextureUsage                           motionTextureUsage() const;
        MTL::TextureUsage                           outputTextureUsage() const;

        NS::UInteger                                inputContentWidth() const;
        void                                        setInputContentWidth( NS::UInteger width );

        NS::UInteger                                inputContentHeight() const;
        void                                        setInputContentHeight( NS::UInteger height );

        MTL::Texture*                               colorTexture() const;
        void                                        setColorTexture( MTL::Texture* pTexture );

        MTL::Texture*                               depthTexture() const;
        void                                        setDepthTexture( MTL::Texture* pTexture );

        MTL::Texture*                               motionTexture() const;
        void                                        setMotionTexture( MTL::Texture* pTexture );

        MTL::Texture*                               outputTexture() const;
        void                                        setOutputTexture( MTL::Texture* pTexture );

        MTL::Texture*                               exposureTexture() const;
        void                                        setExposureTexture( MTL::Texture* pTexture );

        float                                       preExposure() const;
        void                                        setPreExposure( float preExposure );
        
        float                                       jitterOffsetX() const;
        void                                        setJitterOffsetX( float offset );

        float                                       jitterOffsetY() const;
        void                                        setJitterOffsetY( float offset );

        float                                       motionVectorScaleX() const;
        void                                        setMotionVectorScaleX( float scale );

        float                                       motionVectorScaleY() const;
        void                                        setMotionVectorScaleY( float scale );

        MTL::Texture*                               reactiveMaskTexture() const;
        void                                        setReactiveMaskTexture( MTL::Texture* reactiveMaskTexture );

        MTL::TextureUsage                           reactiveTextureUsage() const;

        bool                                        reset() const;
        void                                        setReset( bool reset );

        bool                                        isDepthReversed() const;
        void                                        setDepthReversed( bool depthReversed );

        MTL::PixelFormat                            colorTextureFormat() const;
        MTL::PixelFormat                            depthTextureFormat() const;
        MTL::PixelFormat                            motionTextureFormat() const;
        MTL::PixelFormat                            reactiveTextureFormat() const;
        MTL::PixelFormat                            outputTextureFormat() const;
        NS::UInteger                                inputWidth() const;
        NS::UInteger                                inputHeight() const;
        NS::UInteger                                outputWidth() const;
        NS::UInteger                                outputHeight() const;
        float                                       inputContentMinScale() const;
        float                                       inputContentMaxScale() const;

        MTL::Fence*                                 fence() const;
        void                                        setFence( MTL::Fence* pFence );
    };

    class TemporalScaler : public NS::Referencing< TemporalScaler, TemporalScalerBase >
    {
    public:
        void                                        encodeToCommandBuffer( MTL::CommandBuffer* pCommandBuffer );
    };
}

_MTLFX_INLINE MTLFX::TemporalScalerDescriptor* MTLFX::TemporalScalerDescriptor::alloc()
{
    return NS::Object::alloc< TemporalScalerDescriptor >( _MTLFX_PRIVATE_CLS( MTLFXTemporalScalerDescriptor ) );
}

_MTLFX_INLINE MTLFX::TemporalScalerDescriptor* MTLFX::TemporalScalerDescriptor::init()
{
    return NS::Object::init< TemporalScalerDescriptor >();
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalScalerDescriptor::colorTextureFormat() const
{
    return Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( colorTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerDescriptor::setColorTextureFormat( MTL::PixelFormat format )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setColorTextureFormat_ ), format );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalScalerDescriptor::depthTextureFormat() const
{
    return Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( depthTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerDescriptor::setDepthTextureFormat( MTL::PixelFormat format )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setDepthTextureFormat_ ), format );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalScalerDescriptor::motionTextureFormat() const
{
    return Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( motionTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerDescriptor::setMotionTextureFormat( MTL::PixelFormat format )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setMotionTextureFormat_ ), format );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalScalerDescriptor::outputTextureFormat() const
{
    return Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( outputTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerDescriptor::setOutputTextureFormat( MTL::PixelFormat format )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setOutputTextureFormat_ ), format );
}

_MTLFX_INLINE NS::UInteger MTLFX::TemporalScalerDescriptor::inputWidth() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputWidth ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerDescriptor::setInputWidth( NS::UInteger width )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setInputWidth_ ), width );
}

_MTLFX_INLINE NS::UInteger MTLFX::TemporalScalerDescriptor::inputHeight() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputHeight ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerDescriptor::setInputHeight( NS::UInteger height )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setInputHeight_ ), height );
}

_MTLFX_INLINE NS::UInteger MTLFX::TemporalScalerDescriptor::outputWidth() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( outputWidth ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerDescriptor::setOutputWidth( NS::UInteger width )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setOutputWidth_ ), width );
}

_MTLFX_INLINE NS::UInteger MTLFX::TemporalScalerDescriptor::outputHeight() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( outputHeight ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerDescriptor::setOutputHeight( NS::UInteger height )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setOutputHeight_ ), height );
}

_MTLFX_INLINE bool MTLFX::TemporalScalerDescriptor::isAutoExposureEnabled() const
{
    return Object::sendMessage< bool >( this, _MTLFX_PRIVATE_SEL( isAutoExposureEnabled ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerDescriptor::setAutoExposureEnabled( bool enabled )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setAutoExposureEnabled_ ), enabled );
}

_MTLFX_INLINE bool MTLFX::TemporalScalerDescriptor::isInputContentPropertiesEnabled() const
{
    return Object::sendMessage< bool >( this, _MTLFX_PRIVATE_SEL( isInputContentPropertiesEnabled ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerDescriptor::setInputContentPropertiesEnabled( bool enabled )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setInputContentPropertiesEnabled_ ), enabled );
}

_MTLFX_INLINE bool MTLFX::TemporalScalerDescriptor::requiresSynchronousInitialization() const
{
    return Object::sendMessage< bool >( this, _MTLFX_PRIVATE_SEL( requiresSynchronousInitialization ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerDescriptor::setRequiresSynchronousInitialization(bool requiresSynchronousInitialization)
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setRequiresSynchronousInitialization_ ), requiresSynchronousInitialization );
}

_MTLFX_INLINE bool MTLFX::TemporalScalerDescriptor::isReactiveMaskTextureEnabled() const
{
    return Object::sendMessage< bool >( this, _MTLFX_PRIVATE_SEL( isReactiveMaskTextureEnabled ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerDescriptor::setReactiveMaskTextureEnabled( bool enabled )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setReactiveMaskTextureEnabled_ ), enabled );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalScalerDescriptor::reactiveMaskTextureFormat() const
{
    return Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( reactiveMaskTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerDescriptor::setReactiveMaskTextureFormat( MTL::PixelFormat pixelFormat )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setReactiveMaskTextureFormat_ ), pixelFormat );
}

_MTLFX_INLINE float MTLFX::TemporalScalerDescriptor::inputContentMinScale() const
{
    return Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( inputContentMinScale ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerDescriptor::setInputContentMinScale( float scale )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setInputContentMinScale_ ), scale );
}

_MTLFX_INLINE float MTLFX::TemporalScalerDescriptor::inputContentMaxScale() const
{
    return Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( inputContentMaxScale ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerDescriptor::setInputContentMaxScale( float scale )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setInputContentMaxScale_ ), scale );
}

_MTLFX_INLINE MTLFX::TemporalScaler* MTLFX::TemporalScalerDescriptor::newTemporalScaler( const MTL::Device* pDevice ) const
{
    return Object::sendMessage< TemporalScaler* >( this, _MTLFX_PRIVATE_SEL( newTemporalScalerWithDevice_ ), pDevice );
}

_MTLFX_INLINE MTL4FX::TemporalScaler* MTLFX::TemporalScalerDescriptor::newTemporalScaler( const MTL::Device* pDevice, const MTL4::Compiler* pCompiler ) const
{
    return Object::sendMessage< MTL4FX::TemporalScaler* >( this, _MTLFX_PRIVATE_SEL( newTemporalScalerWithDevice_compiler_ ), pDevice, pCompiler );
}

_MTLFX_INLINE float MTLFX::TemporalScalerDescriptor::supportedInputContentMinScale( const MTL::Device* pDevice )
{
    float scale = 1.0f;

    if ( nullptr != methodSignatureForSelector( _NS_PRIVATE_CLS( MTLFXTemporalScalerDescriptor ), _MTLFX_PRIVATE_SEL( supportedInputContentMinScaleForDevice_ ) ) )
    {
        scale = sendMessage< float >( _NS_PRIVATE_CLS( MTLFXTemporalScalerDescriptor ), _MTLFX_PRIVATE_SEL( supportedInputContentMinScaleForDevice_ ), pDevice );
    }

    return scale;
}

_MTLFX_INLINE float MTLFX::TemporalScalerDescriptor::supportedInputContentMaxScale( const MTL::Device* pDevice )
{
    float scale = 1.0f;

    if ( nullptr != methodSignatureForSelector( _NS_PRIVATE_CLS( MTLFXTemporalScalerDescriptor ), _MTLFX_PRIVATE_SEL( supportedInputContentMaxScaleForDevice_ ) ) )
    {
        scale = sendMessage< float >( _NS_PRIVATE_CLS( MTLFXTemporalScalerDescriptor ), _MTLFX_PRIVATE_SEL( supportedInputContentMaxScaleForDevice_ ), pDevice );
    }
    else if ( supportsDevice( pDevice ) )
    {
        scale = 2.0f;
    }

    return scale;
}

_MTLFX_INLINE bool MTLFX::TemporalScalerDescriptor::supportsDevice( const MTL::Device* pDevice )
{
    return Object::sendMessageSafe< bool >( _NS_PRIVATE_CLS( MTLFXTemporalScalerDescriptor ), _MTLFX_PRIVATE_SEL( supportsDevice_ ), pDevice );
}

_MTLFX_INLINE bool MTLFX::TemporalScalerDescriptor::supportsMetal4FX( const MTL::Device* pDevice )
{
    return Object::sendMessageSafe< bool >( _NS_PRIVATE_CLS( MTLFXTemporalScalerDescriptor ), _MTLFX_PRIVATE_SEL( supportsMetal4FX_ ), pDevice );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::TemporalScalerBase::colorTextureUsage() const
{
    return Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( colorTextureUsage ) );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::TemporalScalerBase::depthTextureUsage() const
{
    return Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( depthTextureUsage ) );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::TemporalScalerBase::motionTextureUsage() const
{
    return Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( motionTextureUsage ) );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::TemporalScalerBase::outputTextureUsage() const
{
    return Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( outputTextureUsage ) );
}

_MTLFX_INLINE NS::UInteger MTLFX::TemporalScalerBase::inputContentWidth() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputContentWidth ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerBase::setInputContentWidth( NS::UInteger width )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setInputContentWidth_ ), width );
}

_MTLFX_INLINE NS::UInteger MTLFX::TemporalScalerBase::inputContentHeight() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputContentHeight ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerBase::setInputContentHeight( NS::UInteger height )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setInputContentHeight_ ), height );
}

_MTLFX_INLINE MTL::Texture* MTLFX::TemporalScalerBase::colorTexture() const
{
    return Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( colorTexture ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerBase::setColorTexture( MTL::Texture* pTexture )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setColorTexture_ ), pTexture );
}

_MTLFX_INLINE MTL::Texture* MTLFX::TemporalScalerBase::depthTexture() const
{
    return Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( depthTexture ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerBase::setDepthTexture( MTL::Texture* pTexture )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setDepthTexture_ ), pTexture );
}

_MTLFX_INLINE MTL::Texture* MTLFX::TemporalScalerBase::motionTexture() const
{
    return Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( motionTexture ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerBase::setMotionTexture( MTL::Texture* pTexture )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setMotionTexture_ ), pTexture );
}

_MTLFX_INLINE MTL::Texture* MTLFX::TemporalScalerBase::outputTexture() const
{
    return Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( outputTexture ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerBase::setOutputTexture( MTL::Texture* pTexture )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setOutputTexture_ ), pTexture );
}

_MTLFX_INLINE MTL::Texture* MTLFX::TemporalScalerBase::exposureTexture() const
{
    return Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( exposureTexture ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerBase::setExposureTexture( MTL::Texture* pTexture )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setExposureTexture_ ), pTexture );
}

_MTLFX_INLINE float MTLFX::TemporalScalerBase::preExposure() const
{
    return Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( preExposure ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerBase::setPreExposure( float preExposure )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setPreExposure_ ), preExposure );
}

_MTLFX_INLINE float MTLFX::TemporalScalerBase::jitterOffsetX() const
{
    return Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( jitterOffsetX ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerBase::setJitterOffsetX( float offset )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setJitterOffsetX_ ), offset );
}

_MTLFX_INLINE float MTLFX::TemporalScalerBase::jitterOffsetY() const
{
    return Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( jitterOffsetY ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerBase::setJitterOffsetY( float offset )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setJitterOffsetY_ ), offset );
}

_MTLFX_INLINE float MTLFX::TemporalScalerBase::motionVectorScaleX() const
{
    return Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( motionVectorScaleX ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerBase::setMotionVectorScaleX( float scale )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setMotionVectorScaleX_ ), scale );
}

_MTLFX_INLINE float MTLFX::TemporalScalerBase::motionVectorScaleY() const
{
    return Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( motionVectorScaleY ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerBase::setMotionVectorScaleY( float scale )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setMotionVectorScaleY_ ), scale );
}

_MTLFX_INLINE MTL::Texture* MTLFX::TemporalScalerBase::reactiveMaskTexture() const
{
    return Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( reactiveMaskTexture ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerBase::setReactiveMaskTexture( MTL::Texture* reactiveMaskTexture )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setReactiveMaskTexture_ ), reactiveMaskTexture );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::TemporalScalerBase::reactiveTextureUsage() const
{
    return Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( reactiveTextureUsage ) );
}

_MTLFX_INLINE bool MTLFX::TemporalScalerBase::reset() const
{
    return Object::sendMessage< bool >( this, _MTLFX_PRIVATE_SEL( reset ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerBase::setReset( bool reset )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setReset_ ), reset );
}

_MTLFX_INLINE bool MTLFX::TemporalScalerBase::isDepthReversed() const
{
    return Object::sendMessage< bool >( this, _MTLFX_PRIVATE_SEL( isDepthReversed ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerBase::setDepthReversed( bool depthReversed )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setDepthReversed_ ), depthReversed );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalScalerBase::colorTextureFormat() const
{
    return Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( colorTextureFormat ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalScalerBase::depthTextureFormat() const
{
    return Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( depthTextureFormat ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalScalerBase::motionTextureFormat() const
{
    return Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( motionTextureFormat ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalScalerBase::outputTextureFormat() const
{
    return Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( outputTextureFormat ) );
}

_MTLFX_INLINE NS::UInteger MTLFX::TemporalScalerBase::inputWidth() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputWidth ) );
}

_MTLFX_INLINE NS::UInteger MTLFX::TemporalScalerBase::inputHeight() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputHeight ) );
}

_MTLFX_INLINE NS::UInteger MTLFX::TemporalScalerBase::outputWidth() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( outputWidth ) );
}

_MTLFX_INLINE NS::UInteger MTLFX::TemporalScalerBase::outputHeight() const
{
    return Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( outputHeight ) );
}

_MTLFX_INLINE float MTLFX::TemporalScalerBase::inputContentMinScale() const
{
    return Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( inputContentMinScale ) );
}

_MTLFX_INLINE float MTLFX::TemporalScalerBase::inputContentMaxScale() const
{
    return Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( inputContentMaxScale ) );
}

_MTLFX_INLINE MTL::Fence* MTLFX::TemporalScalerBase::fence() const
{
    return Object::sendMessage< MTL::Fence* >( this, _MTLFX_PRIVATE_SEL( fence ) );
}

_MTLFX_INLINE void MTLFX::TemporalScalerBase::setFence( MTL::Fence* pFence )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setFence_ ), pFence );
}

_MTLFX_INLINE void MTLFX::TemporalScaler::encodeToCommandBuffer( MTL::CommandBuffer* pCommandBuffer )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( encodeToCommandBuffer_ ), pCommandBuffer );
}

#include <simd/simd.h>

namespace MTL4FX
{
    class TemporalDenoisedScaler;
}

namespace MTLFX
{
    class TemporalDenoisedScalerDescriptor : public NS::Copying< TemporalDenoisedScalerDescriptor >
    {
        public:
            static class TemporalDenoisedScalerDescriptor*       alloc();
            class TemporalDenoisedScalerDescriptor*              init();

            MTL::PixelFormat                                     colorTextureFormat() const;
            void                                                 setColorTextureFormat( MTL::PixelFormat pixelFormat );

            MTL::PixelFormat                                     depthTextureFormat() const;
            void                                                 setDepthTextureFormat( MTL::PixelFormat pixelFormat );

            MTL::PixelFormat                                     motionTextureFormat() const;
            void                                                 setMotionTextureFormat( MTL::PixelFormat pixelFormal );

            MTL::PixelFormat                                     diffuseAlbedoTextureFormat() const;
            void                                                 setDiffuseAlbedoTextureFormat( MTL::PixelFormat pixelFormat );

            MTL::PixelFormat                                     specularAlbedoTextureFormat() const;
            void                                                 setSpecularAlbedoTextureFormat( MTL::PixelFormat pixelFormat );

            MTL::PixelFormat                                     normalTextureFormat() const;
            void                                                 setNormalTextureFormat( MTL::PixelFormat pixelFormat );

            MTL::PixelFormat                                     roughnessTextureFormat() const;
            void                                                 setRoughnessTextureFormat( MTL::PixelFormat pixelFormat );

            MTL::PixelFormat                                     specularHitDistanceTextureFormat() const;
            void                                                 setSpecularHitDistanceTextureFormat( MTL::PixelFormat pixelFormat );

            MTL::PixelFormat                                     denoiseStrengthMaskTextureFormat() const;
            void                                                 setDenoiseStrengthMaskTextureFormat( MTL::PixelFormat pixelFormat );

            MTL::PixelFormat                                     transparencyOverlayTextureFormat() const;
            void                                                 setTransparencyOverlayTextureFormat( MTL::PixelFormat pixelFormat );

            MTL::PixelFormat                                     outputTextureFormat() const;
            void                                                 setOutputTextureFormat( MTL::PixelFormat pixelFormat );

            NS::UInteger                                         inputWidth() const;
            void                                                 setInputWidth( NS::UInteger inputWidth );

            NS::UInteger                                         inputHeight() const;
            void                                                 setInputHeight( NS::UInteger inputHeight );

            NS::UInteger                                         outputWidth() const;
            void                                                 setOutputWidth( NS::UInteger outputWidth );

            NS::UInteger                                         outputHeight() const;
            void                                                 setOutputHeight( NS::UInteger outputHeight );

            bool                                                 requiresSynchronousInitialization() const;
            void                                                 setRequiresSynchronousInitialization( bool requiresSynchronousInitialization );

            bool                                                 isAutoExposureEnabled() const;
            void                                                 setAutoExposureEnabled( bool enabled );

            bool                                                 isInputContentPropertiesEnabled() const;
            void                                                 setInputContentPropertiesEnabled( bool enabled );

            float                                                inputContentMinScale() const;
            void                                                 setInputContentMinScale( float inputContentMinScale );

            float                                                inputContentMaxScale() const;
            void                                                 setInputContentMaxScale( float inputContentMaxScale );

            bool                                                 isReactiveMaskTextureEnabled() const;
            void                                                 setReactiveMaskTextureEnabled( bool enabled );

            MTL::PixelFormat                                     reactiveMaskTextureFormat() const;
            void                                                 setReactiveMaskTextureFormat( MTL::PixelFormat pixelFormat );

            bool                                                 isSpecularHitDistanceTextureEnabled() const;
            void                                                 setSpecularHitDistanceTextureEnabled( bool enabled );

            bool                                                 isDenoiseStrengthMaskTextureEnabled() const;
            void                                                 setDenoiseStrengthMaskTextureEnabled( bool enabled );

            bool                                                 isTransparencyOverlayTextureEnabled() const;
            void                                                 setTransparencyOverlayTextureEnabled( bool enabled );

            class TemporalDenoisedScaler*                        newTemporalDenoisedScaler( const MTL::Device* device ) const;
            MTL4FX::TemporalDenoisedScaler*                      newTemporalDenoisedScaler( const MTL::Device* device, const MTL4::Compiler* compiler) const;

            static float                                         supportedInputContentMinScale(MTL::Device* device);
            static float                                         supportedInputContentMaxScale(MTL::Device* device);

            static bool                                          supportsMetal4FX( MTL::Device* device);
            static bool                                          supportsDevice( MTL::Device* device);
    };

    class TemporalDenoisedScalerBase : public NS::Referencing< TemporalDenoisedScalerBase, FrameInterpolatableScaler >
    {
    public:
        MTL::TextureUsage                                       colorTextureUsage() const;
        MTL::TextureUsage                                       depthTextureUsage() const;
        MTL::TextureUsage                                       motionTextureUsage() const;
        MTL::TextureUsage                                       reactiveTextureUsage() const;
        MTL::TextureUsage                                       diffuseAlbedoTextureUsage() const;
        MTL::TextureUsage                                       specularAlbedoTextureUsage() const;
        MTL::TextureUsage                                       normalTextureUsage() const;
        MTL::TextureUsage                                       roughnessTextureUsage() const;
        MTL::TextureUsage                                       specularHitDistanceTextureUsage() const;
        MTL::TextureUsage                                       denoiseStrengthMaskTextureUsage() const;
        MTL::TextureUsage                                       transparencyOverlayTextureUsage() const;
        MTL::TextureUsage                                       outputTextureUsage() const;

        MTL::Texture*                                           colorTexture() const;
        void                                                    setColorTexture( MTL::Texture* colorTexture );

        MTL::Texture*                                           depthTexture() const;
        void                                                    setDepthTexture( MTL::Texture* depthTexture );

        MTL::Texture*                                           motionTexture() const;
        void                                                    setMotionTexture( MTL::Texture* motionTexture );

        MTL::Texture*                                           diffuseAlbedoTexture() const;
        void                                                    setDiffuseAlbedoTexture( MTL::Texture* diffuseAlbedoTexture );

        MTL::Texture*                                           specularAlbedoTexture() const;
        void                                                    setSpecularAlbedoTexture( MTL::Texture* specularAlbedoTexture );

        MTL::Texture*                                           normalTexture() const;
        void                                                    setNormalTexture( MTL::Texture* normalTexture );

        MTL::Texture*                                           roughnessTexture() const;
        void                                                    setRoughnessTexture( MTL::Texture* roughnessTexture );

        MTL::Texture*                                           specularHitDistanceTexture() const;
        void                                                    setSpecularHitDistanceTexture( MTL::Texture* specularHitDistanceTexture );

        MTL::Texture*                                           denoiseStrengthMaskTexture() const;
        void                                                    setDenoiseStrengthMaskTexture( MTL::Texture* denoiseStrengthMaskTexture );

        MTL::Texture*                                           transparencyOverlayTexture() const;
        void                                                    setTransparencyOverlayTexture( MTL::Texture* transparencyOverlayTexture );

        MTL::Texture*                                           outputTexture() const;
        void                                                    setOutputTexture( MTL::Texture* outputTexture );

        MTL::Texture*                                           exposureTexture() const;
        void                                                    setExposureTexture( MTL::Texture* exposureTexture );

        float                                                   preExposure() const;
        void                                                    setPreExposure( float preExposure );

        MTL::Texture*                                           reactiveMaskTexture() const;
        void                                                    setReactiveMaskTexture( MTL::Texture* reactiveMaskTexture );

        float                                                   jitterOffsetX() const;
        void                                                    setJitterOffsetX( float jitterOffsetX );

        float                                                   jitterOffsetY() const;
        void                                                    setJitterOffsetY( float jitterOffsetY );

        float                                                   motionVectorScaleX() const;
        void                                                    setMotionVectorScaleX( float motionVectorScaleX );

        float                                                   motionVectorScaleY() const;
        void                                                    setMotionVectorScaleY( float motionVectorScaleY );

        bool                                                    shouldResetHistory() const;
        void                                                    setShouldResetHistory( bool shouldResetHistory );

        bool                                                    isDepthReversed() const;
        void                                                    setDepthReversed( bool depthReversed );

        MTL::PixelFormat                                        colorTextureFormat() const;
        MTL::PixelFormat                                        depthTextureFormat() const;
        MTL::PixelFormat                                        motionTextureFormat() const;
        MTL::PixelFormat                                        diffuseAlbedoTextureFormat() const;
        MTL::PixelFormat                                        specularAlbedoTextureFormat() const;
        MTL::PixelFormat                                        normalTextureFormat() const;
        MTL::PixelFormat                                        roughnessTextureFormat() const;
        MTL::PixelFormat                                        specularHitDistanceTextureFormat() const;
        MTL::PixelFormat                                        denoiseStrengthMaskTextureFormat() const;
        MTL::PixelFormat                                        transparencyOverlayTextureFormat() const;
        MTL::PixelFormat                                        reactiveMaskTextureFormat() const;
        MTL::PixelFormat                                        outputTextureFormat() const;

        NS::UInteger                                            inputWidth() const;
        NS::UInteger                                            inputHeight() const;
        NS::UInteger                                            outputWidth() const;
        NS::UInteger                                            outputHeight() const;
        float                                                   inputContentMinScale() const;
        float                                                   inputContentMaxScale() const;

        simd::float4x4                                          worldToViewMatrix() const;
        void                                                    setWorldToViewMatrix( simd::float4x4 worldToViewMatrix );

        simd::float4x4                                          viewToClipMatrix() const;
        void                                                    setViewToClipMatrix( simd::float4x4 viewToClipMatrix );

        MTL::Fence*                                             fence() const;
        void                                                    setFence( MTL::Fence* fence );
    };

    class TemporalDenoisedScaler : public NS::Referencing< TemporalDenoisedScaler, TemporalDenoisedScalerBase >
    {
    public:

        void                                                    encodeToCommandBuffer(MTL::CommandBuffer* commandBuffer);
    };
}

_MTLFX_INLINE MTLFX::TemporalDenoisedScalerDescriptor* MTLFX::TemporalDenoisedScalerDescriptor::alloc()
{
    return NS::Object::alloc< TemporalDenoisedScalerDescriptor >( _MTLFX_PRIVATE_CLS( MTLFXTemporalDenoisedScalerDescriptor ) );
}

_MTLFX_INLINE MTLFX::TemporalDenoisedScalerDescriptor* MTLFX::TemporalDenoisedScalerDescriptor::init()
{
    return NS::Object::init< TemporalDenoisedScalerDescriptor >();
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerDescriptor::colorTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( colorTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setColorTextureFormat( MTL::PixelFormat pixelFormat )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setColorTextureFormat_ ), pixelFormat );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerDescriptor::depthTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( depthTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setDepthTextureFormat( MTL::PixelFormat pixelFormat )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setDepthTextureFormat_ ), pixelFormat );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerDescriptor::motionTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( motionTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setMotionTextureFormat( MTL::PixelFormat pixelFormat )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setMotionTextureFormat_ ), pixelFormat );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerDescriptor::diffuseAlbedoTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( diffuseAlbedoTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setDiffuseAlbedoTextureFormat( MTL::PixelFormat pixelFormat )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setDiffuseAlbedoTextureFormat_ ), pixelFormat );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerDescriptor::specularAlbedoTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( specularAlbedoTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setSpecularAlbedoTextureFormat( MTL::PixelFormat pixelFormat )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setSpecularAlbedoTextureFormat_ ), pixelFormat );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerDescriptor::normalTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( normalTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setNormalTextureFormat( MTL::PixelFormat pixelFormat )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setNormalTextureFormat_ ), pixelFormat );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerDescriptor::roughnessTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( roughnessTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setRoughnessTextureFormat( MTL::PixelFormat pixelFormat )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setRoughnessTextureFormat_ ), pixelFormat );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerDescriptor::specularHitDistanceTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( specularHitDistanceTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setSpecularHitDistanceTextureFormat( MTL::PixelFormat pixelFormat )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setSpecularHitDistanceTextureFormat_ ), pixelFormat );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerDescriptor::denoiseStrengthMaskTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( denoiseStrengthMaskTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setDenoiseStrengthMaskTextureFormat( MTL::PixelFormat pixelFormat )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setDenoiseStrengthMaskTextureFormat_ ), pixelFormat );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerDescriptor::transparencyOverlayTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( transparencyOverlayTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setTransparencyOverlayTextureFormat( MTL::PixelFormat pixelFormat )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setTransparencyOverlayTextureFormat_ ), pixelFormat );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerDescriptor::outputTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( outputTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setOutputTextureFormat( MTL::PixelFormat pixelFormat )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setOutputTextureFormat_ ), pixelFormat );
}

_MTLFX_INLINE NS::UInteger MTLFX::TemporalDenoisedScalerDescriptor::inputWidth() const
{
    return NS::Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputWidth ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setInputWidth( NS::UInteger inputWidth )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setInputWidth_ ), inputWidth );
}

_MTLFX_INLINE NS::UInteger MTLFX::TemporalDenoisedScalerDescriptor::inputHeight() const
{
    return NS::Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputHeight ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setInputHeight( NS::UInteger inputHeight )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setInputHeight_ ), inputHeight );
}

_MTLFX_INLINE NS::UInteger MTLFX::TemporalDenoisedScalerDescriptor::outputWidth() const
{
    return NS::Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( outputWidth ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setOutputWidth( NS::UInteger outputWidth )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setOutputWidth_ ), outputWidth );
}

_MTLFX_INLINE NS::UInteger MTLFX::TemporalDenoisedScalerDescriptor::outputHeight() const
{
    return NS::Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( outputHeight ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setOutputHeight( NS::UInteger outputHeight )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setOutputHeight_ ), outputHeight );
}

_MTLFX_INLINE bool MTLFX::TemporalDenoisedScalerDescriptor::requiresSynchronousInitialization() const
{
    return NS::Object::sendMessage< bool >( this, _MTLFX_PRIVATE_SEL( requiresSynchronousInitialization ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setRequiresSynchronousInitialization( bool requiresSynchronousInitialization )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setRequiresSynchronousInitialization_ ), requiresSynchronousInitialization );
}

_MTLFX_INLINE bool MTLFX::TemporalDenoisedScalerDescriptor::isAutoExposureEnabled() const
{
    return NS::Object::sendMessage< bool >( this, _MTLFX_PRIVATE_SEL( isAutoExposureEnabled ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setAutoExposureEnabled( bool enabled )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setAutoExposureEnabled_ ), enabled );
}

_MTLFX_INLINE bool MTLFX::TemporalDenoisedScalerDescriptor::isInputContentPropertiesEnabled() const
{
    return NS::Object::sendMessage< bool >( this, _MTLFX_PRIVATE_SEL( isInputContentPropertiesEnabled ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setInputContentPropertiesEnabled( bool enabled )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setInputContentPropertiesEnabled_ ), enabled );
}

_MTLFX_INLINE float MTLFX::TemporalDenoisedScalerDescriptor::inputContentMinScale() const
{
    return NS::Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( inputContentMinScale ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setInputContentMinScale( float inputContentMinScale )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setInputContentMinScale_ ), inputContentMinScale );
}

_MTLFX_INLINE float MTLFX::TemporalDenoisedScalerDescriptor::inputContentMaxScale() const
{
    return NS::Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( inputContentMaxScale ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setInputContentMaxScale( float inputContentMaxScale )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setInputContentMaxScale_ ), inputContentMaxScale );
}

_MTLFX_INLINE bool MTLFX::TemporalDenoisedScalerDescriptor::isReactiveMaskTextureEnabled() const
{
    return NS::Object::sendMessage< bool >( this, _MTLFX_PRIVATE_SEL( isReactiveMaskTextureEnabled ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setReactiveMaskTextureEnabled( bool enabled )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setReactiveMaskTextureEnabled_ ), enabled );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerDescriptor::reactiveMaskTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( reactiveMaskTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setReactiveMaskTextureFormat( MTL::PixelFormat pixelFormat )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setReactiveMaskTextureFormat_ ), pixelFormat );
}

_MTLFX_INLINE bool MTLFX::TemporalDenoisedScalerDescriptor::isSpecularHitDistanceTextureEnabled() const
{
    return NS::Object::sendMessage< bool >( this, _MTLFX_PRIVATE_SEL( isSpecularHitDistanceTextureEnabled ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setSpecularHitDistanceTextureEnabled( bool enabled )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setSpecularHitDistanceTextureEnabled_ ), enabled );
}

_MTLFX_INLINE bool MTLFX::TemporalDenoisedScalerDescriptor::isDenoiseStrengthMaskTextureEnabled() const
{
    return NS::Object::sendMessage< bool >( this, _MTLFX_PRIVATE_SEL( isDenoiseStrengthMaskTextureEnabled ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setDenoiseStrengthMaskTextureEnabled( bool enabled )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setDenoiseStrengthMaskTextureEnabled_ ), enabled );
}

_MTLFX_INLINE bool MTLFX::TemporalDenoisedScalerDescriptor::isTransparencyOverlayTextureEnabled() const
{
    return NS::Object::sendMessage< bool >( this, _MTLFX_PRIVATE_SEL( isTransparencyOverlayTextureEnabled ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerDescriptor::setTransparencyOverlayTextureEnabled( bool enabled )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setTransparencyOverlayTextureEnabled_ ), enabled );
}

_MTLFX_INLINE MTLFX::TemporalDenoisedScaler* MTLFX::TemporalDenoisedScalerDescriptor::newTemporalDenoisedScaler( const MTL::Device* device ) const
{
    return NS::Object::sendMessage< TemporalDenoisedScaler* >( this, _MTLFX_PRIVATE_SEL( newTemporalDenoisedScalerWithDevice_ ), device );
}

_MTLFX_INLINE MTL4FX::TemporalDenoisedScaler* MTLFX::TemporalDenoisedScalerDescriptor::newTemporalDenoisedScaler( const MTL::Device* device, const MTL4::Compiler* compiler ) const
{
    return NS::Object::sendMessage< MTL4FX::TemporalDenoisedScaler* >( this, _MTLFX_PRIVATE_SEL( newTemporalDenoisedScalerWithDevice_compiler_ ), device, compiler );
}

_MTLFX_INLINE float MTLFX::TemporalDenoisedScalerDescriptor::supportedInputContentMinScale( MTL::Device* pDevice )
{
    float scale = 1.0f;

    if ( nullptr != methodSignatureForSelector( _MTLFX_PRIVATE_CLS( MTLFXTemporalDenoisedScalerDescriptor ), _MTLFX_PRIVATE_SEL( supportedInputContentMinScaleForDevice_ ) ) )
    {
        scale = sendMessage< float >( _NS_PRIVATE_CLS( MTLFXTemporalDenoisedScalerDescriptor ), _MTLFX_PRIVATE_SEL( supportedInputContentMinScaleForDevice_ ), pDevice );
    }

    return scale;
}

_MTLFX_INLINE float MTLFX::TemporalDenoisedScalerDescriptor::supportedInputContentMaxScale( MTL::Device* pDevice )
{
    float scale = 1.0f;

    if ( nullptr != methodSignatureForSelector( _MTLFX_PRIVATE_CLS( MTLFXTemporalDenoisedScalerDescriptor ), _MTLFX_PRIVATE_SEL( supportedInputContentMaxScaleForDevice_ ) ) )
    {
        scale = sendMessage< float >( _MTLFX_PRIVATE_CLS( MTLFXTemporalDenoisedScalerDescriptor ), _MTLFX_PRIVATE_SEL( supportedInputContentMaxScaleForDevice_ ), pDevice );
    }
    else if ( supportsDevice( pDevice ) )
    {
        scale = 2.0f;
    }

    return scale;
}

_MTLFX_INLINE bool MTLFX::TemporalDenoisedScalerDescriptor::supportsMetal4FX( MTL::Device* device )
{
    return NS::Object::sendMessageSafe< bool >( _MTLFX_PRIVATE_CLS(MTLFXTemporalDenoisedScalerDescriptor), _MTLFX_PRIVATE_SEL( supportsMetal4FX_ ), device );
}

_MTLFX_INLINE bool MTLFX::TemporalDenoisedScalerDescriptor::supportsDevice( MTL::Device* device )
{
    return NS::Object::sendMessageSafe< bool >( _MTLFX_PRIVATE_CLS(MTLFXTemporalDenoisedScalerDescriptor), _MTLFX_PRIVATE_SEL( supportsDevice_ ), device );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::TemporalDenoisedScalerBase::colorTextureUsage() const
{
    return NS::Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( colorTextureUsage ) );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::TemporalDenoisedScalerBase::depthTextureUsage() const
{
    return NS::Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( depthTextureUsage ) );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::TemporalDenoisedScalerBase::motionTextureUsage() const
{
    return NS::Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( motionTextureUsage ) );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::TemporalDenoisedScalerBase::reactiveTextureUsage() const
{
    return NS::Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( reactiveTextureUsage ) );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::TemporalDenoisedScalerBase::diffuseAlbedoTextureUsage() const
{
    return NS::Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( diffuseAlbedoTextureUsage ) );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::TemporalDenoisedScalerBase::specularAlbedoTextureUsage() const
{
    return NS::Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( specularAlbedoTextureUsage ) );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::TemporalDenoisedScalerBase::normalTextureUsage() const
{
    return NS::Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( normalTextureUsage ) );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::TemporalDenoisedScalerBase::roughnessTextureUsage() const
{
    return NS::Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( roughnessTextureUsage ) );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::TemporalDenoisedScalerBase::specularHitDistanceTextureUsage() const
{
    return NS::Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( specularHitDistanceTextureUsage ) );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::TemporalDenoisedScalerBase::denoiseStrengthMaskTextureUsage() const
{
    return NS::Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( denoiseStrengthMaskTextureUsage ) );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::TemporalDenoisedScalerBase::transparencyOverlayTextureUsage() const
{
    return NS::Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( transparencyOverlayTextureUsage ) );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::TemporalDenoisedScalerBase::outputTextureUsage() const
{
    return NS::Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( outputTextureUsage ) );
}

_MTLFX_INLINE MTL::Texture* MTLFX::TemporalDenoisedScalerBase::colorTexture() const
{
    return NS::Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( colorTexture ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setColorTexture( MTL::Texture* colorTexture )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setColorTexture_ ), colorTexture );
}

_MTLFX_INLINE MTL::Texture* MTLFX::TemporalDenoisedScalerBase::depthTexture() const
{
    return NS::Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( depthTexture ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setDepthTexture( MTL::Texture* depthTexture )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setDepthTexture_ ), depthTexture );
}

_MTLFX_INLINE MTL::Texture* MTLFX::TemporalDenoisedScalerBase::motionTexture() const
{
    return NS::Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( motionTexture ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setMotionTexture( MTL::Texture* motionTexture )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setMotionTexture_ ), motionTexture );
}

_MTLFX_INLINE MTL::Texture* MTLFX::TemporalDenoisedScalerBase::diffuseAlbedoTexture() const
{
    return NS::Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( diffuseAlbedoTexture ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setDiffuseAlbedoTexture( MTL::Texture* diffuseAlbedoTexture )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setDiffuseAlbedoTexture_ ), diffuseAlbedoTexture );
}

_MTLFX_INLINE MTL::Texture* MTLFX::TemporalDenoisedScalerBase::specularAlbedoTexture() const
{
    return NS::Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( specularAlbedoTexture ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setSpecularAlbedoTexture( MTL::Texture* specularAlbedoTexture )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setSpecularAlbedoTexture_ ), specularAlbedoTexture );
}

_MTLFX_INLINE MTL::Texture* MTLFX::TemporalDenoisedScalerBase::normalTexture() const
{
    return NS::Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( normalTexture ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setNormalTexture( MTL::Texture* normalTexture )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setNormalTexture_ ), normalTexture );
}

_MTLFX_INLINE MTL::Texture* MTLFX::TemporalDenoisedScalerBase::roughnessTexture() const
{
    return NS::Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( roughnessTexture ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setRoughnessTexture( MTL::Texture* roughnessTexture )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setRoughnessTexture_ ), roughnessTexture );
}

_MTLFX_INLINE MTL::Texture* MTLFX::TemporalDenoisedScalerBase::specularHitDistanceTexture() const
{
    return NS::Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( specularHitDistanceTexture ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setSpecularHitDistanceTexture( MTL::Texture* specularHitDistanceTexture )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setSpecularHitDistanceTexture_ ), specularHitDistanceTexture );
}

_MTLFX_INLINE MTL::Texture* MTLFX::TemporalDenoisedScalerBase::denoiseStrengthMaskTexture() const
{
    return NS::Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( denoiseStrengthMaskTexture ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setDenoiseStrengthMaskTexture( MTL::Texture* denoiseStrengthMaskTexture )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setDenoiseStrengthMaskTexture_ ), denoiseStrengthMaskTexture );
}

_MTLFX_INLINE MTL::Texture* MTLFX::TemporalDenoisedScalerBase::transparencyOverlayTexture() const
{
    return NS::Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( transparencyOverlayTexture ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setTransparencyOverlayTexture( MTL::Texture* transparencyOverlayTexture )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setTransparencyOverlayTexture_ ), transparencyOverlayTexture );
}

_MTLFX_INLINE MTL::Texture* MTLFX::TemporalDenoisedScalerBase::outputTexture() const
{
    return NS::Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( outputTexture ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setOutputTexture( MTL::Texture* outputTexture )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setOutputTexture_ ), outputTexture );
}

_MTLFX_INLINE MTL::Texture* MTLFX::TemporalDenoisedScalerBase::exposureTexture() const
{
    return NS::Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( exposureTexture ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setExposureTexture( MTL::Texture* exposureTexture )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setExposureTexture_ ), exposureTexture );
}

_MTLFX_INLINE float MTLFX::TemporalDenoisedScalerBase::preExposure() const
{
    return NS::Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( preExposure ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setPreExposure( float preExposure )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setPreExposure_ ), preExposure );
}

_MTLFX_INLINE MTL::Texture* MTLFX::TemporalDenoisedScalerBase::reactiveMaskTexture() const
{
    return NS::Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( reactiveMaskTexture ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setReactiveMaskTexture( MTL::Texture* reactiveMaskTexture )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setReactiveMaskTexture_ ), reactiveMaskTexture );
}

_MTLFX_INLINE float MTLFX::TemporalDenoisedScalerBase::jitterOffsetX() const
{
    return NS::Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( jitterOffsetX ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setJitterOffsetX( float jitterOffsetX )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setJitterOffsetX_ ), jitterOffsetX );
}

_MTLFX_INLINE float MTLFX::TemporalDenoisedScalerBase::jitterOffsetY() const
{
    return NS::Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( jitterOffsetY ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setJitterOffsetY( float jitterOffsetY )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setJitterOffsetY_ ), jitterOffsetY );
}

_MTLFX_INLINE float MTLFX::TemporalDenoisedScalerBase::motionVectorScaleX() const
{
    return NS::Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( motionVectorScaleX ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setMotionVectorScaleX( float motionVectorScaleX )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setMotionVectorScaleX_ ), motionVectorScaleX );
}

_MTLFX_INLINE float MTLFX::TemporalDenoisedScalerBase::motionVectorScaleY() const
{
    return NS::Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( motionVectorScaleY ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setMotionVectorScaleY( float motionVectorScaleY )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setMotionVectorScaleY_ ), motionVectorScaleY );
}

_MTLFX_INLINE bool MTLFX::TemporalDenoisedScalerBase::shouldResetHistory() const
{
    return NS::Object::sendMessage< bool >( this, _MTLFX_PRIVATE_SEL( shouldResetHistory ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setShouldResetHistory( bool shouldResetHistory )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setShouldResetHistory_ ), shouldResetHistory );
}

_MTLFX_INLINE bool MTLFX::TemporalDenoisedScalerBase::isDepthReversed() const
{
    return NS::Object::sendMessage< bool >( this, _MTLFX_PRIVATE_SEL( isDepthReversed ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setDepthReversed( bool depthReversed )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setDepthReversed_ ), depthReversed );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerBase::colorTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( colorTextureFormat ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerBase::depthTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( depthTextureFormat ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerBase::motionTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( motionTextureFormat ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerBase::diffuseAlbedoTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( diffuseAlbedoTextureFormat ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerBase::specularAlbedoTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( specularAlbedoTextureFormat ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerBase::normalTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( normalTextureFormat ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerBase::roughnessTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( roughnessTextureFormat ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerBase::specularHitDistanceTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( specularHitDistanceTextureFormat ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerBase::denoiseStrengthMaskTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( denoiseStrengthMaskTextureFormat ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerBase::transparencyOverlayTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( transparencyOverlayTextureFormat ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerBase::reactiveMaskTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( reactiveMaskTextureFormat ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::TemporalDenoisedScalerBase::outputTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( outputTextureFormat ) );
}

_MTLFX_INLINE NS::UInteger MTLFX::TemporalDenoisedScalerBase::inputWidth() const
{
    return NS::Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputWidth ) );
}

_MTLFX_INLINE NS::UInteger MTLFX::TemporalDenoisedScalerBase::inputHeight() const
{
    return NS::Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputHeight ) );
}

_MTLFX_INLINE NS::UInteger MTLFX::TemporalDenoisedScalerBase::outputWidth() const
{
    return NS::Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( outputWidth ) );
}

_MTLFX_INLINE NS::UInteger MTLFX::TemporalDenoisedScalerBase::outputHeight() const
{
    return NS::Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( outputHeight ) );
}

_MTLFX_INLINE float MTLFX::TemporalDenoisedScalerBase::inputContentMinScale() const
{
    return NS::Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( inputContentMinScale ) );
}

_MTLFX_INLINE float MTLFX::TemporalDenoisedScalerBase::inputContentMaxScale() const
{
    return NS::Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( inputContentMaxScale ) );
}

_MTLFX_INLINE simd::float4x4 MTLFX::TemporalDenoisedScalerBase::worldToViewMatrix() const
{
    return NS::Object::sendMessage< simd::float4x4 >( this, _MTLFX_PRIVATE_SEL( worldToViewMatrix ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setWorldToViewMatrix( simd::float4x4 worldToViewMatrix )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setWorldToViewMatrix_ ), worldToViewMatrix );
}

_MTLFX_INLINE simd::float4x4 MTLFX::TemporalDenoisedScalerBase::viewToClipMatrix() const
{
    return NS::Object::sendMessage< simd::float4x4 >( this, _MTLFX_PRIVATE_SEL( viewToClipMatrix ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setViewToClipMatrix( simd::float4x4 viewToClipMatrix )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setViewToClipMatrix_ ), viewToClipMatrix );
}

_MTLFX_INLINE MTL::Fence* MTLFX::TemporalDenoisedScalerBase::fence() const
{
    return NS::Object::sendMessage< MTL::Fence* >( this, _MTLFX_PRIVATE_SEL( fence ) );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScalerBase::setFence( MTL::Fence* fence )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setFence_ ), fence );
}

_MTLFX_INLINE void MTLFX::TemporalDenoisedScaler::encodeToCommandBuffer( MTL::CommandBuffer* commandBuffer )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( encodeToCommandBuffer_ ), commandBuffer );
}

namespace MTL4FX
{
    class TemporalScaler;
    class TemporalDenoisedScaler;
    class FrameInterpolator;
}

namespace MTLFX
{
    class FrameInterpolatorDescriptor : public NS::Copying< FrameInterpolatorDescriptor >
    {
    public:
        static FrameInterpolatorDescriptor* alloc();
        FrameInterpolatorDescriptor*        init();

        MTL::PixelFormat                    colorTextureFormat() const;
        void                                setColorTextureFormat(MTL::PixelFormat colorTextureFormat);

        MTL::PixelFormat                    outputTextureFormat() const;
        void                                setOutputTextureFormat(MTL::PixelFormat outputTextureFormat);

        MTL::PixelFormat                    depthTextureFormat() const;
        void                                setDepthTextureFormat(MTL::PixelFormat depthTextureFormat);

        MTL::PixelFormat                    motionTextureFormat() const;
        void                                setMotionTextureFormat(MTL::PixelFormat motionTextureFormat);

        MTL::PixelFormat                    uiTextureFormat() const;
        void                                setUITextureFormat(MTL::PixelFormat uiTextureFormat);

        MTLFX::FrameInterpolatableScaler*   scaler() const;
        void                                setScaler(MTLFX::FrameInterpolatableScaler* scaler);

        NS::UInteger                        inputWidth() const;
        void                                setInputWidth( NS::UInteger inputWidth );

        NS::UInteger                        inputHeight() const;
        void                                setInputHeight( NS::UInteger inputHeight );

        NS::UInteger                        outputWidth() const;
        void                                setOutputWidth( NS::UInteger outputWidth );

        NS::UInteger                        outputHeight() const;
        void                                setOutputHeight( NS::UInteger outputHeight );

        class FrameInterpolator*            newFrameInterpolator( const MTL::Device* pDevice) const;
        MTL4FX::FrameInterpolator*          newFrameInterpolator( const MTL::Device* pDevice, const MTL4::Compiler* pCompiler) const;

        static bool                         supportsMetal4FX(MTL::Device* device);
        static bool                         supportsDevice(MTL::Device* device);
    };

    class FrameInterpolatorBase : public NS::Referencing<FrameInterpolatorBase>
    {
    public:
        MTL::TextureUsage colorTextureUsage() const;
        MTL::TextureUsage outputTextureUsage() const;
        MTL::TextureUsage depthTextureUsage() const;
        MTL::TextureUsage motionTextureUsage() const;
        MTL::TextureUsage uiTextureUsage() const;

        MTL::PixelFormat  colorTextureFormat() const;
        MTL::PixelFormat  depthTextureFormat() const;
        MTL::PixelFormat  motionTextureFormat() const;
        MTL::PixelFormat  outputTextureFormat() const;

        NS::UInteger      inputWidth() const;
        NS::UInteger      inputHeight() const;
        NS::UInteger      outputWidth() const;
        NS::UInteger      outputHeight() const;
        MTL::PixelFormat  uiTextureFormat() const;

        MTL::Texture*     colorTexture() const;
        void              setColorTexture(MTL::Texture* colorTexture);

        MTL::Texture*     prevColorTexture() const;
        void              setPrevColorTexture(MTL::Texture* prevColorTexture);

        MTL::Texture*     depthTexture() const;
        void              setDepthTexture(MTL::Texture* depthTexture);

        MTL::Texture*     motionTexture() const;
        void              setMotionTexture(MTL::Texture* motionTexture);

        float             motionVectorScaleX() const;
        void              setMotionVectorScaleX(float scaleX);

        float             motionVectorScaleY() const;
        void              setMotionVectorScaleY(float scaleY);

        float             deltaTime() const;
        void              setDeltaTime( float deltaTime );

        float             nearPlane() const;
        void              setNearPlane( float nearPlane );

        float             farPlane() const;
        void              setFarPlane( float farPlane );

        float             fieldOfView() const;
        void              setFieldOfView( float fieldOfView );

        float             aspectRatio() const;
        void              setAspectRatio( float aspectRatio );

        MTL::Texture*     uiTexture() const;
        void              setUITexture(MTL::Texture* uiTexture);

        float             jitterOffsetX() const;
        void              setJitterOffsetX( float jitterOffsetX );

        float             jitterOffsetY() const;
        void              setJitterOffsetY( float jitterOffsetY );

        bool              isUITextureComposited() const;
        void              setIsUITextureComposited( bool uiTextureComposited );

        bool              shouldResetHistory() const;
        void              setShouldResetHistory( bool shouldResetHistory );

        MTL::Texture*     outputTexture() const;
        void              setOutputTexture( MTL::Texture* outputTexture );

        MTL::Fence*       fence() const;
        void              setFence( MTL::Fence* fence );

        bool              isDepthReversed() const;
        void              setDepthReversed( bool depthReversed );
    };

    class FrameInterpolator : public NS::Referencing<FrameInterpolator, FrameInterpolatorBase>
    {
    public:
        void              encodeToCommandBuffer(MTL::CommandBuffer* commandBuffer);
    };

}

_MTLFX_INLINE MTLFX::FrameInterpolatorDescriptor* MTLFX::FrameInterpolatorDescriptor::alloc()
{
    return NS::Object::alloc< FrameInterpolatorDescriptor >( _MTLFX_PRIVATE_CLS( MTLFXFrameInterpolatorDescriptor ) );
}

_MTLFX_INLINE MTLFX::FrameInterpolatorDescriptor* MTLFX::FrameInterpolatorDescriptor::init()
{
    return NS::Object::init< FrameInterpolatorDescriptor >();
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::FrameInterpolatorDescriptor::colorTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( colorTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorDescriptor::setColorTextureFormat( MTL::PixelFormat colorTextureFormat )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setColorTextureFormat_ ), colorTextureFormat );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::FrameInterpolatorDescriptor::outputTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( outputTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorDescriptor::setOutputTextureFormat( MTL::PixelFormat outputTextureFormat )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setOutputTextureFormat_ ), outputTextureFormat );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::FrameInterpolatorDescriptor::depthTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( depthTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorDescriptor::setDepthTextureFormat( MTL::PixelFormat depthTextureFormat )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setDepthTextureFormat_ ), depthTextureFormat );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::FrameInterpolatorDescriptor::motionTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( motionTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorDescriptor::setMotionTextureFormat( MTL::PixelFormat motionTextureFormat )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setMotionTextureFormat_ ), motionTextureFormat );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::FrameInterpolatorDescriptor::uiTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( uiTextureFormat ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorDescriptor::setUITextureFormat( MTL::PixelFormat uiTextureFormat )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setUITextureFormat_ ), uiTextureFormat );
}

_MTLFX_INLINE MTLFX::FrameInterpolatableScaler* MTLFX::FrameInterpolatorDescriptor::scaler() const
{
    return NS::Object::sendMessage< MTLFX::FrameInterpolatableScaler* >( this, _MTLFX_PRIVATE_SEL( scaler ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorDescriptor::setScaler(MTLFX::FrameInterpolatableScaler* scaler)
{
    NS::Object::sendMessage< void >(this, _MTLFX_PRIVATE_SEL( setScaler_ ), scaler );
}

_MTLFX_INLINE NS::UInteger MTLFX::FrameInterpolatorDescriptor::inputWidth() const
{
    return NS::Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputWidth ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorDescriptor::setInputWidth( NS::UInteger inputWidth )
{
    NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setInputWidth_ ), inputWidth );
}

_MTLFX_INLINE NS::UInteger MTLFX::FrameInterpolatorDescriptor::inputHeight() const
{
    return NS::Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputHeight ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorDescriptor::setInputHeight( NS::UInteger inputHeight )
{
    NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setInputHeight_ ), inputHeight );
}

_MTLFX_INLINE NS::UInteger MTLFX::FrameInterpolatorDescriptor::outputWidth() const
{
    return NS::Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( outputWidth ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorDescriptor::setOutputWidth( NS::UInteger outputWidth )
{
    NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setOutputWidth_ ), outputWidth );
}

_MTLFX_INLINE NS::UInteger MTLFX::FrameInterpolatorDescriptor::outputHeight() const
{
    return NS::Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( outputHeight ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorDescriptor::setOutputHeight( NS::UInteger outputHeight )
{
    NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setOutputHeight_ ), outputHeight );
}

_MTLFX_INLINE MTLFX::FrameInterpolator* MTLFX::FrameInterpolatorDescriptor::newFrameInterpolator( const MTL::Device* device ) const
{
    return NS::Object::sendMessage< MTLFX::FrameInterpolator* >( this, _MTLFX_PRIVATE_SEL( newFrameInterpolatorWithDevice_ ), device );
}

_MTLFX_INLINE MTL4FX::FrameInterpolator* MTLFX::FrameInterpolatorDescriptor::newFrameInterpolator( const MTL::Device* device, const MTL4::Compiler* compiler ) const
{
    return NS::Object::sendMessage< MTL4FX::FrameInterpolator* >( this, _MTLFX_PRIVATE_SEL( newFrameInterpolatorWithDevice_compiler_ ), device, compiler );
}

_MTLFX_INLINE bool MTLFX::FrameInterpolatorDescriptor::supportsMetal4FX(MTL::Device* device)
{
    return NS::Object::sendMessageSafe< bool >( _MTLFX_PRIVATE_CLS(MTLFXFrameInterpolatorDescriptor), _MTLFX_PRIVATE_SEL( supportsMetal4FX_ ), device );
}

_MTLFX_INLINE bool MTLFX::FrameInterpolatorDescriptor::supportsDevice(MTL::Device* device)
{
    return NS::Object::sendMessageSafe< bool >( _MTLFX_PRIVATE_CLS(MTLFXFrameInterpolatorDescriptor), _MTLFX_PRIVATE_SEL( supportsDevice_ ), device );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::FrameInterpolatorBase::colorTextureUsage() const
{
    return NS::Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( colorTextureUsage ) );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::FrameInterpolatorBase::outputTextureUsage() const
{
    return NS::Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( outputTextureUsage ) );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::FrameInterpolatorBase::depthTextureUsage() const
{
    return NS::Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( depthTextureUsage ) );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::FrameInterpolatorBase::motionTextureUsage() const
{
    return NS::Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( motionTextureUsage ) );
}

_MTLFX_INLINE MTL::TextureUsage MTLFX::FrameInterpolatorBase::uiTextureUsage() const
{
    return NS::Object::sendMessage< MTL::TextureUsage >( this, _MTLFX_PRIVATE_SEL( uiTextureUsage ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::FrameInterpolatorBase::colorTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( colorTextureFormat ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::FrameInterpolatorBase::depthTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( depthTextureFormat ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::FrameInterpolatorBase::motionTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( motionTextureFormat ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::FrameInterpolatorBase::outputTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( outputTextureFormat ) );
}

_MTLFX_INLINE NS::UInteger MTLFX::FrameInterpolatorBase::inputWidth() const
{
    return NS::Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputWidth ) );
}

_MTLFX_INLINE NS::UInteger MTLFX::FrameInterpolatorBase::inputHeight() const
{
    return NS::Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( inputHeight ) );
}

_MTLFX_INLINE NS::UInteger MTLFX::FrameInterpolatorBase::outputWidth() const
{
    return NS::Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( outputWidth ) );
}

_MTLFX_INLINE NS::UInteger MTLFX::FrameInterpolatorBase::outputHeight() const
{
    return NS::Object::sendMessage< NS::UInteger >( this, _MTLFX_PRIVATE_SEL( outputHeight ) );
}

_MTLFX_INLINE MTL::PixelFormat MTLFX::FrameInterpolatorBase::uiTextureFormat() const
{
    return NS::Object::sendMessage< MTL::PixelFormat >( this, _MTLFX_PRIVATE_SEL( uiTextureFormat ) );
}

_MTLFX_INLINE MTL::Texture* MTLFX::FrameInterpolatorBase::colorTexture() const
{
    return NS::Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( colorTexture ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorBase::setColorTexture(MTL::Texture* colorTexture)
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setColorTexture_ ), colorTexture );
}

_MTLFX_INLINE MTL::Texture* MTLFX::FrameInterpolatorBase::prevColorTexture() const
{
    return NS::Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( prevColorTexture ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorBase::setPrevColorTexture(MTL::Texture* prevColorTexture)
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setPrevColorTexture_ ), prevColorTexture );
}

_MTLFX_INLINE MTL::Texture* MTLFX::FrameInterpolatorBase::depthTexture() const
{
    return NS::Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( depthTexture ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorBase::setDepthTexture(MTL::Texture* depthTexture)
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setDepthTexture_ ), depthTexture );
}

_MTLFX_INLINE MTL::Texture* MTLFX::FrameInterpolatorBase::motionTexture() const
{
    return NS::Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( motionTexture ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorBase::setMotionTexture(MTL::Texture* motionTexture)
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setMotionTexture_ ), motionTexture );
}

_MTLFX_INLINE float MTLFX::FrameInterpolatorBase::motionVectorScaleX() const
{
    return NS::Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( motionVectorScaleX ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorBase::setMotionVectorScaleX(float scaleX)
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setMotionVectorScaleX_ ), scaleX );
}

_MTLFX_INLINE float MTLFX::FrameInterpolatorBase::motionVectorScaleY() const
{
    return NS::Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( motionVectorScaleY ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorBase::setMotionVectorScaleY(float scaleY)
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setMotionVectorScaleY_ ), scaleY );
}

_MTLFX_INLINE float  MTLFX::FrameInterpolatorBase::deltaTime() const
{
    return NS::Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( deltaTime ) );
}

_MTLFX_INLINE void   MTLFX::FrameInterpolatorBase::setDeltaTime( float deltaTime )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setDeltaTime_ ), deltaTime );
}

_MTLFX_INLINE float  MTLFX::FrameInterpolatorBase::nearPlane() const
{
    return NS::Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( nearPlane ) );
}

_MTLFX_INLINE void  MTLFX::FrameInterpolatorBase::setNearPlane( float nearPlane )
{
    NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setNearPlane_ ), nearPlane );
}

_MTLFX_INLINE float  MTLFX::FrameInterpolatorBase::farPlane() const
{
    return NS::Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( farPlane ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorBase::setFarPlane( float farPlane )
{
    NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setFarPlane_ ), farPlane );
}

_MTLFX_INLINE float  MTLFX::FrameInterpolatorBase::fieldOfView() const
{
    return NS::Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( fieldOfView ) );
}

_MTLFX_INLINE void   MTLFX::FrameInterpolatorBase::setFieldOfView( float fieldOfView )
{
    NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setFieldOfView_ ), fieldOfView );
}

_MTLFX_INLINE float  MTLFX::FrameInterpolatorBase::aspectRatio() const
{
    return NS::Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( aspectRatio ) );
}

_MTLFX_INLINE void   MTLFX::FrameInterpolatorBase::setAspectRatio( float aspectRatio )
{
    NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setAspectRatio_ ), aspectRatio );
}

_MTLFX_INLINE MTL::Texture* MTLFX::FrameInterpolatorBase::uiTexture() const
{
    return NS::Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( uiTexture ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorBase::setUITexture(MTL::Texture* uiTexture)
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setUITexture_ ), uiTexture );
}

_MTLFX_INLINE float MTLFX::FrameInterpolatorBase::jitterOffsetX() const
{
    return NS::Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( jitterOffsetX ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorBase::setJitterOffsetX( float jitterOffsetX )
{
    NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setJitterOffsetX_ ), jitterOffsetX );
}

_MTLFX_INLINE float MTLFX::FrameInterpolatorBase::jitterOffsetY() const
{
    return NS::Object::sendMessage< float >( this, _MTLFX_PRIVATE_SEL( jitterOffsetY ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorBase::setJitterOffsetY( float jitterOffsetY )
{
    NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setJitterOffsetY_ ), jitterOffsetY );
}

_MTLFX_INLINE bool MTLFX::FrameInterpolatorBase::isUITextureComposited() const
{
    return NS::Object::sendMessage< bool >( this, _MTLFX_PRIVATE_SEL( isUITextureComposited ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorBase::setIsUITextureComposited( bool uiTextureComposited )
{
    NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setIsUITextureComposited_ ), uiTextureComposited );
}

_MTLFX_INLINE bool MTLFX::FrameInterpolatorBase::shouldResetHistory() const
{
    return NS::Object::sendMessage< bool >( this, _MTLFX_PRIVATE_SEL( shouldResetHistory ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorBase::setShouldResetHistory(bool shouldResetHistory)
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setShouldResetHistory_ ), shouldResetHistory );
}

_MTLFX_INLINE MTL::Texture* MTLFX::FrameInterpolatorBase::outputTexture() const
{
    return NS::Object::sendMessage< MTL::Texture* >( this, _MTLFX_PRIVATE_SEL( outputTexture ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorBase::setOutputTexture(MTL::Texture* outputTexture)
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setOutputTexture_ ), outputTexture );
}

_MTLFX_INLINE MTL::Fence* MTLFX::FrameInterpolatorBase::fence() const
{
    return NS::Object::sendMessage< MTL::Fence* >( this, _MTLFX_PRIVATE_SEL( fence ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorBase::setFence(MTL::Fence* fence)
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setFence_ ), fence );
}

_MTLFX_INLINE bool MTLFX::FrameInterpolatorBase::isDepthReversed() const
{
    return NS::Object::sendMessage< bool >( this, _MTLFX_PRIVATE_SEL( isDepthReversed ) );
}

_MTLFX_INLINE void MTLFX::FrameInterpolatorBase::setDepthReversed(bool depthReversed)
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( setDepthReversed_ ), depthReversed );
}

_MTLFX_INLINE void MTLFX::FrameInterpolator::encodeToCommandBuffer(MTL::CommandBuffer* commandBuffer)
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( encodeToCommandBuffer_ ), commandBuffer );
}

namespace MTL4FX
{
    class SpatialScaler : public NS::Referencing< SpatialScaler, MTLFX::SpatialScalerBase >
    {
    public:
        void encodeToCommandBuffer( MTL4::CommandBuffer* pCommandBuffer );
    };
}

_MTLFX_INLINE void MTL4FX::SpatialScaler::encodeToCommandBuffer( MTL4::CommandBuffer* pCommandBuffer )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( encodeToCommandBuffer_ ), pCommandBuffer );
}

namespace MTL4FX
{
    class TemporalScaler : public NS::Referencing< TemporalScaler, MTLFX::TemporalScalerBase >
    {
    public:
        void encodeToCommandBuffer( MTL4::CommandBuffer* pCommandBuffer );
    };
}

_MTLFX_INLINE void MTL4FX::TemporalScaler::encodeToCommandBuffer( MTL4::CommandBuffer* pCommandBuffer )
{
    Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( encodeToCommandBuffer_ ), pCommandBuffer );
}

#include <simd/simd.h>

namespace MTL4FX
{
    class TemporalDenoisedScaler : public NS::Referencing< TemporalDenoisedScaler, MTLFX::TemporalDenoisedScalerBase >
    {
    public:
        void encodeToCommandBuffer(MTL4::CommandBuffer* commandBuffer);
    };
}

_MTLFX_INLINE void MTL4FX::TemporalDenoisedScaler::encodeToCommandBuffer( MTL4::CommandBuffer* commandBuffer )
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( encodeToCommandBuffer_ ), commandBuffer );
}

namespace MTL4FX
{
    class FrameInterpolator : public NS::Referencing<FrameInterpolator, MTLFX::FrameInterpolatorBase>
    {
    public:
        void encodeToCommandBuffer(MTL4::CommandBuffer* commandBuffer);
    };
}

_MTLFX_INLINE void MTL4FX::FrameInterpolator::encodeToCommandBuffer(MTL4::CommandBuffer* commandBuffer)
{
    return NS::Object::sendMessage< void >( this, _MTLFX_PRIVATE_SEL( encodeToCommandBuffer_ ), commandBuffer );
}

#endif
